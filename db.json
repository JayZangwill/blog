{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.2d7529.css","path":"main.2d7529.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.d238ee.js","path":"mobile.d238ee.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.885efe.js","path":"slider.885efe.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.2d7529.js","path":"main.2d7529.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.59e68b.eot","path":"fonts/iconfont.59e68b.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b7ae25.ttf","path":"fonts/iconfont.b7ae25.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.ca3627.woff","path":"fonts/iconfont.ca3627.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.dba24b.svg","path":"fonts/iconfont.dba24b.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"source/img/box/absolute2.png","path":"img/box/absolute2.png","modified":1,"renderable":0},{"_id":"source/img/box/absolute1.png","path":"img/box/absolute1.png","modified":1,"renderable":0},{"_id":"source/img/box/absolute3.png","path":"img/box/absolute3.png","modified":1,"renderable":0},{"_id":"source/img/box/blue.png","path":"img/box/blue.png","modified":1,"renderable":0},{"_id":"source/img/box/border-box.png","path":"img/box/border-box.png","modified":1,"renderable":0},{"_id":"source/img/box/border.png","path":"img/box/border.png","modified":1,"renderable":0},{"_id":"source/img/box/border-width.png","path":"img/box/border-width.png","modified":1,"renderable":0},{"_id":"source/img/box/box-model.png","path":"img/box/box-model.png","modified":1,"renderable":0},{"_id":"source/img/box/box-sizing.png","path":"img/box/box-sizing.png","modified":1,"renderable":0},{"_id":"source/img/box/fixed.png","path":"img/box/fixed.png","modified":1,"renderable":0},{"_id":"source/img/box/margin.png","path":"img/box/margin.png","modified":1,"renderable":0},{"_id":"source/img/box/margin-box.png","path":"img/box/margin-box.png","modified":1,"renderable":0},{"_id":"source/img/box/margin-width.png","path":"img/box/margin-width.png","modified":1,"renderable":0},{"_id":"source/img/box/padding-box.png","path":"img/box/padding-box.png","modified":1,"renderable":0},{"_id":"source/img/box/padding.png","path":"img/box/padding.png","modified":1,"renderable":0},{"_id":"source/img/box/padding-width.png","path":"img/box/padding-width.png","modified":1,"renderable":0},{"_id":"source/img/box/scroll.png","path":"img/box/scroll.png","modified":1,"renderable":0},{"_id":"source/img/box/static.png","path":"img/box/static.png","modified":1,"renderable":0},{"_id":"source/img/box/relative.png","path":"img/box/relative.png","modified":1,"renderable":0},{"_id":"source/img/box/width-box.png","path":"img/box/width-box.png","modified":1,"renderable":0},{"_id":"source/img/box/width.png","path":"img/box/width.png","modified":1,"renderable":0},{"_id":"source/img/box/z-index1.png","path":"img/box/z-index1.png","modified":1,"renderable":0},{"_id":"source/img/cache/cache.png","path":"img/cache/cache.png","modified":1,"renderable":0},{"_id":"source/img/cache/code_200.png","path":"img/cache/code_200.png","modified":1,"renderable":0},{"_id":"source/img/cache/sw-lifecycle.png","path":"img/cache/sw-lifecycle.png","modified":1,"renderable":0},{"_id":"source/img/common/biaoqing1.png","path":"img/common/biaoqing1.png","modified":1,"renderable":0},{"_id":"source/img/common/baobao.jpg","path":"img/common/baobao.jpg","modified":1,"renderable":0},{"_id":"source/img/common/yaoming.jpeg","path":"img/common/yaoming.jpeg","modified":1,"renderable":0},{"_id":"source/img/face/absolute-padding.png","path":"img/face/absolute-padding.png","modified":1,"renderable":0},{"_id":"source/img/face/padding-top.png","path":"img/face/padding-top.png","modified":1,"renderable":0},{"_id":"source/img/face/w3c.png","path":"img/face/w3c.png","modified":1,"renderable":0},{"_id":"source/img/flexible/rpx.png","path":"img/flexible/rpx.png","modified":1,"renderable":0},{"_id":"source/img/img/bitmap.png","path":"img/img/bitmap.png","modified":1,"renderable":0},{"_id":"source/img/img/deep_digit.png","path":"img/img/deep_digit.png","modified":1,"renderable":0},{"_id":"source/img/img/normal.gif","path":"img/img/normal.gif","modified":1,"renderable":0},{"_id":"source/img/img/ps_menu.png","path":"img/img/ps_menu.png","modified":1,"renderable":0},{"_id":"source/img/lineHeight/gay.png","path":"img/lineHeight/gay.png","modified":1,"renderable":0},{"_id":"source/img/lineHeight/gay_2.png","path":"img/lineHeight/gay_2.png","modified":1,"renderable":0},{"_id":"source/img/lineHeight/height.jpg","path":"img/lineHeight/height.jpg","modified":1,"renderable":0},{"_id":"source/img/lineHeight/inline_box.png","path":"img/lineHeight/inline_box.png","modified":1,"renderable":0},{"_id":"source/img/lineHeight/x_height.png","path":"img/lineHeight/x_height.png","modified":1,"renderable":0},{"_id":"source/img/summary/sass.png","path":"img/summary/sass.png","modified":1,"renderable":0},{"_id":"source/img/summary/styles.png","path":"img/summary/styles.png","modified":1,"renderable":0},{"_id":"source/img/summary/task.png","path":"img/summary/task.png","modified":1,"renderable":0},{"_id":"source/img/summary/uglify.png","path":"img/summary/uglify.png","modified":1,"renderable":0},{"_id":"source/img/cache/application.png","path":"img/cache/application.png","modified":1,"renderable":0},{"_id":"source/img/box/z-index-box.png","path":"img/box/z-index-box.png","modified":1,"renderable":0},{"_id":"source/img/cache/cdn_step.png","path":"img/cache/cdn_step.png","modified":1,"renderable":0},{"_id":"source/img/cache/header_2.png","path":"img/cache/header_2.png","modified":1,"renderable":0},{"_id":"source/img/cache/header_1.png","path":"img/cache/header_1.png","modified":1,"renderable":0},{"_id":"source/img/cache/servicework.png","path":"img/cache/servicework.png","modified":1,"renderable":0},{"_id":"source/img/cache/no_cache.png","path":"img/cache/no_cache.png","modified":1,"renderable":0},{"_id":"source/img/cache/step.png","path":"img/cache/step.png","modified":1,"renderable":0},{"_id":"source/img/cache/step_2.png","path":"img/cache/step_2.png","modified":1,"renderable":0},{"_id":"source/img/img/progressive.gif","path":"img/img/progressive.gif","modified":1,"renderable":0},{"_id":"source/img/lineHeight/line_box.png","path":"img/lineHeight/line_box.png","modified":1,"renderable":0},{"_id":"source/img/cache/weizhi_1.gif","path":"img/cache/weizhi_1.gif","modified":1,"renderable":0},{"_id":"source/img/cache/weizhi_2.gif","path":"img/cache/weizhi_2.gif","modified":1,"renderable":0}],"Cache":[{"_id":"themes/yilia/README.md","hash":"0becd9c18f9d44fc364788a34a4f3ec82ca7940a","modified":1586230158015},{"_id":"themes/yilia/_config.yml","hash":"d2e829d4fcc716bdce8f097e9029968cf44d5f08","modified":1586230158016},{"_id":"themes/yilia/package.json","hash":"4631f9013f0b1c5fc5d73af4c3624375bfe4d109","modified":1586230158028},{"_id":"themes/yilia/webpack.config.js","hash":"14fe482547b12b15bc78cb981c42a4ca5b6ba770","modified":1586230158053},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1586230158026},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1586230158026},{"_id":"themes/yilia/layout/index.ejs","hash":"ec498c6c0606acde997ce195dad97b267418d980","modified":1586230158026},{"_id":"themes/yilia/layout/layout.ejs","hash":"b471ab706d48e0be3f783eab1c94bf5878ef5a94","modified":1586230158027},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1586230158027},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1586230158027},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1586230158028},{"_id":"themes/yilia/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1586230158016},{"_id":"themes/yilia/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1586230158016},{"_id":"themes/yilia/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1586230158017},{"_id":"themes/yilia/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1586230158017},{"_id":"themes/yilia/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1586230158017},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1586230158018},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1586230158017},{"_id":"themes/yilia/source-src/css.ejs","hash":"cf7eab48d626433120d1ef9697f719a359817018","modified":1586230158028},{"_id":"themes/yilia/source-src/script.ejs","hash":"28abac2426761d7e715b38aadd86ce6549c8ae77","modified":1586230158046},{"_id":"themes/yilia/source/main.2d7529.css","hash":"2eef112e365f9b00664302ba98b517662c75d411","modified":1586230158051},{"_id":"themes/yilia/source/mobile.d238ee.js","hash":"a054884092af1cc5c2c14e5e11a4dac6d9254481","modified":1586230158052},{"_id":"themes/yilia/source/slider.885efe.js","hash":"41a76cb10a2b344d54a15ffac68d17331fc6f3d6","modified":1586230158053},{"_id":"source/_posts/Basics sass.md","hash":"d3b846a7bbbf5bb49d22c0783edade2be5490496","modified":1586230157928},{"_id":"source/_posts/CSS box model and location.md","hash":"a4ffa91c7086be959f0af751fc13a79277d18148","modified":1586230157928},{"_id":"source/_posts/Hexo+github quickly build personal blog.md","hash":"a494c022ed1e3da5438c0e1b425a39f5691ffe5a","modified":1586230157929},{"_id":"source/_posts/Javscript data type.md","hash":"cb245e2c5cd7540273860f267d9ece4ac8b7facd","modified":1586230157929},{"_id":"source/_posts/Interview in Beijing in April.md","hash":"2dcebbd4d6bbbd7c8bd912799a584445f9a09a93","modified":1586230157929},{"_id":"source/_posts/Some of the interview questions that impressed me-1.md","hash":"193fdb16e65503ebea70e8cce14f6a051a8851b4","modified":1586230157930},{"_id":"source/_posts/Some of the interview questions that impressed me-2.md","hash":"aa5fdd15cbf44fb83be7b510d6bfe4ef7d5a49da","modified":1586230157932},{"_id":"source/_posts/Taste vue.md","hash":"46429b172d743c8c203b4f0ed7ec2a2c83c8deb6","modified":1586230157932},{"_id":"source/_posts/angular Study notes-2.md","hash":"ade6993ee3cb3fa9aa56b65b17312343f082cc13","modified":1586230157932},{"_id":"source/_posts/angular Study notes-3.md","hash":"f6c8a1325a577c8bf1ab713ec431ca7d6b662e0e","modified":1586230157933},{"_id":"source/_posts/angular Study notes.md","hash":"b4a238b5e16a905326a791a4eb3ae3ae65289623","modified":1586230157933},{"_id":"source/_posts/fe-summary.md","hash":"380f213803ca0966ce32238430b376bcd378ee6f","modified":1586230157935},{"_id":"source/_posts/cache.md","hash":"0dfe65ee727e0715fbafd6cdf92a11652e138130","modified":1586230157934},{"_id":"source/_posts/flexible.md","hash":"5788718a6f7d4001cb82d51c091b134ae341f2d2","modified":1586230157935},{"_id":"source/_posts/img-knowledge.md","hash":"555eece0adf24f5b8a4814c8e49bfaddd3997db5","modified":1586255246679},{"_id":"source/_posts/inherit.md","hash":"c0e71d69cf901c1d8b9abcffa567f6ac14916b2d","modified":1586230157936},{"_id":"source/_posts/line-height-and-vertical-align.md","hash":"a96e983ddb4f20ea3c1e5436179899abf390df0b","modified":1586230157937},{"_id":"source/_posts/new-blog.md","hash":"05e851252abb058d48eb4b48de90d85cb409e5ec","modified":1586230157938},{"_id":"source/_posts/mongodb common command.md","hash":"fbb56212f8a9f3887441081f24413a16214e369c","modified":1586230157938},{"_id":"source/_posts/sogou-life.md","hash":"a018c6080ff9019b1cfeb1f8b8ae420630fc1da9","modified":1586230157938},{"_id":"source/_posts/vue-cli-multipage.md","hash":"67970d65415758e43fa4b48e93dd438ea78d2a51","modified":1586230157939},{"_id":"source/tags/index.md","hash":"8b4b1df34f5938a1d17009967d2568fbabf1e66e","modified":1586230157982},{"_id":"themes/yilia/source/main.2d7529.js","hash":"a0359e7962038f53f9ffbd02dcc52485f8e04da8","modified":1586230158052},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"61c95c49baa2c1bfd99cf88c55ba205b44bf3d97","modified":1586230158019},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"edc0154b30a4127acda10297bec6aacf754b4ac4","modified":1586230158019},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1586230158019},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"db8c42ab7e339c240b7044896a3987555ea9b5b8","modified":1586230158020},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"155327c23607f69989b58845f24d842a54e504b8","modified":1586230158020},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"4767e666849ac2600c7a1cbf94c54cf702864f80","modified":1586230158019},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"871f81cacd5d41cb2eb001cd56254217a857dc2f","modified":1586230158020},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1586230158021},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"12ca7d8dba56bc767b9309dda9526dcbaffc1614","modified":1586230158021},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1586230158021},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"e2b3f2b3631ef211a4d98d11f0da2d285340f10e","modified":1586230158022},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"11550a418921d330e6553be0569a94ab5a217967","modified":1586230158022},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"ccec1fc70f021cb50ac85b524e7949878ab93a18","modified":1586230158022},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"8c295469bd1602e9d3bbf2fee81ff84cacb1d701","modified":1586230158025},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"538b6d35b25cbdba7dc77feec638336625c8ef8b","modified":1586230158025},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"cc1c39903aed0a0601d104238d2bbd13ad2a36f3","modified":1586230158026},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"ce227b6f5a9af194fd5d455200630f32c05e151f","modified":1586230158029},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"29ba600e98ed55f7af4ade8038272c84cba21188","modified":1586230158029},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"4115c4518cca3f5cf461018aa7a7321138d017cc","modified":1586230158030},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"1577a2336b3ad122f49f60dff2bc1a97d4e7b18b","modified":1586230158030},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"8a0ae8ee6af8df3f215f1cd4ecc10145a5b92cf0","modified":1586230158029},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"9069371dcc65eee63081a21e8a56a9f3dbf64c08","modified":1586230158030},{"_id":"themes/yilia/source-src/css/article.scss","hash":"55d082fec4c6bb341725567acaa29ce37d50320a","modified":1586230158031},{"_id":"themes/yilia/source-src/css/duoshuo.scss","hash":"948e44c47c3d70584da93e7ce025dede9b7573d7","modified":1586230158033},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"5dc23be94451d54f0757de85747fd75061e8cf52","modified":1586230158033},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1586230158036},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1586230158036},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"f53ea8270752b5919ec5d79224d22af91f2eda12","modified":1586230158036},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"40e5aa5056dc0b3b9f51c5b387370b612e265d4e","modified":1586230158036},{"_id":"themes/yilia/source-src/css/left.scss","hash":"1ee3dd6fa50186af5bedb09d4a0e6b47ddb1b57b","modified":1586230158038},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"19f10fd2f0c3377aa4b165b3c2291ecf86dd9351","modified":1586230158038},{"_id":"themes/yilia/source-src/css/main.scss","hash":"b63c0f9b3bf68efc3bcd7c816bcac6f2fb827528","modified":1586230158038},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"28a01c3d85ec3194095f96988642a16d461f1077","modified":1586230158039},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"a557a9ed244c82b8b71e9da9de3339d92783499f","modified":1586230158039},{"_id":"themes/yilia/source-src/css/page.scss","hash":"244c4d75c375978ff9edb74acc68825e63c6b235","modified":1586230158039},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"2495f7e4e3b055735c531f944b5f40a118a351ec","modified":1586230158040},{"_id":"themes/yilia/source-src/css/share.scss","hash":"9d6f6884f40c191882e56a1e1e1192400944a515","modified":1586230158040},{"_id":"themes/yilia/source-src/css/social.scss","hash":"70c2e36b7161717feed1f231271ed693c36407d1","modified":1586230158040},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"399744e98e7c67939ed9b23c2670d8baad044eda","modified":1586230158040},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"915c93edd67c5326695cc7dc84b14c5f154dbcc8","modified":1586230158041},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"f5bed08765a8f0a344af5d4781ff822a57028148","modified":1586230158041},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"b81cedbe31accca82e597801186911a7b5e6841c","modified":1586230158041},{"_id":"themes/yilia/source-src/js/Q.js","hash":"e56d9710afa79b31ca6b9fbd845f6d1895f5214b","modified":1586230158042},{"_id":"themes/yilia/source-src/js/anm.js","hash":"d18f6276a352b871390a4112d479b9e58b8cdbbe","modified":1586230158043},{"_id":"themes/yilia/source-src/js/browser.js","hash":"4dc04845cf27f350922b63f1813a9c82e6e33b05","modified":1586230158043},{"_id":"themes/yilia/source-src/js/main.js","hash":"93ca570a646c6087821d7b14cb1646bb2a0274f4","modified":1586230158043},{"_id":"themes/yilia/source-src/js/fix.js","hash":"eccdcc7ee79adebf450bc655b2e80eb6801421a6","modified":1586230158043},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"461c08ffcbc724d74ec7e0ff38e171eefe0f89fd","modified":1586230158044},{"_id":"themes/yilia/source-src/js/share.js","hash":"d4ccff8266c37363b3904226f5d035b7db882c61","modified":1586230158045},{"_id":"themes/yilia/source-src/js/report.js","hash":"57680f9a23bd0a1eaafd64ae08cc33e20627ab15","modified":1586230158044},{"_id":"themes/yilia/source-src/js/slider.js","hash":"707842efee006e3ea9b6765d7460f4ef4f08e41f","modified":1586230158045},{"_id":"themes/yilia/source-src/js/util.js","hash":"3bcdeb95072b85600874424e6929e3e22cfddaa0","modified":1586230158045},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"3e0fd4479a40ddbd1571c6c953df7e23637b61f5","modified":1586230158046},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1586230158047},{"_id":"themes/yilia/source/fonts/iconfont.59e68b.eot","hash":"b7f28dc802d6e32281e8fe7930d4dd2022d00717","modified":1586230158048},{"_id":"themes/yilia/source/fonts/iconfont.b7ae25.ttf","hash":"697449e7790edd12e208706ecaa8d5d0eed44cde","modified":1586230158048},{"_id":"themes/yilia/source/fonts/iconfont.ca3627.woff","hash":"cda0ea1dc25dc3d329d7637afe2cd6aec37e351b","modified":1586230158048},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1586230158049},{"_id":"themes/yilia/source/fonts/iconfont.dba24b.svg","hash":"f6c8d119c14f2124f4362acd6c8e00f209af5613","modified":1586230158049},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1586230158050},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1586230158050},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1586230158050},{"_id":"source/img/box/absolute2.png","hash":"13eaaa68ec0c50ff94aac7777194a55b78c5afb8","modified":1586230157940},{"_id":"source/img/box/absolute1.png","hash":"ce91740edc613a36a98a6c1557419215f77c0a23","modified":1586230157939},{"_id":"source/img/box/absolute3.png","hash":"71a56d6316eb684cd34114391cf6f60e21223453","modified":1586230157940},{"_id":"source/img/box/blue.png","hash":"dbd83af3a9ec25b71c4a8b2fe8e35add18de79b1","modified":1586230157940},{"_id":"source/img/box/border-box.png","hash":"15ff281127c8ada43fcee2935cabfc08f3640a39","modified":1586230157940},{"_id":"source/img/box/border.png","hash":"204d0f2e93f0ef1435fcca215d3fe4df09ac2686","modified":1586230157941},{"_id":"source/img/box/border-width.png","hash":"be85688e028f5c838b41b6838d30f53da8382ea6","modified":1586230157941},{"_id":"source/img/box/box-model.png","hash":"68c45db4d76bca691340db121b19f2ae973367cc","modified":1586230157942},{"_id":"source/img/box/box-sizing.png","hash":"f7a4c19cd5579b8ec7f41427d099a6757c02e197","modified":1586230157942},{"_id":"source/img/box/fixed.png","hash":"86f305a80a380eae4ee2c016f2633bbd381aa915","modified":1586230157942},{"_id":"source/img/box/margin.png","hash":"9b128af7125e5e4761b1888d3fed2db269995a93","modified":1586230157943},{"_id":"source/img/box/margin-box.png","hash":"dc49ec994967458807bccb823e535412412a20f4","modified":1586230157943},{"_id":"source/img/box/margin-width.png","hash":"5a8bf08f41d381893dee584f3deb4c217a9e9f02","modified":1586230157943},{"_id":"source/img/box/padding-box.png","hash":"31679214091a4b5fe8246a2ab4a3290492154892","modified":1586230157944},{"_id":"source/img/box/padding.png","hash":"a195cfb3adcd1ca26899ca50ff99d280bb294a28","modified":1586230157944},{"_id":"source/img/box/padding-width.png","hash":"5354154c8135ae70add60eb2cb0a187c15eed689","modified":1586230157944},{"_id":"source/img/box/scroll.png","hash":"85a2282437a0faa6d24116e2bd4228e953273d30","modified":1586230157945},{"_id":"source/img/box/static.png","hash":"06f951e8725e4c9a77e91fe7049442f8ade42899","modified":1586230157945},{"_id":"source/img/box/relative.png","hash":"fe7adb7dbea113aecf41028176b04edcd0936eb2","modified":1586230157945},{"_id":"source/img/box/width-box.png","hash":"9ab63811de7476bde52640e7f060446a15819b49","modified":1586230157945},{"_id":"source/img/box/width.png","hash":"9acea1ac5fe1c8435d2b70ee94cdbe46f2982ae6","modified":1586230157946},{"_id":"source/img/box/z-index1.png","hash":"9aa8d9b3b981ce9383f0d210672732f125309d49","modified":1586230157946},{"_id":"source/img/cache/cache.png","hash":"3072b2b67f20a89b922ff6052e67e4d1846a041e","modified":1586230157948},{"_id":"source/img/cache/code_200.png","hash":"467cf839b866464d683cf39eb39996adbe1d6b4b","modified":1586230157949},{"_id":"source/img/cache/sw-lifecycle.png","hash":"ba6bc3ad68b25015458fc697f695642bf1fba494","modified":1586230157955},{"_id":"source/img/common/biaoqing1.png","hash":"3f760690bf7993b4ca91b1736254fd171d7d6689","modified":1586230157969},{"_id":"source/img/common/baobao.jpg","hash":"4d299acc930eceb39764248c3e3da378fea8c6d5","modified":1586230157969},{"_id":"source/img/common/yaoming.jpeg","hash":"88fbceff1221960ef95365f634eb51bdabf719f1","modified":1586230157969},{"_id":"source/img/face/absolute-padding.png","hash":"4b508ddbc1f2dd555102ba11f0f6f8448dfe9b73","modified":1586230157975},{"_id":"source/img/face/padding-top.png","hash":"d0e0cc657e2740bb4d25dd3eef9291b198700ca8","modified":1586230157975},{"_id":"source/img/face/w3c.png","hash":"30ca0584fcfe92cbc70b3ded4a228e0033537b65","modified":1586230157976},{"_id":"source/img/flexible/rpx.png","hash":"c2d7407fdf06fc7f612fb021e424e2651673bc4d","modified":1586230157976},{"_id":"source/img/img/bitmap.png","hash":"57673d11ae0202e8ee7c6da8016b02204e306d5d","modified":1586239333507},{"_id":"source/img/img/deep_digit.png","hash":"c18f3114f5fc447342346ef0809212813f11d865","modified":1586254898741},{"_id":"source/img/img/normal.gif","hash":"fd121296868da53d64b5fed9341f94ac0ecc7b44","modified":1586247354779},{"_id":"source/img/img/ps_menu.png","hash":"735c9b575429e095ada3ec4dd3e1a475bb37da39","modified":1586241105781},{"_id":"source/img/lineHeight/gay.png","hash":"de608ebc03f22827c9d5cc52f0434afa4b66b8af","modified":1586230157977},{"_id":"source/img/lineHeight/gay_2.png","hash":"c8450f5bf6369a579cbcee3893808c0934fd40f9","modified":1586230157977},{"_id":"source/img/lineHeight/height.jpg","hash":"c1572608a4771e8c562810f023a6fb78f1fa2b48","modified":1586230157978},{"_id":"source/img/lineHeight/inline_box.png","hash":"59a08a88c8222ed6568da8bf84682d51012fb54e","modified":1586230157978},{"_id":"source/img/lineHeight/x_height.png","hash":"883e9bc7633e5ab4739fd3980fa4f45f7da1fd03","modified":1586230157980},{"_id":"source/img/summary/sass.png","hash":"d40188f71265548f73f3de9b7ccba8fe0858d3c8","modified":1586230157980},{"_id":"source/img/summary/styles.png","hash":"1cbf4b34c69204826d34585ed785ab7c9b080927","modified":1586230157981},{"_id":"source/img/summary/task.png","hash":"b05e5157d519a2a1ea87c5fc3159fb878297c047","modified":1586230157981},{"_id":"source/img/summary/uglify.png","hash":"9c41e7fdb1e9c24b3e07e2274e63b14193ec8461","modified":1586230157982},{"_id":"source/img/cache/application.png","hash":"d60ceb98f4008995dbb2e3ce89e21042a66fa312","modified":1586230157947},{"_id":"source/img/box/z-index-box.png","hash":"46245b1ca13d61661316e98411182da6eb0da383","modified":1586230157946},{"_id":"source/img/cache/cdn_step.png","hash":"43b75f907e748fe75d266f46940362c76caf3f60","modified":1586230157949},{"_id":"source/img/cache/header_2.png","hash":"c5c0b4dc80139ef27e2a596b33047f4fe187bd53","modified":1586230157950},{"_id":"source/img/cache/header_1.png","hash":"ac80a953a829c10d1ecb3c12e9a54cd9fd0a3c25","modified":1586230157949},{"_id":"source/img/cache/servicework.png","hash":"2fda3f9989096a8e1de71424477320fb0c3631b7","modified":1586230157953},{"_id":"source/img/cache/no_cache.png","hash":"64bfb24303ea3b722be34369ed22f73729486962","modified":1586230157952},{"_id":"source/img/cache/step.png","hash":"6ee543cb17d4c7efdb13becc6fb948e7fa7f98f4","modified":1586230157954},{"_id":"source/img/cache/step_2.png","hash":"9088cacaca9b50af91a3f4c5eae4f57723ff1258","modified":1586230157954},{"_id":"source/img/img/progressive.gif","hash":"ff88c9107ca7259ea2776f15ee0740664485b1bf","modified":1586247361366},{"_id":"source/img/lineHeight/line_box.png","hash":"61d0b8a74981d37863fe31ffa7d7c480ecc22d5e","modified":1586230157979},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"aae96de18d48cd3b9b7bf6fed0100e15b53cca97","modified":1586230158023},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"f75b236818b6c0ec0e5e6c12a517825d6230d756","modified":1586230158023},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1586230158023},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"b6a97043f9ec37e571aacacfedcda1d4d75e3c7c","modified":1586230158023},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"06a2dd18ac9a43fbc9a59c61e6f795f9326e9927","modified":1586230158024},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2c4e4ca36c9bb4318506c38aca7127f1f44d827f","modified":1586230158024},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1586230158025},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"1834c3ed8560716e63bb3a50be94cac87fbbeaf3","modified":1586230158031},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"398a49913b4a47d928103562b1ce94520be4026a","modified":1586230158032},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"91db061c9c17628291a005e5bd4936cf9d35a6c4","modified":1586230158032},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"6e75bdaa46de83094ba0873099c6e7d656a22453","modified":1586230158033},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"b7f28dc802d6e32281e8fe7930d4dd2022d00717","modified":1586230158034},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"262ffcd88775080b7f511db37f58d2bcb1b2bfc7","modified":1586230158031},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f6c8d119c14f2124f4362acd6c8e00f209af5613","modified":1586230158034},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"697449e7790edd12e208706ecaa8d5d0eed44cde","modified":1586230158035},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"cda0ea1dc25dc3d329d7637afe2cd6aec37e351b","modified":1586230158035},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1586230158037},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1586230158037},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1586230158037},{"_id":"source/img/cache/weizhi_1.gif","hash":"7c21f579756aa32c32a2aa54d82644713743c889","modified":1586230157961},{"_id":"source/img/cache/weizhi_2.gif","hash":"c8f0ab3137db24322eeed9826b7a6e104115b3d2","modified":1586230157967},{"_id":"public/atom.xml","hash":"9a62b5849331fbd342fd388b89ce1aef4ba28ec0","modified":1586329013611},{"_id":"public/tags/index.html","hash":"7a97111f30b437a27a95c2a2f291287196c1f999","modified":1586329014189},{"_id":"public/2019/04/02/flexible/index.html","hash":"13c5f0b1117bd878a88ae94dfc8f540d07ccec41","modified":1586329014189},{"_id":"public/2019/02/07/cache/index.html","hash":"616445f86d931a4d23c4aab922a3aad6f57ad8eb","modified":1586329014209},{"_id":"public/2018/11/24/line-height-and-vertical-align/index.html","hash":"304b783c6c1dd37f5904be647df35299af19773f","modified":1586329014213},{"_id":"public/2018/05/01/fe-summary/index.html","hash":"8390acb04f82e80cf04da415b14849316925c512","modified":1586329014213},{"_id":"public/2018/03/19/sogou-life/index.html","hash":"6561964cb0b979a920f1f5e65edb45505be5f709","modified":1586329014213},{"_id":"public/2018/03/06/vue-cli-multipage/index.html","hash":"6b779dbf2b247845b11b36b07e17ffa511b4de60","modified":1586329014214},{"_id":"public/2018/02/27/inherit/index.html","hash":"f855d00cdc2d5176cfa3bfe3c105af11688acf79","modified":1586329014214},{"_id":"public/2017/04/25/Interview in Beijing in April/index.html","hash":"e6f513539b1b25e248250b3fe73891b08a1d0214","modified":1586329014214},{"_id":"public/2017/04/10/mongodb common command/index.html","hash":"9b821c40a54e4320999f32298cc5a57f02d95e47","modified":1586329014214},{"_id":"public/2017/03/19/Some of the interview questions that impressed me-2/index.html","hash":"c7b6620a44e0658b1fc04761b6dd70ff38f7262d","modified":1586329014214},{"_id":"public/2017/03/01/Some of the interview questions that impressed me-1/index.html","hash":"79618776c91e0f7e9055a8e655b64bb58895b91e","modified":1586329014214},{"_id":"public/2016/12/15/CSS box model and location/index.html","hash":"5d7d7d729f9e04aedc0ab2f7cceb4154466c5705","modified":1586329014214},{"_id":"public/2016/11/07/Javscript data type/index.html","hash":"ad8ff204caef9177c294cd4d53b4bcaa16e11424","modified":1586329014214},{"_id":"public/2016/10/24/angular Study notes-3/index.html","hash":"6c3929cbb8251e645aa1629445d95dbf394f59b1","modified":1586329014214},{"_id":"public/2016/10/14/angular Study notes-2/index.html","hash":"00b8ecd67505254f05fcf460d303569458bf5495","modified":1586329014214},{"_id":"public/2016/10/11/angular Study notes/index.html","hash":"8548da1c1285c63250a1bb8c7d6e292be775eb3c","modified":1586329014214},{"_id":"public/2016/08/14/Taste vue/index.html","hash":"9c0a3f7564858bbe08c03fa4e77a5f080a1a9398","modified":1586329014215},{"_id":"public/2016/08/09/Basics sass/index.html","hash":"1257be8907140d5c8c762c788688dda91f45c619","modified":1586329014215},{"_id":"public/2016/07/31/Hexo+github quickly build personal blog/index.html","hash":"8a1c80b89eaf1565f9f35be4683795349e139d77","modified":1586329014215},{"_id":"public/2016/07/30/new-blog/index.html","hash":"c47637d3430e1aac86b3e156e002b11e59a9c874","modified":1586329014215},{"_id":"public/archives/index.html","hash":"6341d3a11eadb54389cf50727c6361e06fb91ae1","modified":1586329014215},{"_id":"public/archives/page/2/index.html","hash":"a02fa78f40a6169f26c3464a9658bc66621f7c02","modified":1586329014215},{"_id":"public/archives/page/3/index.html","hash":"e306c1fec0da6f8602c38d5eff26f92a11eb1c39","modified":1586329014215},{"_id":"public/archives/2016/index.html","hash":"a5cadb87a2234a261aa87154490ae397504025d3","modified":1586329014215},{"_id":"public/archives/2016/07/index.html","hash":"a351ff9b7531614e1753c894d6e8a236c9b58a70","modified":1586329014215},{"_id":"public/archives/2016/08/index.html","hash":"2e29c1be7878d439e7eca25759e2c8196d9e46c6","modified":1586329014215},{"_id":"public/archives/2016/10/index.html","hash":"640c01d269d398cdbd16575ab52bfd2913da5103","modified":1586329014215},{"_id":"public/archives/2016/11/index.html","hash":"acee6545aa1a9b2ffdf61da8cb6cb6a44b409816","modified":1586329014215},{"_id":"public/archives/2016/12/index.html","hash":"d33ee5e9fa215af0cc1021118c6fc56c232c3c23","modified":1586329014216},{"_id":"public/archives/2017/index.html","hash":"8695d0e4543b2a0a8a944f3798de00a7e3154d1b","modified":1586329014216},{"_id":"public/archives/2017/03/index.html","hash":"22aa870338bfff9521790161fc5531d470b476e1","modified":1586329014216},{"_id":"public/archives/2017/04/index.html","hash":"9911acc0d6aab5e02bb3a9ab3fd5928205146bde","modified":1586329014216},{"_id":"public/archives/2018/index.html","hash":"2ddb1dc2aa1711d545dffced3645111297a74ba9","modified":1586329014216},{"_id":"public/archives/2018/02/index.html","hash":"223f67f480eb4f6d980f3c160fe6f104200c6b6a","modified":1586329014216},{"_id":"public/archives/2018/03/index.html","hash":"7be600fcd6255b22e26b6930fd95229be5d990a8","modified":1586329014216},{"_id":"public/archives/2018/05/index.html","hash":"a6d8040228ef07685acd96d9b176efb42d4398ad","modified":1586329014216},{"_id":"public/archives/2018/11/index.html","hash":"0c25bff4dfb2c35bce38863c7c950b11a2c49d69","modified":1586329014216},{"_id":"public/archives/2019/index.html","hash":"9b0081b5813591958f9d34e765e48c195e7e6c06","modified":1586329014216},{"_id":"public/archives/2019/02/index.html","hash":"eb38940306e78f5607b56833e971fe7727d5f952","modified":1586329014216},{"_id":"public/archives/2019/04/index.html","hash":"464ead5348e3396d439edf7c77e57d24fce37e2e","modified":1586329014216},{"_id":"public/index.html","hash":"7c1a60452b194354ca6dc173931067198b2b724c","modified":1586329014216},{"_id":"public/page/2/index.html","hash":"0115849e4d50dfbdc997a489514f41d78c8d47fa","modified":1586329014217},{"_id":"public/page/3/index.html","hash":"2dc6f507ec58c9faf6934f259b6f5b61d62a48ec","modified":1586329014217},{"_id":"public/tags/css/index.html","hash":"991c3f4b29594c6ea76b61ad93d32646121d4231","modified":1586329014217},{"_id":"public/tags/基础/index.html","hash":"91996b92790486c62dfef45152c66d1502b661aa","modified":1586329014217},{"_id":"public/tags/基础/page/2/index.html","hash":"a84dcbc9369f5499e6864a8e749024cf568d0369","modified":1586329014217},{"_id":"public/tags/盒模型/index.html","hash":"e435759f0645775a17956d07dd2e7095a764fb27","modified":1586329014217},{"_id":"public/tags/定位/index.html","hash":"eca380c73873d9019cd682782e8cc06793160e79","modified":1586329014217},{"_id":"public/tags/sass/index.html","hash":"10d55503371239d12412518c2893ab452428d965","modified":1586329014217},{"_id":"public/tags/hexo/index.html","hash":"5bd76474c01294ea3576bdc8ad7bc724cfb04e9d","modified":1586329014217},{"_id":"public/tags/面试/index.html","hash":"9b628b30575165cbd43d1dbd97c2cc7d0cd4403b","modified":1586329014217},{"_id":"public/tags/javascript/index.html","hash":"e3ce46babade27c960a9226796c5ee67b1eebef8","modified":1586329014217},{"_id":"public/tags/心情/index.html","hash":"fd81451b1d302d6ffcddc98c3c082bdae5fbcda0","modified":1586329014217},{"_id":"public/tags/angular/index.html","hash":"a8c542f5ee965483df7c44d57845bd6b5e4ade6c","modified":1586329014217},{"_id":"public/tags/vue/index.html","hash":"dbf9d7a4ef42efb1e5ad486e8efc7c3bf55faaba","modified":1586329014218},{"_id":"public/tags/html/index.html","hash":"fbc8cbc2850e6e2e3916ee51d87a4303fcf9db50","modified":1586329014218},{"_id":"public/tags/移动端/index.html","hash":"855d2464dbf8203199860cbe2b6ee341b45386ee","modified":1586329014218},{"_id":"public/tags/适配/index.html","hash":"4a1766cecdf9083c40bcbe493819ec729b398f71","modified":1586329014218},{"_id":"public/tags/浏览器/index.html","hash":"d1e0735e75ccc035948d7dcc960993ab86a08198","modified":1586329014218},{"_id":"public/tags/其他/index.html","hash":"14b97128e0ddc10daf28a3b2263472087f024ba5","modified":1586329014218},{"_id":"public/tags/mongodb/index.html","hash":"7d8d0724323f08d8fcb6dde17940ff3e46a1965d","modified":1586329014218},{"_id":"public/tags/vue-cli/index.html","hash":"4fe8001845a6f2999dd1c7f217f136a880884029","modified":1586329014218},{"_id":"public/2020/04/07/img-knowledge/index.html","hash":"d14b6eb0080a7d1d61ab70a0ff669a3196848f36","modified":1586329014232},{"_id":"public/archives/2020/index.html","hash":"550b46d2a9dcb9da0fcc6641004902b871b7d75c","modified":1586329014232},{"_id":"public/archives/2020/04/index.html","hash":"53fffcf471c0afcd9f33d64881ea23dc8124211b","modified":1586329014232},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1586329014248},{"_id":"public/fonts/iconfont.59e68b.eot","hash":"b7f28dc802d6e32281e8fe7930d4dd2022d00717","modified":1586329014248},{"_id":"public/fonts/iconfont.b7ae25.ttf","hash":"697449e7790edd12e208706ecaa8d5d0eed44cde","modified":1586329014248},{"_id":"public/fonts/iconfont.ca3627.woff","hash":"cda0ea1dc25dc3d329d7637afe2cd6aec37e351b","modified":1586329014249},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1586329014249},{"_id":"public/fonts/iconfont.dba24b.svg","hash":"f6c8d119c14f2124f4362acd6c8e00f209af5613","modified":1586329014249},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1586329014249},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1586329014249},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1586329014249},{"_id":"public/img/box/absolute2.png","hash":"13eaaa68ec0c50ff94aac7777194a55b78c5afb8","modified":1586329014249},{"_id":"public/img/box/absolute1.png","hash":"ce91740edc613a36a98a6c1557419215f77c0a23","modified":1586329014249},{"_id":"public/img/box/absolute3.png","hash":"71a56d6316eb684cd34114391cf6f60e21223453","modified":1586329014249},{"_id":"public/img/box/blue.png","hash":"dbd83af3a9ec25b71c4a8b2fe8e35add18de79b1","modified":1586329014250},{"_id":"public/img/box/border-box.png","hash":"15ff281127c8ada43fcee2935cabfc08f3640a39","modified":1586329014250},{"_id":"public/img/box/border.png","hash":"204d0f2e93f0ef1435fcca215d3fe4df09ac2686","modified":1586329014250},{"_id":"public/img/box/border-width.png","hash":"be85688e028f5c838b41b6838d30f53da8382ea6","modified":1586329014250},{"_id":"public/img/box/box-model.png","hash":"68c45db4d76bca691340db121b19f2ae973367cc","modified":1586329014250},{"_id":"public/img/box/box-sizing.png","hash":"f7a4c19cd5579b8ec7f41427d099a6757c02e197","modified":1586329014250},{"_id":"public/img/box/fixed.png","hash":"86f305a80a380eae4ee2c016f2633bbd381aa915","modified":1586329014250},{"_id":"public/img/box/margin.png","hash":"9b128af7125e5e4761b1888d3fed2db269995a93","modified":1586329014250},{"_id":"public/img/box/margin-box.png","hash":"dc49ec994967458807bccb823e535412412a20f4","modified":1586329014250},{"_id":"public/img/box/margin-width.png","hash":"5a8bf08f41d381893dee584f3deb4c217a9e9f02","modified":1586329014250},{"_id":"public/img/box/padding-box.png","hash":"31679214091a4b5fe8246a2ab4a3290492154892","modified":1586329014250},{"_id":"public/img/box/padding.png","hash":"a195cfb3adcd1ca26899ca50ff99d280bb294a28","modified":1586329014250},{"_id":"public/img/box/scroll.png","hash":"85a2282437a0faa6d24116e2bd4228e953273d30","modified":1586329014250},{"_id":"public/img/box/padding-width.png","hash":"5354154c8135ae70add60eb2cb0a187c15eed689","modified":1586329014250},{"_id":"public/img/box/static.png","hash":"06f951e8725e4c9a77e91fe7049442f8ade42899","modified":1586329014250},{"_id":"public/img/box/relative.png","hash":"fe7adb7dbea113aecf41028176b04edcd0936eb2","modified":1586329014251},{"_id":"public/img/box/width-box.png","hash":"9ab63811de7476bde52640e7f060446a15819b49","modified":1586329014251},{"_id":"public/img/box/width.png","hash":"9acea1ac5fe1c8435d2b70ee94cdbe46f2982ae6","modified":1586329014251},{"_id":"public/img/box/z-index1.png","hash":"9aa8d9b3b981ce9383f0d210672732f125309d49","modified":1586329014251},{"_id":"public/img/cache/cache.png","hash":"3072b2b67f20a89b922ff6052e67e4d1846a041e","modified":1586329014251},{"_id":"public/img/cache/sw-lifecycle.png","hash":"ba6bc3ad68b25015458fc697f695642bf1fba494","modified":1586329014251},{"_id":"public/img/cache/code_200.png","hash":"467cf839b866464d683cf39eb39996adbe1d6b4b","modified":1586329014251},{"_id":"public/img/common/baobao.jpg","hash":"4d299acc930eceb39764248c3e3da378fea8c6d5","modified":1586329014251},{"_id":"public/img/common/biaoqing1.png","hash":"3f760690bf7993b4ca91b1736254fd171d7d6689","modified":1586329014251},{"_id":"public/img/common/yaoming.jpeg","hash":"88fbceff1221960ef95365f634eb51bdabf719f1","modified":1586329014251},{"_id":"public/img/face/absolute-padding.png","hash":"4b508ddbc1f2dd555102ba11f0f6f8448dfe9b73","modified":1586329014251},{"_id":"public/img/face/padding-top.png","hash":"d0e0cc657e2740bb4d25dd3eef9291b198700ca8","modified":1586329014251},{"_id":"public/img/face/w3c.png","hash":"30ca0584fcfe92cbc70b3ded4a228e0033537b65","modified":1586329014251},{"_id":"public/img/flexible/rpx.png","hash":"c2d7407fdf06fc7f612fb021e424e2651673bc4d","modified":1586329014251},{"_id":"public/img/lineHeight/gay.png","hash":"de608ebc03f22827c9d5cc52f0434afa4b66b8af","modified":1586329014251},{"_id":"public/img/lineHeight/inline_box.png","hash":"59a08a88c8222ed6568da8bf84682d51012fb54e","modified":1586329014251},{"_id":"public/img/lineHeight/gay_2.png","hash":"c8450f5bf6369a579cbcee3893808c0934fd40f9","modified":1586329014251},{"_id":"public/img/lineHeight/height.jpg","hash":"c1572608a4771e8c562810f023a6fb78f1fa2b48","modified":1586329014251},{"_id":"public/img/lineHeight/x_height.png","hash":"883e9bc7633e5ab4739fd3980fa4f45f7da1fd03","modified":1586329014252},{"_id":"public/img/summary/sass.png","hash":"d40188f71265548f73f3de9b7ccba8fe0858d3c8","modified":1586329014252},{"_id":"public/img/summary/styles.png","hash":"1cbf4b34c69204826d34585ed785ab7c9b080927","modified":1586329014252},{"_id":"public/img/summary/task.png","hash":"b05e5157d519a2a1ea87c5fc3159fb878297c047","modified":1586329014252},{"_id":"public/img/cache/application.png","hash":"d60ceb98f4008995dbb2e3ce89e21042a66fa312","modified":1586329014252},{"_id":"public/img/box/z-index-box.png","hash":"46245b1ca13d61661316e98411182da6eb0da383","modified":1586329014252},{"_id":"public/img/img/deep_digit.png","hash":"c18f3114f5fc447342346ef0809212813f11d865","modified":1586329014252},{"_id":"public/img/img/bitmap.png","hash":"57673d11ae0202e8ee7c6da8016b02204e306d5d","modified":1586329014252},{"_id":"public/img/img/ps_menu.png","hash":"735c9b575429e095ada3ec4dd3e1a475bb37da39","modified":1586329014252},{"_id":"public/img/img/normal.gif","hash":"fd121296868da53d64b5fed9341f94ac0ecc7b44","modified":1586329014252},{"_id":"public/img/summary/uglify.png","hash":"9c41e7fdb1e9c24b3e07e2274e63b14193ec8461","modified":1586329014256},{"_id":"public/img/cache/cdn_step.png","hash":"43b75f907e748fe75d266f46940362c76caf3f60","modified":1586329014257},{"_id":"public/img/cache/header_2.png","hash":"c5c0b4dc80139ef27e2a596b33047f4fe187bd53","modified":1586329014257},{"_id":"public/img/cache/header_1.png","hash":"ac80a953a829c10d1ecb3c12e9a54cd9fd0a3c25","modified":1586329014257},{"_id":"public/img/cache/servicework.png","hash":"2fda3f9989096a8e1de71424477320fb0c3631b7","modified":1586329014258},{"_id":"public/img/cache/no_cache.png","hash":"64bfb24303ea3b722be34369ed22f73729486962","modified":1586329014258},{"_id":"public/img/cache/step.png","hash":"6ee543cb17d4c7efdb13becc6fb948e7fa7f98f4","modified":1586329014258},{"_id":"public/img/cache/step_2.png","hash":"9088cacaca9b50af91a3f4c5eae4f57723ff1258","modified":1586329014258},{"_id":"public/img/lineHeight/line_box.png","hash":"61d0b8a74981d37863fe31ffa7d7c480ecc22d5e","modified":1586329014258},{"_id":"public/img/img/progressive.gif","hash":"ff88c9107ca7259ea2776f15ee0740664485b1bf","modified":1586329014258},{"_id":"public/mobile.d238ee.js","hash":"a054884092af1cc5c2c14e5e11a4dac6d9254481","modified":1586329014286},{"_id":"public/main.2d7529.css","hash":"2eef112e365f9b00664302ba98b517662c75d411","modified":1586329014286},{"_id":"public/main.2d7529.js","hash":"988c141a741441812bcf4c408ef530d7a01522f3","modified":1586329014286},{"_id":"public/slider.885efe.js","hash":"1f1a6548c6016cc132bf65a1701cc8421a1f8414","modified":1586329014286},{"_id":"public/img/cache/weizhi_1.gif","hash":"7c21f579756aa32c32a2aa54d82644713743c889","modified":1586329014333},{"_id":"public/img/cache/weizhi_2.gif","hash":"c8f0ab3137db24322eeed9826b7a6e104115b3d2","modified":1586329014339}],"Category":[],"Data":[],"Page":[{"layout":"tags","title":"tags","date":"2016-07-30T09:26:26.000Z","_content":"type: \"tags\"\n","source":"tags/index.md","raw":"---\nlayout: tags\ntitle: tags\ndate: 2016-07-30 17:26:26\n---\ntype: \"tags\"\n","updated":"2020-04-07T03:29:17.982Z","path":"tags/index.html","comments":1,"_id":"ck8qzc39b002r2cl6zb4ghhpt","content":"<p>type: “tags”</p>\n","site":{"data":{}},"excerpt":"","more":"<p>type: “tags”</p>\n"}],"Post":[{"title":"css盒模型与定位","date":"2016-12-15T08:25:28.000Z","_content":"\n说到css的盒子模型和定位相信大家一定都听说过，因为它们是css中的基础，同时也是难点，这篇文章的作用在于基础知识的扫盲。\n\n<!-- more-->\n\n先来说说盒子模型吧\n\n# 什么是盒子模型\n\n简单地说每个html标签都是一个方块，然后这个方块又包着几个小方块。分别是：margin、border、padding、content。它们的关系是margin包着border包着padding包着content。就像盒子一层一层地包着一样，这就是我们所说的盒模型。\n嗯，看上面的文字有点文绉绉的，我们直接上图吧。\n打开谷歌浏览器，按下F12，然后把右边栏的滚动条拉到最下面你就会看到一个东西：\n\n![盒模型](/blog/img/box/box-model.png)\n\n这就很直观给我们展示了什么是盒子模型！\n\n# 盒子有多大\n\n我相信这个问题肯定会问倒很多人，这个问题是个非常经典的问题。我在百度上查都能查到有很多人写的博客上都在这方面有错误，所以，我觉得我有必要在这篇文章上讲清楚盒子到底有多大。\n老规矩，先上代码\n\n\t.red{\n\t\twidth:200px;\n\t\theight:200px;\n\t\tbackground-color:red;\n\t}\n\t\n补全html代码就会在页面左上角出现这么个玩意儿：\n\n![红色方块](/blog/img/box/width.png)\n\n对应的盒子模型：\n\n![红色方块的盒子模型](/blog/img/box/width-box.png)\n\n很明显这个时候的盒子大小就是content的大小。来，我们继续往下走，我们给这个方块加上padding：\n\n\t.red{\n\t\twidth:200px;\n\t\theight:200px;\n\t\tpadding:10px;\n\t\tbackground-color:red;\n\t}\n\n这时你就会发现这个方块比原来稍微胖了那么一点：\n\n![加上padding的红色方块](/blog/img/box/padding.png)\n\n对应的盒模型：\n\n![加上padding的红色方块的盒子模型](/blog/img/box/padding-box.png)\n\n这个时候将鼠标移到控制台上的这个元素你就会发现：\n\n![加上padding的红色方块的长宽](/blog/img/box/padding-width.png)\n\n下面写有盒子的长宽变成了`220x220`，很明显，padding是能够改变盒子的大小的，这时盒子大小就等于content+padding。\n\n接下来，我们给盒子加上边框：\n\n\t.red{\n\t\twidth:200px;\n\t\theight:200px;\n\t\tpadding:10px;\n\t\tborder:10px solid black;\n\t\tbackground-color:red;\n\t}\n\t\n这个时候变成了下面这样：\n\n![加上border的红色方块](/blog/img/box/border.png)\n\n盒模型：\n\n![加上border的红色方块的盒模型](/blog/img/box/border-box.png)\n\n它的长宽：\n\n![加上border的红色方块的长宽](/blog/img/box/border-width.png)\n\n可以发现长宽变为了`240x240`，所以这时盒子大小就等于content+padding+border。\n\n接下来讲margin。在给这个方块加margin之前为了方便观察我们加个类名为blue的div，并且加上样式：\n\n\t.blue{\n\t\twidth:100px;\n\t\theight:100px;\n\t\tbackground-color:blue;\n\t}\n\n效果图：\n\n![加个蓝色方块](/blog/img/box/blue.png)\n\n因为div是块级元素，所以新加的蓝色div自动跑到红色的下面。\n接下来给红色方块加上margin-bottom：\n\n\t.red{\n\t\twidth:200px;\n\t\theight:200px;\n\t\tpadding:10px;\n\t\tmargin-bottom:10px;\n\t\tborder:10px solid black;\n\t\tbackground-color:red;\n\t}\n\t\n效果图：\n\n![加上margin](/blog/img/box/margin.png)\n\n可以发现，盒子的底部产生了10px的空白。\n\n对应的盒模型\n\n![加上margin的红色方块的盒模型](/blog/img/box/margin-box.png)\n\n方块的长宽\n\n![加上margin的红色方块的长宽](/blog/img/box/margin-width.png)\n\n很明显盒子的大小并没有变大，还是原来的`240x240`。\n\n所以，最终盒子的大小为content+padding+border即内容的(width)+内边距的再加上边框，而不加上margin。\n\n看到网上很多文章都把margin算进去了，如果按照他们所说的，上面盒子的大小应该是`240x250`，然而实际情况并不是。从这里可以看出，很多人对盒模型有误解。**把margin算进去的那是盒子占据的位置，而不是盒子的大小！**\n\n其实盒模型一共分为两种，一种是上面讲的标准盒模型，还有一种是怪异盒模型，这两种盒模型的区别在于width/height。前者width/height指的是content区域的宽度和高度，后者width/height指的是content+padding+border。\n\n在ie8+浏览器中使用哪个盒模型可以由`box-sizing`控制，默认值为`content-box`，即标准盒模型；如果将`box-sizing`设为`border-box`则用的是怪异盒模型。如果在ie6,7,8中DOCTYPE缺失会触发怪异模式。\n\n我们可以把上面的红色方块的`box-sizing`设为`border-box`发现，无论我们怎么改border和padding盒子大小始终是定义的width和height：\n\n![box-sizing](/blog/img/box/box-sizing.png)\n\n# 定位\n\n定位`(position)`有四个值：\n1. static\n2. relative\n3. absolute\n4. fixed\n\n## static\n\n一般如果我们不设置`position`的话它的默认值就是`static`，这个时候left、top、bottom、right是不起作用的\n，现在有如下两个div，他们的关系是兄弟关系：\n\n\t.red{\n\t\twidth:200px;\n\t\theight:200px;\n\t\tleft:100px;\n\t\ttop:100px;\n\t\tbackground-color:red;\n\t}\n\t.blue{\n\t\twidth:100px;\n\t\theight:100px;\n\t\tbackground-color:blue;\n\t}\n\n效果图：\n\n![static](/blog/img/box/static.png)\n\n可以发现，并没有什么变化。红色方块的`left`和`top`加不加都一样。\n\n## relative\n\n但是，现在我们给红色方块加个`position:relative`：\n\n\t.red{\n\t\tposition:relative;\n\t\twidth:200px;\n\t\theight:200px;\n\t\tleft:100px;\n\t\ttop:100px;\n\t\tbackground-color:red;\n\t}\n\t\n嘿嘿，变这样了：\n\n![relative](/blog/img/box/relative.png)\n\n可以发现，红色方块跑到蓝色方块的右边了，左边缘和顶边缘都距离原来100px，但是蓝色方块还是在原来的地方不动，现在可以得出一个结论：**使用相对定位给元素加left/top/right/buttom元素会以原来的位置为基础加上这些值，即以原来的位置为基础定位，并且没有脱离文档流**\n\n嗯，是不是看起来有点文绉绉的，那来个形象的比喻吧：\n\n假如`position:static`是一个活人的话，并且拥有灵魂，这个时候我想给他加个`left:100px`想让他的灵魂出来，但是并没有效果。当这个人刚去世而且尸体还没火化的时候(相当于`position:relative`)，这时我加个`left:100px`灵魂就可以移动了，并且灵魂往尸体的右边移动了100px。因为尸体还没火化，所以这个人还是占一定的空间的。\n\n## absolute\n\n现在，我们把`position`改为`absolute`：\n\n\t.red{\n\t\tposition:absolute;\n\t\twidth:200px;\n\t\theight:200px;\n\t\tleft:100px;\n\t\ttop:100px;\n\t\tbackground-color:red;\n\t}\n\t\n效果图：\n\n![absolute](/blog/img/box/absolute1.png)\n\n可以发现蓝色方块如我们所愿移动到了红色方块的上面，说明红色方块已经脱离文档流。虽然红色方块的位移和`relative`一样但是，红色方块位移的参考不再是原来的位置而是body只不过红色方块的位置刚好在body的最左上角，刚好碰巧位移一样，上面的这个例子可能看不出来，让我们来改改代码。\n\n首先将html结构改成：\n\n\t<div class=\"red\">\n\t\t<div class=\"blue\"></div>\n\t</div>\n\n然后红色方块的`absolute`改回`relative`\n\n效果图：\n\n![absolute](/blog/img/box/absolute2.png)\n\t\n然后蓝色方块代码改为：\n\n\t.blue{\n\t\tposition:absolute;\n\t\ttop:100px;\n\t\tleft:100px;\n\t\twidth:100px;\n\t\theight:100px;\n\t\tbackground-color:blue;\n\t}\n\n\n![absolute](/blog/img/box/absolute3.png)\n\n可以发现在给蓝色方块添加`position:absolute`前，蓝色方块像我们想的那样在红色方块的左上角；当我们给蓝色方块添加`position:absolute`并且添加`left`和`top`时，蓝色方块就跑到了红色方块的右下角。\n\n那么这次这个蓝色方块是以谁为参考进行位移的？刚刚你说的以body为参考又是什么情况？\n\n好，我这里就给大家说清楚，当给一个元素设置`position:absolute`时，这个元素的位置就是以他父代元素`position`不为`static`的元素作为参考，如果他的父代元素都是`position:static`那就以body作为参考。刚刚红色方块的情况就是他父代元素没有`position`不为`static`的元素，所以只能以body作为参考。\n\n嗯，讲的文绉绉的，我不喜欢。来，举个例子：\n\n还是刚刚那个人与灵魂的例子，当设置`position:absolute`时，就相当于人死了，尸体已经火化了，只剩下灵魂和骨灰，所以是不占空间的(就是已经脱离文档流)。这个时候灵魂可以乱飘了，但是有个限制，只能相对于骨灰飘。\n\n## fixed\n\n现在让我们再来创建一个绿色方块：\n\n\t.green{\n\t\tposition:fixed;\n\t\ttop:150px;\n\t\tleft:150px;\n\t\twidth:100px;\n\t\theight:100px;\n\t\tbackground-color:green;\n\t}\n\n效果图：\n\n![fixed](/blog/img/box/fixed.png)\n\n这个看起来貌似没有什么特别的，现在我们来给body加个`height:2000px`(这个高度随意，但是要使浏览器右边出现滚动条)，然后把浏览器的滚动条往下拉，一个神奇的事情发生了：绿色方块固定在我们定义的位置上屏幕上不动了！\n\n![scroll](/blog/img/box/scroll.png)\n\n这个fixed我们见得最多的就是网页中顽固的小广告，不管我们怎么拖拽滚动条，它总是固定在那，就是一个升级版的`absolute`。\n\n用上面的例子来说就是人已经成仙了，可以不受限制地乱飘，而且不管你怎么拉，都拉不动他，他就在那不动了！\n\n## z-index\n\n说到定位，肯定少不了z-index。用上面的例子来说z-index就是灵魂飘的高度，设置得越大，自然就飘得越高，既然扯到了灵魂，z-index肯定是对活人(`static`)无效的了。\n\n正常情况下(没有加z-index)，元素是按照后来居上原则进行堆叠。在这个例子上的html元素是这样的：\n\n\t<div class=\"red\">\n\t\t\t<div class=\"blue\"></div>\n\t\t</div>\n\t<div class=\"green\"></div>\n\n按照后来居上原则，红色方块最先被浏览器渲染到，所以在最下面，其次到蓝色，最后到绿色。\n\n如果我们想让红色方块显示到前面我们可以给它加个`z-index:1`，结果：\n\n![z-index](/blog/img/box/z-index1.png)\n\n发现绿色方块“消失了”。其实绿色方块并没有消失，你可以将滚动条往下拉，或者看盒子模型：\n\n![z-index](/blog/img/box/z-index-box.png)\n\n可以发现它并没有消失，只是被盖在了红色方块下面。由于红色方块与蓝色方块是父子关系，红色的上来了，蓝色肯定的上来啊。\n\n现在我有个想法，想让蓝色方块弄到红色方块下面该怎么办？很多人可能会想到简单啊，直接给蓝色方块加个`z-index:-1`不就得了吗？但是很可惜，没用。\n\n要解释这个现象就得扯到**层叠上下文**的东西了。解释这东西又得花些篇幅来讲，具体的可以看[这里](http://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/)。\n\n这里我就一笔带过了，用最通俗易懂的例子来解释了，老爸的灵魂包着儿子的灵魂飘到了一楼(z-index:1)，但是儿子想下到-1楼(z-index:-1)这是不行的因为儿子的灵魂已经被老爸的灵魂包着了(当z-index为数值时，会产生层叠上下文)，如果儿子想下到一楼，得先不让老爸的灵魂包着儿子的灵魂(不设置红色方块的z-index或者设置为z-index:auto)，这样就能下到-1楼了这样蓝色方块就被红色方块挡住了。\n\n但是不设置红色的`z-index`的话，绿色方块又出来作怪了，这个时候只能设置绿色方块`z-index:-1`，红色方块就没谁能挡得住了！\n\n# 总结\n\n1. css的盒模型由content(内容)、padding(内边距)、border(边框)、margin(外边距)组成。\n2. 在w3c和模型中，设置的width/height是content的宽度/高度，在怪异模式中width/height设置的是content+padding+border宽度/高度。\n3. 在w3c盒子模型中盒子的大小由content、padding、border决定，在在怪异模式中盒子大小由width和height决定。\n4. 定位有四个值static(静止)、relative(相对)、absolute(绝对)、fixed(固定)。\n5. left、top、right、bottom、z-index不能对static起作用。\n\n有什么问题可以在下面留言哦，会及时给出答复的。\n","source":"_posts/CSS box model and location.md","raw":"---\ntitle: css盒模型与定位\ndate: 2016-12-15 16:25:28\ntags: [css,基础,盒模型,定位]\n---\n\n说到css的盒子模型和定位相信大家一定都听说过，因为它们是css中的基础，同时也是难点，这篇文章的作用在于基础知识的扫盲。\n\n<!-- more-->\n\n先来说说盒子模型吧\n\n# 什么是盒子模型\n\n简单地说每个html标签都是一个方块，然后这个方块又包着几个小方块。分别是：margin、border、padding、content。它们的关系是margin包着border包着padding包着content。就像盒子一层一层地包着一样，这就是我们所说的盒模型。\n嗯，看上面的文字有点文绉绉的，我们直接上图吧。\n打开谷歌浏览器，按下F12，然后把右边栏的滚动条拉到最下面你就会看到一个东西：\n\n![盒模型](/blog/img/box/box-model.png)\n\n这就很直观给我们展示了什么是盒子模型！\n\n# 盒子有多大\n\n我相信这个问题肯定会问倒很多人，这个问题是个非常经典的问题。我在百度上查都能查到有很多人写的博客上都在这方面有错误，所以，我觉得我有必要在这篇文章上讲清楚盒子到底有多大。\n老规矩，先上代码\n\n\t.red{\n\t\twidth:200px;\n\t\theight:200px;\n\t\tbackground-color:red;\n\t}\n\t\n补全html代码就会在页面左上角出现这么个玩意儿：\n\n![红色方块](/blog/img/box/width.png)\n\n对应的盒子模型：\n\n![红色方块的盒子模型](/blog/img/box/width-box.png)\n\n很明显这个时候的盒子大小就是content的大小。来，我们继续往下走，我们给这个方块加上padding：\n\n\t.red{\n\t\twidth:200px;\n\t\theight:200px;\n\t\tpadding:10px;\n\t\tbackground-color:red;\n\t}\n\n这时你就会发现这个方块比原来稍微胖了那么一点：\n\n![加上padding的红色方块](/blog/img/box/padding.png)\n\n对应的盒模型：\n\n![加上padding的红色方块的盒子模型](/blog/img/box/padding-box.png)\n\n这个时候将鼠标移到控制台上的这个元素你就会发现：\n\n![加上padding的红色方块的长宽](/blog/img/box/padding-width.png)\n\n下面写有盒子的长宽变成了`220x220`，很明显，padding是能够改变盒子的大小的，这时盒子大小就等于content+padding。\n\n接下来，我们给盒子加上边框：\n\n\t.red{\n\t\twidth:200px;\n\t\theight:200px;\n\t\tpadding:10px;\n\t\tborder:10px solid black;\n\t\tbackground-color:red;\n\t}\n\t\n这个时候变成了下面这样：\n\n![加上border的红色方块](/blog/img/box/border.png)\n\n盒模型：\n\n![加上border的红色方块的盒模型](/blog/img/box/border-box.png)\n\n它的长宽：\n\n![加上border的红色方块的长宽](/blog/img/box/border-width.png)\n\n可以发现长宽变为了`240x240`，所以这时盒子大小就等于content+padding+border。\n\n接下来讲margin。在给这个方块加margin之前为了方便观察我们加个类名为blue的div，并且加上样式：\n\n\t.blue{\n\t\twidth:100px;\n\t\theight:100px;\n\t\tbackground-color:blue;\n\t}\n\n效果图：\n\n![加个蓝色方块](/blog/img/box/blue.png)\n\n因为div是块级元素，所以新加的蓝色div自动跑到红色的下面。\n接下来给红色方块加上margin-bottom：\n\n\t.red{\n\t\twidth:200px;\n\t\theight:200px;\n\t\tpadding:10px;\n\t\tmargin-bottom:10px;\n\t\tborder:10px solid black;\n\t\tbackground-color:red;\n\t}\n\t\n效果图：\n\n![加上margin](/blog/img/box/margin.png)\n\n可以发现，盒子的底部产生了10px的空白。\n\n对应的盒模型\n\n![加上margin的红色方块的盒模型](/blog/img/box/margin-box.png)\n\n方块的长宽\n\n![加上margin的红色方块的长宽](/blog/img/box/margin-width.png)\n\n很明显盒子的大小并没有变大，还是原来的`240x240`。\n\n所以，最终盒子的大小为content+padding+border即内容的(width)+内边距的再加上边框，而不加上margin。\n\n看到网上很多文章都把margin算进去了，如果按照他们所说的，上面盒子的大小应该是`240x250`，然而实际情况并不是。从这里可以看出，很多人对盒模型有误解。**把margin算进去的那是盒子占据的位置，而不是盒子的大小！**\n\n其实盒模型一共分为两种，一种是上面讲的标准盒模型，还有一种是怪异盒模型，这两种盒模型的区别在于width/height。前者width/height指的是content区域的宽度和高度，后者width/height指的是content+padding+border。\n\n在ie8+浏览器中使用哪个盒模型可以由`box-sizing`控制，默认值为`content-box`，即标准盒模型；如果将`box-sizing`设为`border-box`则用的是怪异盒模型。如果在ie6,7,8中DOCTYPE缺失会触发怪异模式。\n\n我们可以把上面的红色方块的`box-sizing`设为`border-box`发现，无论我们怎么改border和padding盒子大小始终是定义的width和height：\n\n![box-sizing](/blog/img/box/box-sizing.png)\n\n# 定位\n\n定位`(position)`有四个值：\n1. static\n2. relative\n3. absolute\n4. fixed\n\n## static\n\n一般如果我们不设置`position`的话它的默认值就是`static`，这个时候left、top、bottom、right是不起作用的\n，现在有如下两个div，他们的关系是兄弟关系：\n\n\t.red{\n\t\twidth:200px;\n\t\theight:200px;\n\t\tleft:100px;\n\t\ttop:100px;\n\t\tbackground-color:red;\n\t}\n\t.blue{\n\t\twidth:100px;\n\t\theight:100px;\n\t\tbackground-color:blue;\n\t}\n\n效果图：\n\n![static](/blog/img/box/static.png)\n\n可以发现，并没有什么变化。红色方块的`left`和`top`加不加都一样。\n\n## relative\n\n但是，现在我们给红色方块加个`position:relative`：\n\n\t.red{\n\t\tposition:relative;\n\t\twidth:200px;\n\t\theight:200px;\n\t\tleft:100px;\n\t\ttop:100px;\n\t\tbackground-color:red;\n\t}\n\t\n嘿嘿，变这样了：\n\n![relative](/blog/img/box/relative.png)\n\n可以发现，红色方块跑到蓝色方块的右边了，左边缘和顶边缘都距离原来100px，但是蓝色方块还是在原来的地方不动，现在可以得出一个结论：**使用相对定位给元素加left/top/right/buttom元素会以原来的位置为基础加上这些值，即以原来的位置为基础定位，并且没有脱离文档流**\n\n嗯，是不是看起来有点文绉绉的，那来个形象的比喻吧：\n\n假如`position:static`是一个活人的话，并且拥有灵魂，这个时候我想给他加个`left:100px`想让他的灵魂出来，但是并没有效果。当这个人刚去世而且尸体还没火化的时候(相当于`position:relative`)，这时我加个`left:100px`灵魂就可以移动了，并且灵魂往尸体的右边移动了100px。因为尸体还没火化，所以这个人还是占一定的空间的。\n\n## absolute\n\n现在，我们把`position`改为`absolute`：\n\n\t.red{\n\t\tposition:absolute;\n\t\twidth:200px;\n\t\theight:200px;\n\t\tleft:100px;\n\t\ttop:100px;\n\t\tbackground-color:red;\n\t}\n\t\n效果图：\n\n![absolute](/blog/img/box/absolute1.png)\n\n可以发现蓝色方块如我们所愿移动到了红色方块的上面，说明红色方块已经脱离文档流。虽然红色方块的位移和`relative`一样但是，红色方块位移的参考不再是原来的位置而是body只不过红色方块的位置刚好在body的最左上角，刚好碰巧位移一样，上面的这个例子可能看不出来，让我们来改改代码。\n\n首先将html结构改成：\n\n\t<div class=\"red\">\n\t\t<div class=\"blue\"></div>\n\t</div>\n\n然后红色方块的`absolute`改回`relative`\n\n效果图：\n\n![absolute](/blog/img/box/absolute2.png)\n\t\n然后蓝色方块代码改为：\n\n\t.blue{\n\t\tposition:absolute;\n\t\ttop:100px;\n\t\tleft:100px;\n\t\twidth:100px;\n\t\theight:100px;\n\t\tbackground-color:blue;\n\t}\n\n\n![absolute](/blog/img/box/absolute3.png)\n\n可以发现在给蓝色方块添加`position:absolute`前，蓝色方块像我们想的那样在红色方块的左上角；当我们给蓝色方块添加`position:absolute`并且添加`left`和`top`时，蓝色方块就跑到了红色方块的右下角。\n\n那么这次这个蓝色方块是以谁为参考进行位移的？刚刚你说的以body为参考又是什么情况？\n\n好，我这里就给大家说清楚，当给一个元素设置`position:absolute`时，这个元素的位置就是以他父代元素`position`不为`static`的元素作为参考，如果他的父代元素都是`position:static`那就以body作为参考。刚刚红色方块的情况就是他父代元素没有`position`不为`static`的元素，所以只能以body作为参考。\n\n嗯，讲的文绉绉的，我不喜欢。来，举个例子：\n\n还是刚刚那个人与灵魂的例子，当设置`position:absolute`时，就相当于人死了，尸体已经火化了，只剩下灵魂和骨灰，所以是不占空间的(就是已经脱离文档流)。这个时候灵魂可以乱飘了，但是有个限制，只能相对于骨灰飘。\n\n## fixed\n\n现在让我们再来创建一个绿色方块：\n\n\t.green{\n\t\tposition:fixed;\n\t\ttop:150px;\n\t\tleft:150px;\n\t\twidth:100px;\n\t\theight:100px;\n\t\tbackground-color:green;\n\t}\n\n效果图：\n\n![fixed](/blog/img/box/fixed.png)\n\n这个看起来貌似没有什么特别的，现在我们来给body加个`height:2000px`(这个高度随意，但是要使浏览器右边出现滚动条)，然后把浏览器的滚动条往下拉，一个神奇的事情发生了：绿色方块固定在我们定义的位置上屏幕上不动了！\n\n![scroll](/blog/img/box/scroll.png)\n\n这个fixed我们见得最多的就是网页中顽固的小广告，不管我们怎么拖拽滚动条，它总是固定在那，就是一个升级版的`absolute`。\n\n用上面的例子来说就是人已经成仙了，可以不受限制地乱飘，而且不管你怎么拉，都拉不动他，他就在那不动了！\n\n## z-index\n\n说到定位，肯定少不了z-index。用上面的例子来说z-index就是灵魂飘的高度，设置得越大，自然就飘得越高，既然扯到了灵魂，z-index肯定是对活人(`static`)无效的了。\n\n正常情况下(没有加z-index)，元素是按照后来居上原则进行堆叠。在这个例子上的html元素是这样的：\n\n\t<div class=\"red\">\n\t\t\t<div class=\"blue\"></div>\n\t\t</div>\n\t<div class=\"green\"></div>\n\n按照后来居上原则，红色方块最先被浏览器渲染到，所以在最下面，其次到蓝色，最后到绿色。\n\n如果我们想让红色方块显示到前面我们可以给它加个`z-index:1`，结果：\n\n![z-index](/blog/img/box/z-index1.png)\n\n发现绿色方块“消失了”。其实绿色方块并没有消失，你可以将滚动条往下拉，或者看盒子模型：\n\n![z-index](/blog/img/box/z-index-box.png)\n\n可以发现它并没有消失，只是被盖在了红色方块下面。由于红色方块与蓝色方块是父子关系，红色的上来了，蓝色肯定的上来啊。\n\n现在我有个想法，想让蓝色方块弄到红色方块下面该怎么办？很多人可能会想到简单啊，直接给蓝色方块加个`z-index:-1`不就得了吗？但是很可惜，没用。\n\n要解释这个现象就得扯到**层叠上下文**的东西了。解释这东西又得花些篇幅来讲，具体的可以看[这里](http://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/)。\n\n这里我就一笔带过了，用最通俗易懂的例子来解释了，老爸的灵魂包着儿子的灵魂飘到了一楼(z-index:1)，但是儿子想下到-1楼(z-index:-1)这是不行的因为儿子的灵魂已经被老爸的灵魂包着了(当z-index为数值时，会产生层叠上下文)，如果儿子想下到一楼，得先不让老爸的灵魂包着儿子的灵魂(不设置红色方块的z-index或者设置为z-index:auto)，这样就能下到-1楼了这样蓝色方块就被红色方块挡住了。\n\n但是不设置红色的`z-index`的话，绿色方块又出来作怪了，这个时候只能设置绿色方块`z-index:-1`，红色方块就没谁能挡得住了！\n\n# 总结\n\n1. css的盒模型由content(内容)、padding(内边距)、border(边框)、margin(外边距)组成。\n2. 在w3c和模型中，设置的width/height是content的宽度/高度，在怪异模式中width/height设置的是content+padding+border宽度/高度。\n3. 在w3c盒子模型中盒子的大小由content、padding、border决定，在在怪异模式中盒子大小由width和height决定。\n4. 定位有四个值static(静止)、relative(相对)、absolute(绝对)、fixed(固定)。\n5. left、top、right、bottom、z-index不能对static起作用。\n\n有什么问题可以在下面留言哦，会及时给出答复的。\n","slug":"CSS box model and location","published":1,"updated":"2020-04-07T03:29:17.928Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8qzc33l00002cl60cdipz1x","content":"<p>说到css的盒子模型和定位相信大家一定都听说过，因为它们是css中的基础，同时也是难点，这篇文章的作用在于基础知识的扫盲。</p>\n<a id=\"more\"></a>\n<p>先来说说盒子模型吧</p>\n<h1 id=\"什么是盒子模型\"><a href=\"#什么是盒子模型\" class=\"headerlink\" title=\"什么是盒子模型\"></a>什么是盒子模型</h1><p>简单地说每个html标签都是一个方块，然后这个方块又包着几个小方块。分别是：margin、border、padding、content。它们的关系是margin包着border包着padding包着content。就像盒子一层一层地包着一样，这就是我们所说的盒模型。<br>嗯，看上面的文字有点文绉绉的，我们直接上图吧。<br>打开谷歌浏览器，按下F12，然后把右边栏的滚动条拉到最下面你就会看到一个东西：</p>\n<p><img src=\"/blog/img/box/box-model.png\" alt=\"盒模型\"></p>\n<p>这就很直观给我们展示了什么是盒子模型！</p>\n<h1 id=\"盒子有多大\"><a href=\"#盒子有多大\" class=\"headerlink\" title=\"盒子有多大\"></a>盒子有多大</h1><p>我相信这个问题肯定会问倒很多人，这个问题是个非常经典的问题。我在百度上查都能查到有很多人写的博客上都在这方面有错误，所以，我觉得我有必要在这篇文章上讲清楚盒子到底有多大。<br>老规矩，先上代码</p>\n<pre><code>.red{\n    width:200px;\n    height:200px;\n    background-color:red;\n}\n</code></pre><p>补全html代码就会在页面左上角出现这么个玩意儿：</p>\n<p><img src=\"/blog/img/box/width.png\" alt=\"红色方块\"></p>\n<p>对应的盒子模型：</p>\n<p><img src=\"/blog/img/box/width-box.png\" alt=\"红色方块的盒子模型\"></p>\n<p>很明显这个时候的盒子大小就是content的大小。来，我们继续往下走，我们给这个方块加上padding：</p>\n<pre><code>.red{\n    width:200px;\n    height:200px;\n    padding:10px;\n    background-color:red;\n}\n</code></pre><p>这时你就会发现这个方块比原来稍微胖了那么一点：</p>\n<p><img src=\"/blog/img/box/padding.png\" alt=\"加上padding的红色方块\"></p>\n<p>对应的盒模型：</p>\n<p><img src=\"/blog/img/box/padding-box.png\" alt=\"加上padding的红色方块的盒子模型\"></p>\n<p>这个时候将鼠标移到控制台上的这个元素你就会发现：</p>\n<p><img src=\"/blog/img/box/padding-width.png\" alt=\"加上padding的红色方块的长宽\"></p>\n<p>下面写有盒子的长宽变成了<code>220x220</code>，很明显，padding是能够改变盒子的大小的，这时盒子大小就等于content+padding。</p>\n<p>接下来，我们给盒子加上边框：</p>\n<pre><code>.red{\n    width:200px;\n    height:200px;\n    padding:10px;\n    border:10px solid black;\n    background-color:red;\n}\n</code></pre><p>这个时候变成了下面这样：</p>\n<p><img src=\"/blog/img/box/border.png\" alt=\"加上border的红色方块\"></p>\n<p>盒模型：</p>\n<p><img src=\"/blog/img/box/border-box.png\" alt=\"加上border的红色方块的盒模型\"></p>\n<p>它的长宽：</p>\n<p><img src=\"/blog/img/box/border-width.png\" alt=\"加上border的红色方块的长宽\"></p>\n<p>可以发现长宽变为了<code>240x240</code>，所以这时盒子大小就等于content+padding+border。</p>\n<p>接下来讲margin。在给这个方块加margin之前为了方便观察我们加个类名为blue的div，并且加上样式：</p>\n<pre><code>.blue{\n    width:100px;\n    height:100px;\n    background-color:blue;\n}\n</code></pre><p>效果图：</p>\n<p><img src=\"/blog/img/box/blue.png\" alt=\"加个蓝色方块\"></p>\n<p>因为div是块级元素，所以新加的蓝色div自动跑到红色的下面。<br>接下来给红色方块加上margin-bottom：</p>\n<pre><code>.red{\n    width:200px;\n    height:200px;\n    padding:10px;\n    margin-bottom:10px;\n    border:10px solid black;\n    background-color:red;\n}\n</code></pre><p>效果图：</p>\n<p><img src=\"/blog/img/box/margin.png\" alt=\"加上margin\"></p>\n<p>可以发现，盒子的底部产生了10px的空白。</p>\n<p>对应的盒模型</p>\n<p><img src=\"/blog/img/box/margin-box.png\" alt=\"加上margin的红色方块的盒模型\"></p>\n<p>方块的长宽</p>\n<p><img src=\"/blog/img/box/margin-width.png\" alt=\"加上margin的红色方块的长宽\"></p>\n<p>很明显盒子的大小并没有变大，还是原来的<code>240x240</code>。</p>\n<p>所以，最终盒子的大小为content+padding+border即内容的(width)+内边距的再加上边框，而不加上margin。</p>\n<p>看到网上很多文章都把margin算进去了，如果按照他们所说的，上面盒子的大小应该是<code>240x250</code>，然而实际情况并不是。从这里可以看出，很多人对盒模型有误解。<strong>把margin算进去的那是盒子占据的位置，而不是盒子的大小！</strong></p>\n<p>其实盒模型一共分为两种，一种是上面讲的标准盒模型，还有一种是怪异盒模型，这两种盒模型的区别在于width/height。前者width/height指的是content区域的宽度和高度，后者width/height指的是content+padding+border。</p>\n<p>在ie8+浏览器中使用哪个盒模型可以由<code>box-sizing</code>控制，默认值为<code>content-box</code>，即标准盒模型；如果将<code>box-sizing</code>设为<code>border-box</code>则用的是怪异盒模型。如果在ie6,7,8中DOCTYPE缺失会触发怪异模式。</p>\n<p>我们可以把上面的红色方块的<code>box-sizing</code>设为<code>border-box</code>发现，无论我们怎么改border和padding盒子大小始终是定义的width和height：</p>\n<p><img src=\"/blog/img/box/box-sizing.png\" alt=\"box-sizing\"></p>\n<h1 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h1><p>定位<code>(position)</code>有四个值：</p>\n<ol>\n<li>static</li>\n<li>relative</li>\n<li>absolute</li>\n<li>fixed</li>\n</ol>\n<h2 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h2><p>一般如果我们不设置<code>position</code>的话它的默认值就是<code>static</code>，这个时候left、top、bottom、right是不起作用的<br>，现在有如下两个div，他们的关系是兄弟关系：</p>\n<pre><code>.red{\n    width:200px;\n    height:200px;\n    left:100px;\n    top:100px;\n    background-color:red;\n}\n.blue{\n    width:100px;\n    height:100px;\n    background-color:blue;\n}\n</code></pre><p>效果图：</p>\n<p><img src=\"/blog/img/box/static.png\" alt=\"static\"></p>\n<p>可以发现，并没有什么变化。红色方块的<code>left</code>和<code>top</code>加不加都一样。</p>\n<h2 id=\"relative\"><a href=\"#relative\" class=\"headerlink\" title=\"relative\"></a>relative</h2><p>但是，现在我们给红色方块加个<code>position:relative</code>：</p>\n<pre><code>.red{\n    position:relative;\n    width:200px;\n    height:200px;\n    left:100px;\n    top:100px;\n    background-color:red;\n}\n</code></pre><p>嘿嘿，变这样了：</p>\n<p><img src=\"/blog/img/box/relative.png\" alt=\"relative\"></p>\n<p>可以发现，红色方块跑到蓝色方块的右边了，左边缘和顶边缘都距离原来100px，但是蓝色方块还是在原来的地方不动，现在可以得出一个结论：<strong>使用相对定位给元素加left/top/right/buttom元素会以原来的位置为基础加上这些值，即以原来的位置为基础定位，并且没有脱离文档流</strong></p>\n<p>嗯，是不是看起来有点文绉绉的，那来个形象的比喻吧：</p>\n<p>假如<code>position:static</code>是一个活人的话，并且拥有灵魂，这个时候我想给他加个<code>left:100px</code>想让他的灵魂出来，但是并没有效果。当这个人刚去世而且尸体还没火化的时候(相当于<code>position:relative</code>)，这时我加个<code>left:100px</code>灵魂就可以移动了，并且灵魂往尸体的右边移动了100px。因为尸体还没火化，所以这个人还是占一定的空间的。</p>\n<h2 id=\"absolute\"><a href=\"#absolute\" class=\"headerlink\" title=\"absolute\"></a>absolute</h2><p>现在，我们把<code>position</code>改为<code>absolute</code>：</p>\n<pre><code>.red{\n    position:absolute;\n    width:200px;\n    height:200px;\n    left:100px;\n    top:100px;\n    background-color:red;\n}\n</code></pre><p>效果图：</p>\n<p><img src=\"/blog/img/box/absolute1.png\" alt=\"absolute\"></p>\n<p>可以发现蓝色方块如我们所愿移动到了红色方块的上面，说明红色方块已经脱离文档流。虽然红色方块的位移和<code>relative</code>一样但是，红色方块位移的参考不再是原来的位置而是body只不过红色方块的位置刚好在body的最左上角，刚好碰巧位移一样，上面的这个例子可能看不出来，让我们来改改代码。</p>\n<p>首先将html结构改成：</p>\n<pre><code>&lt;div class=&quot;red&quot;&gt;\n    &lt;div class=&quot;blue&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>然后红色方块的<code>absolute</code>改回<code>relative</code></p>\n<p>效果图：</p>\n<p><img src=\"/blog/img/box/absolute2.png\" alt=\"absolute\"></p>\n<p>然后蓝色方块代码改为：</p>\n<pre><code>.blue{\n    position:absolute;\n    top:100px;\n    left:100px;\n    width:100px;\n    height:100px;\n    background-color:blue;\n}\n</code></pre><p><img src=\"/blog/img/box/absolute3.png\" alt=\"absolute\"></p>\n<p>可以发现在给蓝色方块添加<code>position:absolute</code>前，蓝色方块像我们想的那样在红色方块的左上角；当我们给蓝色方块添加<code>position:absolute</code>并且添加<code>left</code>和<code>top</code>时，蓝色方块就跑到了红色方块的右下角。</p>\n<p>那么这次这个蓝色方块是以谁为参考进行位移的？刚刚你说的以body为参考又是什么情况？</p>\n<p>好，我这里就给大家说清楚，当给一个元素设置<code>position:absolute</code>时，这个元素的位置就是以他父代元素<code>position</code>不为<code>static</code>的元素作为参考，如果他的父代元素都是<code>position:static</code>那就以body作为参考。刚刚红色方块的情况就是他父代元素没有<code>position</code>不为<code>static</code>的元素，所以只能以body作为参考。</p>\n<p>嗯，讲的文绉绉的，我不喜欢。来，举个例子：</p>\n<p>还是刚刚那个人与灵魂的例子，当设置<code>position:absolute</code>时，就相当于人死了，尸体已经火化了，只剩下灵魂和骨灰，所以是不占空间的(就是已经脱离文档流)。这个时候灵魂可以乱飘了，但是有个限制，只能相对于骨灰飘。</p>\n<h2 id=\"fixed\"><a href=\"#fixed\" class=\"headerlink\" title=\"fixed\"></a>fixed</h2><p>现在让我们再来创建一个绿色方块：</p>\n<pre><code>.green{\n    position:fixed;\n    top:150px;\n    left:150px;\n    width:100px;\n    height:100px;\n    background-color:green;\n}\n</code></pre><p>效果图：</p>\n<p><img src=\"/blog/img/box/fixed.png\" alt=\"fixed\"></p>\n<p>这个看起来貌似没有什么特别的，现在我们来给body加个<code>height:2000px</code>(这个高度随意，但是要使浏览器右边出现滚动条)，然后把浏览器的滚动条往下拉，一个神奇的事情发生了：绿色方块固定在我们定义的位置上屏幕上不动了！</p>\n<p><img src=\"/blog/img/box/scroll.png\" alt=\"scroll\"></p>\n<p>这个fixed我们见得最多的就是网页中顽固的小广告，不管我们怎么拖拽滚动条，它总是固定在那，就是一个升级版的<code>absolute</code>。</p>\n<p>用上面的例子来说就是人已经成仙了，可以不受限制地乱飘，而且不管你怎么拉，都拉不动他，他就在那不动了！</p>\n<h2 id=\"z-index\"><a href=\"#z-index\" class=\"headerlink\" title=\"z-index\"></a>z-index</h2><p>说到定位，肯定少不了z-index。用上面的例子来说z-index就是灵魂飘的高度，设置得越大，自然就飘得越高，既然扯到了灵魂，z-index肯定是对活人(<code>static</code>)无效的了。</p>\n<p>正常情况下(没有加z-index)，元素是按照后来居上原则进行堆叠。在这个例子上的html元素是这样的：</p>\n<pre><code>&lt;div class=&quot;red&quot;&gt;\n        &lt;div class=&quot;blue&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n&lt;div class=&quot;green&quot;&gt;&lt;/div&gt;\n</code></pre><p>按照后来居上原则，红色方块最先被浏览器渲染到，所以在最下面，其次到蓝色，最后到绿色。</p>\n<p>如果我们想让红色方块显示到前面我们可以给它加个<code>z-index:1</code>，结果：</p>\n<p><img src=\"/blog/img/box/z-index1.png\" alt=\"z-index\"></p>\n<p>发现绿色方块“消失了”。其实绿色方块并没有消失，你可以将滚动条往下拉，或者看盒子模型：</p>\n<p><img src=\"/blog/img/box/z-index-box.png\" alt=\"z-index\"></p>\n<p>可以发现它并没有消失，只是被盖在了红色方块下面。由于红色方块与蓝色方块是父子关系，红色的上来了，蓝色肯定的上来啊。</p>\n<p>现在我有个想法，想让蓝色方块弄到红色方块下面该怎么办？很多人可能会想到简单啊，直接给蓝色方块加个<code>z-index:-1</code>不就得了吗？但是很可惜，没用。</p>\n<p>要解释这个现象就得扯到<strong>层叠上下文</strong>的东西了。解释这东西又得花些篇幅来讲，具体的可以看<a href=\"http://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n<p>这里我就一笔带过了，用最通俗易懂的例子来解释了，老爸的灵魂包着儿子的灵魂飘到了一楼(z-index:1)，但是儿子想下到-1楼(z-index:-1)这是不行的因为儿子的灵魂已经被老爸的灵魂包着了(当z-index为数值时，会产生层叠上下文)，如果儿子想下到一楼，得先不让老爸的灵魂包着儿子的灵魂(不设置红色方块的z-index或者设置为z-index:auto)，这样就能下到-1楼了这样蓝色方块就被红色方块挡住了。</p>\n<p>但是不设置红色的<code>z-index</code>的话，绿色方块又出来作怪了，这个时候只能设置绿色方块<code>z-index:-1</code>，红色方块就没谁能挡得住了！</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>css的盒模型由content(内容)、padding(内边距)、border(边框)、margin(外边距)组成。</li>\n<li>在w3c和模型中，设置的width/height是content的宽度/高度，在怪异模式中width/height设置的是content+padding+border宽度/高度。</li>\n<li>在w3c盒子模型中盒子的大小由content、padding、border决定，在在怪异模式中盒子大小由width和height决定。</li>\n<li>定位有四个值static(静止)、relative(相对)、absolute(绝对)、fixed(固定)。</li>\n<li>left、top、right、bottom、z-index不能对static起作用。</li>\n</ol>\n<p>有什么问题可以在下面留言哦，会及时给出答复的。</p>\n","site":{"data":{}},"excerpt":"<p>说到css的盒子模型和定位相信大家一定都听说过，因为它们是css中的基础，同时也是难点，这篇文章的作用在于基础知识的扫盲。</p>","more":"<p>先来说说盒子模型吧</p>\n<h1 id=\"什么是盒子模型\"><a href=\"#什么是盒子模型\" class=\"headerlink\" title=\"什么是盒子模型\"></a>什么是盒子模型</h1><p>简单地说每个html标签都是一个方块，然后这个方块又包着几个小方块。分别是：margin、border、padding、content。它们的关系是margin包着border包着padding包着content。就像盒子一层一层地包着一样，这就是我们所说的盒模型。<br>嗯，看上面的文字有点文绉绉的，我们直接上图吧。<br>打开谷歌浏览器，按下F12，然后把右边栏的滚动条拉到最下面你就会看到一个东西：</p>\n<p><img src=\"/blog/img/box/box-model.png\" alt=\"盒模型\"></p>\n<p>这就很直观给我们展示了什么是盒子模型！</p>\n<h1 id=\"盒子有多大\"><a href=\"#盒子有多大\" class=\"headerlink\" title=\"盒子有多大\"></a>盒子有多大</h1><p>我相信这个问题肯定会问倒很多人，这个问题是个非常经典的问题。我在百度上查都能查到有很多人写的博客上都在这方面有错误，所以，我觉得我有必要在这篇文章上讲清楚盒子到底有多大。<br>老规矩，先上代码</p>\n<pre><code>.red{\n    width:200px;\n    height:200px;\n    background-color:red;\n}\n</code></pre><p>补全html代码就会在页面左上角出现这么个玩意儿：</p>\n<p><img src=\"/blog/img/box/width.png\" alt=\"红色方块\"></p>\n<p>对应的盒子模型：</p>\n<p><img src=\"/blog/img/box/width-box.png\" alt=\"红色方块的盒子模型\"></p>\n<p>很明显这个时候的盒子大小就是content的大小。来，我们继续往下走，我们给这个方块加上padding：</p>\n<pre><code>.red{\n    width:200px;\n    height:200px;\n    padding:10px;\n    background-color:red;\n}\n</code></pre><p>这时你就会发现这个方块比原来稍微胖了那么一点：</p>\n<p><img src=\"/blog/img/box/padding.png\" alt=\"加上padding的红色方块\"></p>\n<p>对应的盒模型：</p>\n<p><img src=\"/blog/img/box/padding-box.png\" alt=\"加上padding的红色方块的盒子模型\"></p>\n<p>这个时候将鼠标移到控制台上的这个元素你就会发现：</p>\n<p><img src=\"/blog/img/box/padding-width.png\" alt=\"加上padding的红色方块的长宽\"></p>\n<p>下面写有盒子的长宽变成了<code>220x220</code>，很明显，padding是能够改变盒子的大小的，这时盒子大小就等于content+padding。</p>\n<p>接下来，我们给盒子加上边框：</p>\n<pre><code>.red{\n    width:200px;\n    height:200px;\n    padding:10px;\n    border:10px solid black;\n    background-color:red;\n}\n</code></pre><p>这个时候变成了下面这样：</p>\n<p><img src=\"/blog/img/box/border.png\" alt=\"加上border的红色方块\"></p>\n<p>盒模型：</p>\n<p><img src=\"/blog/img/box/border-box.png\" alt=\"加上border的红色方块的盒模型\"></p>\n<p>它的长宽：</p>\n<p><img src=\"/blog/img/box/border-width.png\" alt=\"加上border的红色方块的长宽\"></p>\n<p>可以发现长宽变为了<code>240x240</code>，所以这时盒子大小就等于content+padding+border。</p>\n<p>接下来讲margin。在给这个方块加margin之前为了方便观察我们加个类名为blue的div，并且加上样式：</p>\n<pre><code>.blue{\n    width:100px;\n    height:100px;\n    background-color:blue;\n}\n</code></pre><p>效果图：</p>\n<p><img src=\"/blog/img/box/blue.png\" alt=\"加个蓝色方块\"></p>\n<p>因为div是块级元素，所以新加的蓝色div自动跑到红色的下面。<br>接下来给红色方块加上margin-bottom：</p>\n<pre><code>.red{\n    width:200px;\n    height:200px;\n    padding:10px;\n    margin-bottom:10px;\n    border:10px solid black;\n    background-color:red;\n}\n</code></pre><p>效果图：</p>\n<p><img src=\"/blog/img/box/margin.png\" alt=\"加上margin\"></p>\n<p>可以发现，盒子的底部产生了10px的空白。</p>\n<p>对应的盒模型</p>\n<p><img src=\"/blog/img/box/margin-box.png\" alt=\"加上margin的红色方块的盒模型\"></p>\n<p>方块的长宽</p>\n<p><img src=\"/blog/img/box/margin-width.png\" alt=\"加上margin的红色方块的长宽\"></p>\n<p>很明显盒子的大小并没有变大，还是原来的<code>240x240</code>。</p>\n<p>所以，最终盒子的大小为content+padding+border即内容的(width)+内边距的再加上边框，而不加上margin。</p>\n<p>看到网上很多文章都把margin算进去了，如果按照他们所说的，上面盒子的大小应该是<code>240x250</code>，然而实际情况并不是。从这里可以看出，很多人对盒模型有误解。<strong>把margin算进去的那是盒子占据的位置，而不是盒子的大小！</strong></p>\n<p>其实盒模型一共分为两种，一种是上面讲的标准盒模型，还有一种是怪异盒模型，这两种盒模型的区别在于width/height。前者width/height指的是content区域的宽度和高度，后者width/height指的是content+padding+border。</p>\n<p>在ie8+浏览器中使用哪个盒模型可以由<code>box-sizing</code>控制，默认值为<code>content-box</code>，即标准盒模型；如果将<code>box-sizing</code>设为<code>border-box</code>则用的是怪异盒模型。如果在ie6,7,8中DOCTYPE缺失会触发怪异模式。</p>\n<p>我们可以把上面的红色方块的<code>box-sizing</code>设为<code>border-box</code>发现，无论我们怎么改border和padding盒子大小始终是定义的width和height：</p>\n<p><img src=\"/blog/img/box/box-sizing.png\" alt=\"box-sizing\"></p>\n<h1 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h1><p>定位<code>(position)</code>有四个值：</p>\n<ol>\n<li>static</li>\n<li>relative</li>\n<li>absolute</li>\n<li>fixed</li>\n</ol>\n<h2 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h2><p>一般如果我们不设置<code>position</code>的话它的默认值就是<code>static</code>，这个时候left、top、bottom、right是不起作用的<br>，现在有如下两个div，他们的关系是兄弟关系：</p>\n<pre><code>.red{\n    width:200px;\n    height:200px;\n    left:100px;\n    top:100px;\n    background-color:red;\n}\n.blue{\n    width:100px;\n    height:100px;\n    background-color:blue;\n}\n</code></pre><p>效果图：</p>\n<p><img src=\"/blog/img/box/static.png\" alt=\"static\"></p>\n<p>可以发现，并没有什么变化。红色方块的<code>left</code>和<code>top</code>加不加都一样。</p>\n<h2 id=\"relative\"><a href=\"#relative\" class=\"headerlink\" title=\"relative\"></a>relative</h2><p>但是，现在我们给红色方块加个<code>position:relative</code>：</p>\n<pre><code>.red{\n    position:relative;\n    width:200px;\n    height:200px;\n    left:100px;\n    top:100px;\n    background-color:red;\n}\n</code></pre><p>嘿嘿，变这样了：</p>\n<p><img src=\"/blog/img/box/relative.png\" alt=\"relative\"></p>\n<p>可以发现，红色方块跑到蓝色方块的右边了，左边缘和顶边缘都距离原来100px，但是蓝色方块还是在原来的地方不动，现在可以得出一个结论：<strong>使用相对定位给元素加left/top/right/buttom元素会以原来的位置为基础加上这些值，即以原来的位置为基础定位，并且没有脱离文档流</strong></p>\n<p>嗯，是不是看起来有点文绉绉的，那来个形象的比喻吧：</p>\n<p>假如<code>position:static</code>是一个活人的话，并且拥有灵魂，这个时候我想给他加个<code>left:100px</code>想让他的灵魂出来，但是并没有效果。当这个人刚去世而且尸体还没火化的时候(相当于<code>position:relative</code>)，这时我加个<code>left:100px</code>灵魂就可以移动了，并且灵魂往尸体的右边移动了100px。因为尸体还没火化，所以这个人还是占一定的空间的。</p>\n<h2 id=\"absolute\"><a href=\"#absolute\" class=\"headerlink\" title=\"absolute\"></a>absolute</h2><p>现在，我们把<code>position</code>改为<code>absolute</code>：</p>\n<pre><code>.red{\n    position:absolute;\n    width:200px;\n    height:200px;\n    left:100px;\n    top:100px;\n    background-color:red;\n}\n</code></pre><p>效果图：</p>\n<p><img src=\"/blog/img/box/absolute1.png\" alt=\"absolute\"></p>\n<p>可以发现蓝色方块如我们所愿移动到了红色方块的上面，说明红色方块已经脱离文档流。虽然红色方块的位移和<code>relative</code>一样但是，红色方块位移的参考不再是原来的位置而是body只不过红色方块的位置刚好在body的最左上角，刚好碰巧位移一样，上面的这个例子可能看不出来，让我们来改改代码。</p>\n<p>首先将html结构改成：</p>\n<pre><code>&lt;div class=&quot;red&quot;&gt;\n    &lt;div class=&quot;blue&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>然后红色方块的<code>absolute</code>改回<code>relative</code></p>\n<p>效果图：</p>\n<p><img src=\"/blog/img/box/absolute2.png\" alt=\"absolute\"></p>\n<p>然后蓝色方块代码改为：</p>\n<pre><code>.blue{\n    position:absolute;\n    top:100px;\n    left:100px;\n    width:100px;\n    height:100px;\n    background-color:blue;\n}\n</code></pre><p><img src=\"/blog/img/box/absolute3.png\" alt=\"absolute\"></p>\n<p>可以发现在给蓝色方块添加<code>position:absolute</code>前，蓝色方块像我们想的那样在红色方块的左上角；当我们给蓝色方块添加<code>position:absolute</code>并且添加<code>left</code>和<code>top</code>时，蓝色方块就跑到了红色方块的右下角。</p>\n<p>那么这次这个蓝色方块是以谁为参考进行位移的？刚刚你说的以body为参考又是什么情况？</p>\n<p>好，我这里就给大家说清楚，当给一个元素设置<code>position:absolute</code>时，这个元素的位置就是以他父代元素<code>position</code>不为<code>static</code>的元素作为参考，如果他的父代元素都是<code>position:static</code>那就以body作为参考。刚刚红色方块的情况就是他父代元素没有<code>position</code>不为<code>static</code>的元素，所以只能以body作为参考。</p>\n<p>嗯，讲的文绉绉的，我不喜欢。来，举个例子：</p>\n<p>还是刚刚那个人与灵魂的例子，当设置<code>position:absolute</code>时，就相当于人死了，尸体已经火化了，只剩下灵魂和骨灰，所以是不占空间的(就是已经脱离文档流)。这个时候灵魂可以乱飘了，但是有个限制，只能相对于骨灰飘。</p>\n<h2 id=\"fixed\"><a href=\"#fixed\" class=\"headerlink\" title=\"fixed\"></a>fixed</h2><p>现在让我们再来创建一个绿色方块：</p>\n<pre><code>.green{\n    position:fixed;\n    top:150px;\n    left:150px;\n    width:100px;\n    height:100px;\n    background-color:green;\n}\n</code></pre><p>效果图：</p>\n<p><img src=\"/blog/img/box/fixed.png\" alt=\"fixed\"></p>\n<p>这个看起来貌似没有什么特别的，现在我们来给body加个<code>height:2000px</code>(这个高度随意，但是要使浏览器右边出现滚动条)，然后把浏览器的滚动条往下拉，一个神奇的事情发生了：绿色方块固定在我们定义的位置上屏幕上不动了！</p>\n<p><img src=\"/blog/img/box/scroll.png\" alt=\"scroll\"></p>\n<p>这个fixed我们见得最多的就是网页中顽固的小广告，不管我们怎么拖拽滚动条，它总是固定在那，就是一个升级版的<code>absolute</code>。</p>\n<p>用上面的例子来说就是人已经成仙了，可以不受限制地乱飘，而且不管你怎么拉，都拉不动他，他就在那不动了！</p>\n<h2 id=\"z-index\"><a href=\"#z-index\" class=\"headerlink\" title=\"z-index\"></a>z-index</h2><p>说到定位，肯定少不了z-index。用上面的例子来说z-index就是灵魂飘的高度，设置得越大，自然就飘得越高，既然扯到了灵魂，z-index肯定是对活人(<code>static</code>)无效的了。</p>\n<p>正常情况下(没有加z-index)，元素是按照后来居上原则进行堆叠。在这个例子上的html元素是这样的：</p>\n<pre><code>&lt;div class=&quot;red&quot;&gt;\n        &lt;div class=&quot;blue&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n&lt;div class=&quot;green&quot;&gt;&lt;/div&gt;\n</code></pre><p>按照后来居上原则，红色方块最先被浏览器渲染到，所以在最下面，其次到蓝色，最后到绿色。</p>\n<p>如果我们想让红色方块显示到前面我们可以给它加个<code>z-index:1</code>，结果：</p>\n<p><img src=\"/blog/img/box/z-index1.png\" alt=\"z-index\"></p>\n<p>发现绿色方块“消失了”。其实绿色方块并没有消失，你可以将滚动条往下拉，或者看盒子模型：</p>\n<p><img src=\"/blog/img/box/z-index-box.png\" alt=\"z-index\"></p>\n<p>可以发现它并没有消失，只是被盖在了红色方块下面。由于红色方块与蓝色方块是父子关系，红色的上来了，蓝色肯定的上来啊。</p>\n<p>现在我有个想法，想让蓝色方块弄到红色方块下面该怎么办？很多人可能会想到简单啊，直接给蓝色方块加个<code>z-index:-1</code>不就得了吗？但是很可惜，没用。</p>\n<p>要解释这个现象就得扯到<strong>层叠上下文</strong>的东西了。解释这东西又得花些篇幅来讲，具体的可以看<a href=\"http://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n<p>这里我就一笔带过了，用最通俗易懂的例子来解释了，老爸的灵魂包着儿子的灵魂飘到了一楼(z-index:1)，但是儿子想下到-1楼(z-index:-1)这是不行的因为儿子的灵魂已经被老爸的灵魂包着了(当z-index为数值时，会产生层叠上下文)，如果儿子想下到一楼，得先不让老爸的灵魂包着儿子的灵魂(不设置红色方块的z-index或者设置为z-index:auto)，这样就能下到-1楼了这样蓝色方块就被红色方块挡住了。</p>\n<p>但是不设置红色的<code>z-index</code>的话，绿色方块又出来作怪了，这个时候只能设置绿色方块<code>z-index:-1</code>，红色方块就没谁能挡得住了！</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>css的盒模型由content(内容)、padding(内边距)、border(边框)、margin(外边距)组成。</li>\n<li>在w3c和模型中，设置的width/height是content的宽度/高度，在怪异模式中width/height设置的是content+padding+border宽度/高度。</li>\n<li>在w3c盒子模型中盒子的大小由content、padding、border决定，在在怪异模式中盒子大小由width和height决定。</li>\n<li>定位有四个值static(静止)、relative(相对)、absolute(绝对)、fixed(固定)。</li>\n<li>left、top、right、bottom、z-index不能对static起作用。</li>\n</ol>\n<p>有什么问题可以在下面留言哦，会及时给出答复的。</p>"},{"title":"sass基础","date":"2016-08-09T11:27:28.000Z","_content":"# sass语法糖  \n\n用了两天的时间看了一下sass的一些语法，对于熟悉css的我来说,看sass基本没遇到什么困难。  \n\n为了避免忘记，现在来写些sass的一些笔记。\n\n<!-- more-->\n\n## sass安装  \n\n因为sass是基于[Ruby的](http://rubyinstaller.org/downloads)，所以点开链接下载吧。  \n\n安装过程中在选择路径的下面有三个选项![sass安装](http://img.mukewang.com/54f561190001531806350474.jpg \"选第二个\"),其它的我就不多说了。  \n\n然后打开命令行工具输入：  \n\n\n    gem install sass\n\n\n稍等片刻，sass就安装好了。  \n\n要更新的话在命令行工具输入：  \n\n\n    gem update sass\n\n\n就得了\n\n## 开始编写sass\n\n新建一个*.scss*文件，用你喜欢的编译器打开  \n\nsass语法和css语法类似像下面：\n\n\n    body{\n    margin:0;\n    padding:0;\n    }\n    \n\n用[grunt](https://www.npmjs.com/package/grunt-contrib-sass)或者命令：\n\n\n    sass \"要编译的Sass文件路径\"/\"文件名\".scss:\"要输出CSS文件路径\"/\"文件名\".css\n\n编译出来的css代码：\n\n\n    body{\n    margin:0;\n    padding:0;\n    }\n\n\nsass的`--watch \"要编译的Sass文件路径\"/\"文件名\".scss:\"要输出CSS文件路径\"/\"文件名\".css`命令也可以像[grunt-watch](https://www.npmjs.com/package/grunt-contrib-watch)一样监视文件的改动 \n\n### 用变量编写sass\n\nsass也可以声明变量，声明变量的方法`$+变量名`，例如：\n\n\n    $variable=100px;\n    body{\n    width:$variable;\n    }\n\n编译出来就是：\n\n\n    body{\n    width:100px;\n    }\n\n\n如果要声明默认变量，在声明的变量后面加个` !default`即可。\n\n\n    $variable=50px !default;\n    body{\n    width:$variable;\n    }\n\n编译出来就是：\n\n\n    body{\n    width:50px;\n    }\n\n\n### 嵌套\n在sass中，可以使用选择器嵌套，属性嵌套，伪类嵌套,例如：\n\n\n    nav{\n        a{\n            color:red;\n            margin:{\n                left:10px;\n                top:100px;\n            }\n            &:hover\n            {\n                color:yellow;\n            }\n            &:visited\n            {\n                color:black;\n            }\n        header &{\n            color:green;\n        }\n        }\n    }\n\n\n编译出来就是：\n\n\n    nav a {\n    color: red;\n    margin-left: 10px;\n    margin-top: 100px; \n    }\n\n    nav a:hover {\n    color: yellow; \n    }\n\n    nav a:visited {\n    color: black; \n    }\n\n    header nav a {\n    color: green; \n    }\n    \n    \n  ### 混合宏\n  \n  混合宏是用来处理重复的样式，就像js中的有名函数一样，只要声明了，就可以无数次调用  \n  \n  \n  声明：\n  \n  \n      @mixin name{\n            transform: scale(2);\n            -webkit-transform: scale(2);\n            -moz-transform:scale(2);\n            -o-transform: scale(2);\n            -ms-transform: scale(2);\n      }\n\n\n  调用：\n\n\n      img{\n        @include name;\n      }\n\n\n编译出来就是：\n\n\n    img\n    {\n        transform: scale(2);\n        -webkit-transform: scale(2);\n        -moz-transform:scale(2);\n        -o-transform: scale(2);\n        -ms-transform: scale(2);\n    }\n\n\n当然，混合宏也可以传参数：\n\n\n     @mixin name($scale){\n        transform:$scale;\n        -webkit-transform:$scale;\n        -moz-transform:$scale;\n        -o-transform:$scale;\n        -ms-transform:$scale;\n    }\n    img{\n        @include name(scale(2));\n    }\n    \n    \n编译出来就是：\n\n\n    img {\n    transform: scale(2);\n    -webkit-transform: scale(2);\n    -moz-transform: scale(2);\n    -o-transform: scale(2);\n    -ms-transform: scale(2); \n    }\n\n\n这样，只要调用这个混合宏就不用像css那样写一堆兼容代码了，确实方便不少  \n\n当然，混合宏也可以传多个参数，当参数过多时，可以用`...`代替，例如：\n\n\n    @mixin box-shadow($shadows...){\n    @if length($shadows) >= 1 {\n        -webkit-box-shadow: $shadows;\n        box-shadow: $shadows;\n    } @else {\n        $shadows: 0 0 2px rgba(#000,.25);\n        -webkit-box-shadow: $shadow;\n        box-shadow: $shadow;\n            }\n    }\n\n    .box {\n        @include box-shadow(0 0 1px rgba(#000,.5));\n    }\n\n\n编译出来就是：\n\n\n    .box {\n    -webkit-box-shadow: 0 0 1px rgba(0, 0, 0, 0.5);\n    box-shadow: 0 0 1px rgba(0, 0, 0, 0.5); \n    }\n\n\n### 继承\n\n在css中有继承样式(子元素可以继承父元素的某些样式，例如font-family可以给子元素继承),在sass中可以使用`@extend`实现样式继承：\n\n\n    .btn {\n     border: 1px solid #ccc;\n    padding: 6px 10px;\n    font-size: 14px;\n    }\n    \n    .btn-primary {\n    background-color: #f36;\n    color: #fff;\n    @extend .btn;\n    }\n\n\n编译出来就是：\n\n\n    .btn,.btn-primary {\n\n    border: 1px solid #ccc;\n\n    padding: 6px 10px;\n\n    font-size: 14px; \n    }\n\n    .btn-primary {\n\n    background-color: #f36;\n\n    color: #fff; \n    }\n\n\n这样又减少了我们写重复的代码了！  \n\n### 占位符%\n\nSass 中的占位符 `%` 功能是一个很强大，很实用的一个功能，因为 `%` 声明的代码，如果不被 `@extend` 调用的话，不会产生任何代码：\n\n\n    %mt5 {\n    margin-top: 5px;\n    }\n    %pt5{\n    padding-top: 5px;\n    }\n    .btn\n    {\n        @extend %mt5;\n    }\n\n\n编译出来就是：\n\n\n    .btn {\n    margin-top: 5px; \n    }\n    \n\n### 插值`#{}`\n\n使用 CSS 预处理器语言的一个主要原因是想使用 Sass 获得一个更好的结构体系。比如说你想写更干净的、高效的和面向对象的 CSS。Sass 中的插值就是重要的一部分，例如，最开始的那个混合宏还可以变为：\n\n\n    @mixin name($transform,$scale){\n    -webkit-#{$transform}:$scale;\n    -moz-#{$transform}:$scale;\n    -o-#{$transform}:$scale;\n    -ms-#{$transform}:$scale;\n    #{$transform}:$scale;\n    }\n    img{\n        @include name(transform,scale(2));\n    }\n\n\n编译出来就是：\n\n\n    img {\n    -webkit-transform: scale(2);\n    -moz-transform: scale(2);\n    -o-transform: scale(2);\n    -ms-transform: scale(2);\n    transform: scale(2); \n    }\n\n\n这样上面这个名为*name*的混合宏就可以变为更灵活，可以帮我们写各种css的兼容前缀。  \n\n### 运算\n\n在css中只有calc()函数可以进行数字运算。然而，在sass中可以直接使用算术运算符来对数据进行运算：\n\n\n    .box {\n    width: 20px + 8in;//1in=96px\n    height: 8in - 20px;//当对变量进行运算时-前面需要有空格\n    font-size: 10px * 2;\n    background-position:(100px/2);\n    }\n\n\n编译出来就是：\n\n\n    .box {\n    width: 788px;\n    height: 748px;\n    font-size: 20px;\n    background-position:50px;\n    }\n\n但对于不同单位进行计算时，会报错，例如：\n\n\n    .box {\n    width: 20px + 1em;\n    }\n\n\n编译时会报错：`Incompatible units: 'em' and 'px'.`\n\n### 颜色运算\n\n所有算数运算都支持颜色值，并且是分段运算的。也就是说，红、绿和蓝各颜色分段单独进行运算。如：\n\n\n    p {\n    color: #010203 + #040506;\n    }\n\n\n计算公式为 01 + 04 = 05、02 + 05 = 07 和 03 + 06 = 09   \n\n编译出来就是：\n\n\n    p {\n    color: #050709;\n    }\n\n\n如果`#ffffff`再加的话编译出来就是`white`，同理`#000000`再减的话就是`black`  \n\n`#000000`不论乘什么除什么编译出来都是`black`，`#ffffff`不论乘什么编译出来都是`white`\n\n### 字符运算\n\n在 Sass 中可以通过加法符号`+`来对字符串进行连接。例如：\n\n\n    $content: \"Hello\" + \"\" + \"Sass!\";\n    .box:before {\n    content: \" #{$content} \";\n    }\n\n\n编译出来就是：\n\n\n    .box:before {\n    content: \" Hello Sass! \";\n    }\n    \n\n注意，如果有引号的字符串被添加了一个没有引号的字符串 （也就是，带引号的字符串在 + 符号左侧）， 结果会是一个有引号的字符串。 同样的，如果一个没有引号的字符串被添加了一个有引号的字符串 （没有引号的字符串在 + 符号左侧）， 结果将是一个没有引号的字符串。 例如：\n\n\n    p:before {\n    content: \"Foo \" + Bar;\n    font-family: sans- + \"serif\";\n    }\n\n\n编译出来就是：\n\n\n    p:before {\n    content: \"Foo Bar\";\n    font-family: sans-serif; \n    }\n\n\n至此sass基础第一篇文章就写完了，有什么意见的在下面留言吧。","source":"_posts/Basics sass.md","raw":"---\ntitle: sass基础\ndate: 2016-08-09 19:27:28\ntags: sass\n---\n# sass语法糖  \n\n用了两天的时间看了一下sass的一些语法，对于熟悉css的我来说,看sass基本没遇到什么困难。  \n\n为了避免忘记，现在来写些sass的一些笔记。\n\n<!-- more-->\n\n## sass安装  \n\n因为sass是基于[Ruby的](http://rubyinstaller.org/downloads)，所以点开链接下载吧。  \n\n安装过程中在选择路径的下面有三个选项![sass安装](http://img.mukewang.com/54f561190001531806350474.jpg \"选第二个\"),其它的我就不多说了。  \n\n然后打开命令行工具输入：  \n\n\n    gem install sass\n\n\n稍等片刻，sass就安装好了。  \n\n要更新的话在命令行工具输入：  \n\n\n    gem update sass\n\n\n就得了\n\n## 开始编写sass\n\n新建一个*.scss*文件，用你喜欢的编译器打开  \n\nsass语法和css语法类似像下面：\n\n\n    body{\n    margin:0;\n    padding:0;\n    }\n    \n\n用[grunt](https://www.npmjs.com/package/grunt-contrib-sass)或者命令：\n\n\n    sass \"要编译的Sass文件路径\"/\"文件名\".scss:\"要输出CSS文件路径\"/\"文件名\".css\n\n编译出来的css代码：\n\n\n    body{\n    margin:0;\n    padding:0;\n    }\n\n\nsass的`--watch \"要编译的Sass文件路径\"/\"文件名\".scss:\"要输出CSS文件路径\"/\"文件名\".css`命令也可以像[grunt-watch](https://www.npmjs.com/package/grunt-contrib-watch)一样监视文件的改动 \n\n### 用变量编写sass\n\nsass也可以声明变量，声明变量的方法`$+变量名`，例如：\n\n\n    $variable=100px;\n    body{\n    width:$variable;\n    }\n\n编译出来就是：\n\n\n    body{\n    width:100px;\n    }\n\n\n如果要声明默认变量，在声明的变量后面加个` !default`即可。\n\n\n    $variable=50px !default;\n    body{\n    width:$variable;\n    }\n\n编译出来就是：\n\n\n    body{\n    width:50px;\n    }\n\n\n### 嵌套\n在sass中，可以使用选择器嵌套，属性嵌套，伪类嵌套,例如：\n\n\n    nav{\n        a{\n            color:red;\n            margin:{\n                left:10px;\n                top:100px;\n            }\n            &:hover\n            {\n                color:yellow;\n            }\n            &:visited\n            {\n                color:black;\n            }\n        header &{\n            color:green;\n        }\n        }\n    }\n\n\n编译出来就是：\n\n\n    nav a {\n    color: red;\n    margin-left: 10px;\n    margin-top: 100px; \n    }\n\n    nav a:hover {\n    color: yellow; \n    }\n\n    nav a:visited {\n    color: black; \n    }\n\n    header nav a {\n    color: green; \n    }\n    \n    \n  ### 混合宏\n  \n  混合宏是用来处理重复的样式，就像js中的有名函数一样，只要声明了，就可以无数次调用  \n  \n  \n  声明：\n  \n  \n      @mixin name{\n            transform: scale(2);\n            -webkit-transform: scale(2);\n            -moz-transform:scale(2);\n            -o-transform: scale(2);\n            -ms-transform: scale(2);\n      }\n\n\n  调用：\n\n\n      img{\n        @include name;\n      }\n\n\n编译出来就是：\n\n\n    img\n    {\n        transform: scale(2);\n        -webkit-transform: scale(2);\n        -moz-transform:scale(2);\n        -o-transform: scale(2);\n        -ms-transform: scale(2);\n    }\n\n\n当然，混合宏也可以传参数：\n\n\n     @mixin name($scale){\n        transform:$scale;\n        -webkit-transform:$scale;\n        -moz-transform:$scale;\n        -o-transform:$scale;\n        -ms-transform:$scale;\n    }\n    img{\n        @include name(scale(2));\n    }\n    \n    \n编译出来就是：\n\n\n    img {\n    transform: scale(2);\n    -webkit-transform: scale(2);\n    -moz-transform: scale(2);\n    -o-transform: scale(2);\n    -ms-transform: scale(2); \n    }\n\n\n这样，只要调用这个混合宏就不用像css那样写一堆兼容代码了，确实方便不少  \n\n当然，混合宏也可以传多个参数，当参数过多时，可以用`...`代替，例如：\n\n\n    @mixin box-shadow($shadows...){\n    @if length($shadows) >= 1 {\n        -webkit-box-shadow: $shadows;\n        box-shadow: $shadows;\n    } @else {\n        $shadows: 0 0 2px rgba(#000,.25);\n        -webkit-box-shadow: $shadow;\n        box-shadow: $shadow;\n            }\n    }\n\n    .box {\n        @include box-shadow(0 0 1px rgba(#000,.5));\n    }\n\n\n编译出来就是：\n\n\n    .box {\n    -webkit-box-shadow: 0 0 1px rgba(0, 0, 0, 0.5);\n    box-shadow: 0 0 1px rgba(0, 0, 0, 0.5); \n    }\n\n\n### 继承\n\n在css中有继承样式(子元素可以继承父元素的某些样式，例如font-family可以给子元素继承),在sass中可以使用`@extend`实现样式继承：\n\n\n    .btn {\n     border: 1px solid #ccc;\n    padding: 6px 10px;\n    font-size: 14px;\n    }\n    \n    .btn-primary {\n    background-color: #f36;\n    color: #fff;\n    @extend .btn;\n    }\n\n\n编译出来就是：\n\n\n    .btn,.btn-primary {\n\n    border: 1px solid #ccc;\n\n    padding: 6px 10px;\n\n    font-size: 14px; \n    }\n\n    .btn-primary {\n\n    background-color: #f36;\n\n    color: #fff; \n    }\n\n\n这样又减少了我们写重复的代码了！  \n\n### 占位符%\n\nSass 中的占位符 `%` 功能是一个很强大，很实用的一个功能，因为 `%` 声明的代码，如果不被 `@extend` 调用的话，不会产生任何代码：\n\n\n    %mt5 {\n    margin-top: 5px;\n    }\n    %pt5{\n    padding-top: 5px;\n    }\n    .btn\n    {\n        @extend %mt5;\n    }\n\n\n编译出来就是：\n\n\n    .btn {\n    margin-top: 5px; \n    }\n    \n\n### 插值`#{}`\n\n使用 CSS 预处理器语言的一个主要原因是想使用 Sass 获得一个更好的结构体系。比如说你想写更干净的、高效的和面向对象的 CSS。Sass 中的插值就是重要的一部分，例如，最开始的那个混合宏还可以变为：\n\n\n    @mixin name($transform,$scale){\n    -webkit-#{$transform}:$scale;\n    -moz-#{$transform}:$scale;\n    -o-#{$transform}:$scale;\n    -ms-#{$transform}:$scale;\n    #{$transform}:$scale;\n    }\n    img{\n        @include name(transform,scale(2));\n    }\n\n\n编译出来就是：\n\n\n    img {\n    -webkit-transform: scale(2);\n    -moz-transform: scale(2);\n    -o-transform: scale(2);\n    -ms-transform: scale(2);\n    transform: scale(2); \n    }\n\n\n这样上面这个名为*name*的混合宏就可以变为更灵活，可以帮我们写各种css的兼容前缀。  \n\n### 运算\n\n在css中只有calc()函数可以进行数字运算。然而，在sass中可以直接使用算术运算符来对数据进行运算：\n\n\n    .box {\n    width: 20px + 8in;//1in=96px\n    height: 8in - 20px;//当对变量进行运算时-前面需要有空格\n    font-size: 10px * 2;\n    background-position:(100px/2);\n    }\n\n\n编译出来就是：\n\n\n    .box {\n    width: 788px;\n    height: 748px;\n    font-size: 20px;\n    background-position:50px;\n    }\n\n但对于不同单位进行计算时，会报错，例如：\n\n\n    .box {\n    width: 20px + 1em;\n    }\n\n\n编译时会报错：`Incompatible units: 'em' and 'px'.`\n\n### 颜色运算\n\n所有算数运算都支持颜色值，并且是分段运算的。也就是说，红、绿和蓝各颜色分段单独进行运算。如：\n\n\n    p {\n    color: #010203 + #040506;\n    }\n\n\n计算公式为 01 + 04 = 05、02 + 05 = 07 和 03 + 06 = 09   \n\n编译出来就是：\n\n\n    p {\n    color: #050709;\n    }\n\n\n如果`#ffffff`再加的话编译出来就是`white`，同理`#000000`再减的话就是`black`  \n\n`#000000`不论乘什么除什么编译出来都是`black`，`#ffffff`不论乘什么编译出来都是`white`\n\n### 字符运算\n\n在 Sass 中可以通过加法符号`+`来对字符串进行连接。例如：\n\n\n    $content: \"Hello\" + \"\" + \"Sass!\";\n    .box:before {\n    content: \" #{$content} \";\n    }\n\n\n编译出来就是：\n\n\n    .box:before {\n    content: \" Hello Sass! \";\n    }\n    \n\n注意，如果有引号的字符串被添加了一个没有引号的字符串 （也就是，带引号的字符串在 + 符号左侧）， 结果会是一个有引号的字符串。 同样的，如果一个没有引号的字符串被添加了一个有引号的字符串 （没有引号的字符串在 + 符号左侧）， 结果将是一个没有引号的字符串。 例如：\n\n\n    p:before {\n    content: \"Foo \" + Bar;\n    font-family: sans- + \"serif\";\n    }\n\n\n编译出来就是：\n\n\n    p:before {\n    content: \"Foo Bar\";\n    font-family: sans-serif; \n    }\n\n\n至此sass基础第一篇文章就写完了，有什么意见的在下面留言吧。","slug":"Basics sass","published":1,"updated":"2020-04-07T03:29:17.928Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8qzc33q00012cl6aj3rsbmn","content":"<h1 id=\"sass语法糖\"><a href=\"#sass语法糖\" class=\"headerlink\" title=\"sass语法糖\"></a>sass语法糖</h1><p>用了两天的时间看了一下sass的一些语法，对于熟悉css的我来说,看sass基本没遇到什么困难。  </p>\n<p>为了避免忘记，现在来写些sass的一些笔记。</p>\n<a id=\"more\"></a>\n<h2 id=\"sass安装\"><a href=\"#sass安装\" class=\"headerlink\" title=\"sass安装\"></a>sass安装</h2><p>因为sass是基于<a href=\"http://rubyinstaller.org/downloads\" target=\"_blank\" rel=\"noopener\">Ruby的</a>，所以点开链接下载吧。  </p>\n<p>安装过程中在选择路径的下面有三个选项<img src=\"http://img.mukewang.com/54f561190001531806350474.jpg\" alt=\"sass安装\" title=\"选第二个\">,其它的我就不多说了。  </p>\n<p>然后打开命令行工具输入：  </p>\n<pre><code>gem install sass\n</code></pre><p>稍等片刻，sass就安装好了。  </p>\n<p>要更新的话在命令行工具输入：  </p>\n<pre><code>gem update sass\n</code></pre><p>就得了</p>\n<h2 id=\"开始编写sass\"><a href=\"#开始编写sass\" class=\"headerlink\" title=\"开始编写sass\"></a>开始编写sass</h2><p>新建一个<em>.scss</em>文件，用你喜欢的编译器打开  </p>\n<p>sass语法和css语法类似像下面：</p>\n<pre><code>body{\nmargin:0;\npadding:0;\n}\n</code></pre><p>用<a href=\"https://www.npmjs.com/package/grunt-contrib-sass\" target=\"_blank\" rel=\"noopener\">grunt</a>或者命令：</p>\n<pre><code>sass &quot;要编译的Sass文件路径&quot;/&quot;文件名&quot;.scss:&quot;要输出CSS文件路径&quot;/&quot;文件名&quot;.css\n</code></pre><p>编译出来的css代码：</p>\n<pre><code>body{\nmargin:0;\npadding:0;\n}\n</code></pre><p>sass的<code>--watch &quot;要编译的Sass文件路径&quot;/&quot;文件名&quot;.scss:&quot;要输出CSS文件路径&quot;/&quot;文件名&quot;.css</code>命令也可以像<a href=\"https://www.npmjs.com/package/grunt-contrib-watch\" target=\"_blank\" rel=\"noopener\">grunt-watch</a>一样监视文件的改动 </p>\n<h3 id=\"用变量编写sass\"><a href=\"#用变量编写sass\" class=\"headerlink\" title=\"用变量编写sass\"></a>用变量编写sass</h3><p>sass也可以声明变量，声明变量的方法<code>$+变量名</code>，例如：</p>\n<pre><code>$variable=100px;\nbody{\nwidth:$variable;\n}\n</code></pre><p>编译出来就是：</p>\n<pre><code>body{\nwidth:100px;\n}\n</code></pre><p>如果要声明默认变量，在声明的变量后面加个<code>!default</code>即可。</p>\n<pre><code>$variable=50px !default;\nbody{\nwidth:$variable;\n}\n</code></pre><p>编译出来就是：</p>\n<pre><code>body{\nwidth:50px;\n}\n</code></pre><h3 id=\"嵌套\"><a href=\"#嵌套\" class=\"headerlink\" title=\"嵌套\"></a>嵌套</h3><p>在sass中，可以使用选择器嵌套，属性嵌套，伪类嵌套,例如：</p>\n<pre><code>nav{\n    a{\n        color:red;\n        margin:{\n            left:10px;\n            top:100px;\n        }\n        &amp;:hover\n        {\n            color:yellow;\n        }\n        &amp;:visited\n        {\n            color:black;\n        }\n    header &amp;{\n        color:green;\n    }\n    }\n}\n</code></pre><p>编译出来就是：</p>\n<pre><code>nav a {\ncolor: red;\nmargin-left: 10px;\nmargin-top: 100px; \n}\n\nnav a:hover {\ncolor: yellow; \n}\n\nnav a:visited {\ncolor: black; \n}\n\nheader nav a {\ncolor: green; \n}\n</code></pre><h3 id=\"混合宏\"><a href=\"#混合宏\" class=\"headerlink\" title=\"混合宏\"></a>混合宏</h3><p>  混合宏是用来处理重复的样式，就像js中的有名函数一样，只要声明了，就可以无数次调用  </p>\n<p>  声明：</p>\n<pre><code>@mixin name{\n      transform: scale(2);\n      -webkit-transform: scale(2);\n      -moz-transform:scale(2);\n      -o-transform: scale(2);\n      -ms-transform: scale(2);\n}\n</code></pre><p>  调用：</p>\n<pre><code>img{\n  @include name;\n}\n</code></pre><p>编译出来就是：</p>\n<pre><code>img\n{\n    transform: scale(2);\n    -webkit-transform: scale(2);\n    -moz-transform:scale(2);\n    -o-transform: scale(2);\n    -ms-transform: scale(2);\n}\n</code></pre><p>当然，混合宏也可以传参数：</p>\n<pre><code> @mixin name($scale){\n    transform:$scale;\n    -webkit-transform:$scale;\n    -moz-transform:$scale;\n    -o-transform:$scale;\n    -ms-transform:$scale;\n}\nimg{\n    @include name(scale(2));\n}\n</code></pre><p>编译出来就是：</p>\n<pre><code>img {\ntransform: scale(2);\n-webkit-transform: scale(2);\n-moz-transform: scale(2);\n-o-transform: scale(2);\n-ms-transform: scale(2); \n}\n</code></pre><p>这样，只要调用这个混合宏就不用像css那样写一堆兼容代码了，确实方便不少  </p>\n<p>当然，混合宏也可以传多个参数，当参数过多时，可以用<code>...</code>代替，例如：</p>\n<pre><code>@mixin box-shadow($shadows...){\n@if length($shadows) &gt;= 1 {\n    -webkit-box-shadow: $shadows;\n    box-shadow: $shadows;\n} @else {\n    $shadows: 0 0 2px rgba(#000,.25);\n    -webkit-box-shadow: $shadow;\n    box-shadow: $shadow;\n        }\n}\n\n.box {\n    @include box-shadow(0 0 1px rgba(#000,.5));\n}\n</code></pre><p>编译出来就是：</p>\n<pre><code>.box {\n-webkit-box-shadow: 0 0 1px rgba(0, 0, 0, 0.5);\nbox-shadow: 0 0 1px rgba(0, 0, 0, 0.5); \n}\n</code></pre><h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>在css中有继承样式(子元素可以继承父元素的某些样式，例如font-family可以给子元素继承),在sass中可以使用<code>@extend</code>实现样式继承：</p>\n<pre><code>.btn {\n border: 1px solid #ccc;\npadding: 6px 10px;\nfont-size: 14px;\n}\n\n.btn-primary {\nbackground-color: #f36;\ncolor: #fff;\n@extend .btn;\n}\n</code></pre><p>编译出来就是：</p>\n<pre><code>.btn,.btn-primary {\n\nborder: 1px solid #ccc;\n\npadding: 6px 10px;\n\nfont-size: 14px; \n}\n\n.btn-primary {\n\nbackground-color: #f36;\n\ncolor: #fff; \n}\n</code></pre><p>这样又减少了我们写重复的代码了！  </p>\n<h3 id=\"占位符\"><a href=\"#占位符\" class=\"headerlink\" title=\"占位符%\"></a>占位符%</h3><p>Sass 中的占位符 <code>%</code> 功能是一个很强大，很实用的一个功能，因为 <code>%</code> 声明的代码，如果不被 <code>@extend</code> 调用的话，不会产生任何代码：</p>\n<pre><code>%mt5 {\nmargin-top: 5px;\n}\n%pt5{\npadding-top: 5px;\n}\n.btn\n{\n    @extend %mt5;\n}\n</code></pre><p>编译出来就是：</p>\n<pre><code>.btn {\nmargin-top: 5px; \n}\n</code></pre><h3 id=\"插值\"><a href=\"#插值\" class=\"headerlink\" title=\"插值#{}\"></a>插值<code>#{}</code></h3><p>使用 CSS 预处理器语言的一个主要原因是想使用 Sass 获得一个更好的结构体系。比如说你想写更干净的、高效的和面向对象的 CSS。Sass 中的插值就是重要的一部分，例如，最开始的那个混合宏还可以变为：</p>\n<pre><code>@mixin name($transform,$scale){\n-webkit-#{$transform}:$scale;\n-moz-#{$transform}:$scale;\n-o-#{$transform}:$scale;\n-ms-#{$transform}:$scale;\n#{$transform}:$scale;\n}\nimg{\n    @include name(transform,scale(2));\n}\n</code></pre><p>编译出来就是：</p>\n<pre><code>img {\n-webkit-transform: scale(2);\n-moz-transform: scale(2);\n-o-transform: scale(2);\n-ms-transform: scale(2);\ntransform: scale(2); \n}\n</code></pre><p>这样上面这个名为<em>name</em>的混合宏就可以变为更灵活，可以帮我们写各种css的兼容前缀。  </p>\n<h3 id=\"运算\"><a href=\"#运算\" class=\"headerlink\" title=\"运算\"></a>运算</h3><p>在css中只有calc()函数可以进行数字运算。然而，在sass中可以直接使用算术运算符来对数据进行运算：</p>\n<pre><code>.box {\nwidth: 20px + 8in;//1in=96px\nheight: 8in - 20px;//当对变量进行运算时-前面需要有空格\nfont-size: 10px * 2;\nbackground-position:(100px/2);\n}\n</code></pre><p>编译出来就是：</p>\n<pre><code>.box {\nwidth: 788px;\nheight: 748px;\nfont-size: 20px;\nbackground-position:50px;\n}\n</code></pre><p>但对于不同单位进行计算时，会报错，例如：</p>\n<pre><code>.box {\nwidth: 20px + 1em;\n}\n</code></pre><p>编译时会报错：<code>Incompatible units: &#39;em&#39; and &#39;px&#39;.</code></p>\n<h3 id=\"颜色运算\"><a href=\"#颜色运算\" class=\"headerlink\" title=\"颜色运算\"></a>颜色运算</h3><p>所有算数运算都支持颜色值，并且是分段运算的。也就是说，红、绿和蓝各颜色分段单独进行运算。如：</p>\n<pre><code>p {\ncolor: #010203 + #040506;\n}\n</code></pre><p>计算公式为 01 + 04 = 05、02 + 05 = 07 和 03 + 06 = 09   </p>\n<p>编译出来就是：</p>\n<pre><code>p {\ncolor: #050709;\n}\n</code></pre><p>如果<code>#ffffff</code>再加的话编译出来就是<code>white</code>，同理<code>#000000</code>再减的话就是<code>black</code>  </p>\n<p><code>#000000</code>不论乘什么除什么编译出来都是<code>black</code>，<code>#ffffff</code>不论乘什么编译出来都是<code>white</code></p>\n<h3 id=\"字符运算\"><a href=\"#字符运算\" class=\"headerlink\" title=\"字符运算\"></a>字符运算</h3><p>在 Sass 中可以通过加法符号<code>+</code>来对字符串进行连接。例如：</p>\n<pre><code>$content: &quot;Hello&quot; + &quot;&quot; + &quot;Sass!&quot;;\n.box:before {\ncontent: &quot; #{$content} &quot;;\n}\n</code></pre><p>编译出来就是：</p>\n<pre><code>.box:before {\ncontent: &quot; Hello Sass! &quot;;\n}\n</code></pre><p>注意，如果有引号的字符串被添加了一个没有引号的字符串 （也就是，带引号的字符串在 + 符号左侧）， 结果会是一个有引号的字符串。 同样的，如果一个没有引号的字符串被添加了一个有引号的字符串 （没有引号的字符串在 + 符号左侧）， 结果将是一个没有引号的字符串。 例如：</p>\n<pre><code>p:before {\ncontent: &quot;Foo &quot; + Bar;\nfont-family: sans- + &quot;serif&quot;;\n}\n</code></pre><p>编译出来就是：</p>\n<pre><code>p:before {\ncontent: &quot;Foo Bar&quot;;\nfont-family: sans-serif; \n}\n</code></pre><p>至此sass基础第一篇文章就写完了，有什么意见的在下面留言吧。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"sass语法糖\"><a href=\"#sass语法糖\" class=\"headerlink\" title=\"sass语法糖\"></a>sass语法糖</h1><p>用了两天的时间看了一下sass的一些语法，对于熟悉css的我来说,看sass基本没遇到什么困难。  </p>\n<p>为了避免忘记，现在来写些sass的一些笔记。</p>","more":"<h2 id=\"sass安装\"><a href=\"#sass安装\" class=\"headerlink\" title=\"sass安装\"></a>sass安装</h2><p>因为sass是基于<a href=\"http://rubyinstaller.org/downloads\" target=\"_blank\" rel=\"noopener\">Ruby的</a>，所以点开链接下载吧。  </p>\n<p>安装过程中在选择路径的下面有三个选项<img src=\"http://img.mukewang.com/54f561190001531806350474.jpg\" alt=\"sass安装\" title=\"选第二个\">,其它的我就不多说了。  </p>\n<p>然后打开命令行工具输入：  </p>\n<pre><code>gem install sass\n</code></pre><p>稍等片刻，sass就安装好了。  </p>\n<p>要更新的话在命令行工具输入：  </p>\n<pre><code>gem update sass\n</code></pre><p>就得了</p>\n<h2 id=\"开始编写sass\"><a href=\"#开始编写sass\" class=\"headerlink\" title=\"开始编写sass\"></a>开始编写sass</h2><p>新建一个<em>.scss</em>文件，用你喜欢的编译器打开  </p>\n<p>sass语法和css语法类似像下面：</p>\n<pre><code>body{\nmargin:0;\npadding:0;\n}\n</code></pre><p>用<a href=\"https://www.npmjs.com/package/grunt-contrib-sass\" target=\"_blank\" rel=\"noopener\">grunt</a>或者命令：</p>\n<pre><code>sass &quot;要编译的Sass文件路径&quot;/&quot;文件名&quot;.scss:&quot;要输出CSS文件路径&quot;/&quot;文件名&quot;.css\n</code></pre><p>编译出来的css代码：</p>\n<pre><code>body{\nmargin:0;\npadding:0;\n}\n</code></pre><p>sass的<code>--watch &quot;要编译的Sass文件路径&quot;/&quot;文件名&quot;.scss:&quot;要输出CSS文件路径&quot;/&quot;文件名&quot;.css</code>命令也可以像<a href=\"https://www.npmjs.com/package/grunt-contrib-watch\" target=\"_blank\" rel=\"noopener\">grunt-watch</a>一样监视文件的改动 </p>\n<h3 id=\"用变量编写sass\"><a href=\"#用变量编写sass\" class=\"headerlink\" title=\"用变量编写sass\"></a>用变量编写sass</h3><p>sass也可以声明变量，声明变量的方法<code>$+变量名</code>，例如：</p>\n<pre><code>$variable=100px;\nbody{\nwidth:$variable;\n}\n</code></pre><p>编译出来就是：</p>\n<pre><code>body{\nwidth:100px;\n}\n</code></pre><p>如果要声明默认变量，在声明的变量后面加个<code>!default</code>即可。</p>\n<pre><code>$variable=50px !default;\nbody{\nwidth:$variable;\n}\n</code></pre><p>编译出来就是：</p>\n<pre><code>body{\nwidth:50px;\n}\n</code></pre><h3 id=\"嵌套\"><a href=\"#嵌套\" class=\"headerlink\" title=\"嵌套\"></a>嵌套</h3><p>在sass中，可以使用选择器嵌套，属性嵌套，伪类嵌套,例如：</p>\n<pre><code>nav{\n    a{\n        color:red;\n        margin:{\n            left:10px;\n            top:100px;\n        }\n        &amp;:hover\n        {\n            color:yellow;\n        }\n        &amp;:visited\n        {\n            color:black;\n        }\n    header &amp;{\n        color:green;\n    }\n    }\n}\n</code></pre><p>编译出来就是：</p>\n<pre><code>nav a {\ncolor: red;\nmargin-left: 10px;\nmargin-top: 100px; \n}\n\nnav a:hover {\ncolor: yellow; \n}\n\nnav a:visited {\ncolor: black; \n}\n\nheader nav a {\ncolor: green; \n}\n</code></pre><h3 id=\"混合宏\"><a href=\"#混合宏\" class=\"headerlink\" title=\"混合宏\"></a>混合宏</h3><p>  混合宏是用来处理重复的样式，就像js中的有名函数一样，只要声明了，就可以无数次调用  </p>\n<p>  声明：</p>\n<pre><code>@mixin name{\n      transform: scale(2);\n      -webkit-transform: scale(2);\n      -moz-transform:scale(2);\n      -o-transform: scale(2);\n      -ms-transform: scale(2);\n}\n</code></pre><p>  调用：</p>\n<pre><code>img{\n  @include name;\n}\n</code></pre><p>编译出来就是：</p>\n<pre><code>img\n{\n    transform: scale(2);\n    -webkit-transform: scale(2);\n    -moz-transform:scale(2);\n    -o-transform: scale(2);\n    -ms-transform: scale(2);\n}\n</code></pre><p>当然，混合宏也可以传参数：</p>\n<pre><code> @mixin name($scale){\n    transform:$scale;\n    -webkit-transform:$scale;\n    -moz-transform:$scale;\n    -o-transform:$scale;\n    -ms-transform:$scale;\n}\nimg{\n    @include name(scale(2));\n}\n</code></pre><p>编译出来就是：</p>\n<pre><code>img {\ntransform: scale(2);\n-webkit-transform: scale(2);\n-moz-transform: scale(2);\n-o-transform: scale(2);\n-ms-transform: scale(2); \n}\n</code></pre><p>这样，只要调用这个混合宏就不用像css那样写一堆兼容代码了，确实方便不少  </p>\n<p>当然，混合宏也可以传多个参数，当参数过多时，可以用<code>...</code>代替，例如：</p>\n<pre><code>@mixin box-shadow($shadows...){\n@if length($shadows) &gt;= 1 {\n    -webkit-box-shadow: $shadows;\n    box-shadow: $shadows;\n} @else {\n    $shadows: 0 0 2px rgba(#000,.25);\n    -webkit-box-shadow: $shadow;\n    box-shadow: $shadow;\n        }\n}\n\n.box {\n    @include box-shadow(0 0 1px rgba(#000,.5));\n}\n</code></pre><p>编译出来就是：</p>\n<pre><code>.box {\n-webkit-box-shadow: 0 0 1px rgba(0, 0, 0, 0.5);\nbox-shadow: 0 0 1px rgba(0, 0, 0, 0.5); \n}\n</code></pre><h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>在css中有继承样式(子元素可以继承父元素的某些样式，例如font-family可以给子元素继承),在sass中可以使用<code>@extend</code>实现样式继承：</p>\n<pre><code>.btn {\n border: 1px solid #ccc;\npadding: 6px 10px;\nfont-size: 14px;\n}\n\n.btn-primary {\nbackground-color: #f36;\ncolor: #fff;\n@extend .btn;\n}\n</code></pre><p>编译出来就是：</p>\n<pre><code>.btn,.btn-primary {\n\nborder: 1px solid #ccc;\n\npadding: 6px 10px;\n\nfont-size: 14px; \n}\n\n.btn-primary {\n\nbackground-color: #f36;\n\ncolor: #fff; \n}\n</code></pre><p>这样又减少了我们写重复的代码了！  </p>\n<h3 id=\"占位符\"><a href=\"#占位符\" class=\"headerlink\" title=\"占位符%\"></a>占位符%</h3><p>Sass 中的占位符 <code>%</code> 功能是一个很强大，很实用的一个功能，因为 <code>%</code> 声明的代码，如果不被 <code>@extend</code> 调用的话，不会产生任何代码：</p>\n<pre><code>%mt5 {\nmargin-top: 5px;\n}\n%pt5{\npadding-top: 5px;\n}\n.btn\n{\n    @extend %mt5;\n}\n</code></pre><p>编译出来就是：</p>\n<pre><code>.btn {\nmargin-top: 5px; \n}\n</code></pre><h3 id=\"插值\"><a href=\"#插值\" class=\"headerlink\" title=\"插值#{}\"></a>插值<code>#{}</code></h3><p>使用 CSS 预处理器语言的一个主要原因是想使用 Sass 获得一个更好的结构体系。比如说你想写更干净的、高效的和面向对象的 CSS。Sass 中的插值就是重要的一部分，例如，最开始的那个混合宏还可以变为：</p>\n<pre><code>@mixin name($transform,$scale){\n-webkit-#{$transform}:$scale;\n-moz-#{$transform}:$scale;\n-o-#{$transform}:$scale;\n-ms-#{$transform}:$scale;\n#{$transform}:$scale;\n}\nimg{\n    @include name(transform,scale(2));\n}\n</code></pre><p>编译出来就是：</p>\n<pre><code>img {\n-webkit-transform: scale(2);\n-moz-transform: scale(2);\n-o-transform: scale(2);\n-ms-transform: scale(2);\ntransform: scale(2); \n}\n</code></pre><p>这样上面这个名为<em>name</em>的混合宏就可以变为更灵活，可以帮我们写各种css的兼容前缀。  </p>\n<h3 id=\"运算\"><a href=\"#运算\" class=\"headerlink\" title=\"运算\"></a>运算</h3><p>在css中只有calc()函数可以进行数字运算。然而，在sass中可以直接使用算术运算符来对数据进行运算：</p>\n<pre><code>.box {\nwidth: 20px + 8in;//1in=96px\nheight: 8in - 20px;//当对变量进行运算时-前面需要有空格\nfont-size: 10px * 2;\nbackground-position:(100px/2);\n}\n</code></pre><p>编译出来就是：</p>\n<pre><code>.box {\nwidth: 788px;\nheight: 748px;\nfont-size: 20px;\nbackground-position:50px;\n}\n</code></pre><p>但对于不同单位进行计算时，会报错，例如：</p>\n<pre><code>.box {\nwidth: 20px + 1em;\n}\n</code></pre><p>编译时会报错：<code>Incompatible units: &#39;em&#39; and &#39;px&#39;.</code></p>\n<h3 id=\"颜色运算\"><a href=\"#颜色运算\" class=\"headerlink\" title=\"颜色运算\"></a>颜色运算</h3><p>所有算数运算都支持颜色值，并且是分段运算的。也就是说，红、绿和蓝各颜色分段单独进行运算。如：</p>\n<pre><code>p {\ncolor: #010203 + #040506;\n}\n</code></pre><p>计算公式为 01 + 04 = 05、02 + 05 = 07 和 03 + 06 = 09   </p>\n<p>编译出来就是：</p>\n<pre><code>p {\ncolor: #050709;\n}\n</code></pre><p>如果<code>#ffffff</code>再加的话编译出来就是<code>white</code>，同理<code>#000000</code>再减的话就是<code>black</code>  </p>\n<p><code>#000000</code>不论乘什么除什么编译出来都是<code>black</code>，<code>#ffffff</code>不论乘什么编译出来都是<code>white</code></p>\n<h3 id=\"字符运算\"><a href=\"#字符运算\" class=\"headerlink\" title=\"字符运算\"></a>字符运算</h3><p>在 Sass 中可以通过加法符号<code>+</code>来对字符串进行连接。例如：</p>\n<pre><code>$content: &quot;Hello&quot; + &quot;&quot; + &quot;Sass!&quot;;\n.box:before {\ncontent: &quot; #{$content} &quot;;\n}\n</code></pre><p>编译出来就是：</p>\n<pre><code>.box:before {\ncontent: &quot; Hello Sass! &quot;;\n}\n</code></pre><p>注意，如果有引号的字符串被添加了一个没有引号的字符串 （也就是，带引号的字符串在 + 符号左侧）， 结果会是一个有引号的字符串。 同样的，如果一个没有引号的字符串被添加了一个有引号的字符串 （没有引号的字符串在 + 符号左侧）， 结果将是一个没有引号的字符串。 例如：</p>\n<pre><code>p:before {\ncontent: &quot;Foo &quot; + Bar;\nfont-family: sans- + &quot;serif&quot;;\n}\n</code></pre><p>编译出来就是：</p>\n<pre><code>p:before {\ncontent: &quot;Foo Bar&quot;;\nfont-family: sans-serif; \n}\n</code></pre><p>至此sass基础第一篇文章就写完了，有什么意见的在下面留言吧。</p>"},{"title":"hexo+github快速搭建个人博客","date":"2016-07-31T01:31:24.000Z","_content":"# 开场白\n\n\n昨天用*hexo*搭建了自己的一个个人博客，费了不少劲，网上的资料有的不全，有的是太老了现在用不了，废话不多说了，直奔主题吧。\n\n<!-- more-->\n\n## 正文\n\n\n因为*hexo*是基于*node*的所以安装的时候非常方便\n\n\n## 准备工作\n\n\n 首先，我们来到[node官网](https://nodejs.org/en/)下载node(建议下载稳定版的)安装包，下载完后运行安装程序，然后一直点下一步就行了(安装的时候建议使用默认路径)。  \n \n 然后，打开*cmd*或者*git bash*输入：\n \n \n     node -v\n     \n \n 如果出现版本号说明安装成功。  \n \n 接着，使用*node*自带的包管理工具*npm*安装*hexo*：\n \n \n     输入npm install -g hexo(或者npm i -g hexo)\n     \n     \n 安装全局的*hexo*  \n \n 上面的工作做完后来到[github官网](https://github.com/)，没注册的先注册。然后点击**New repository**新建一个项目，名字为：`yourname.github.io` **注意：一个账号只能有一个yourname.github.io，如果有了就随便新建一个项目**。  \n \n 新建完后，将仓库用\n \n \n     git clone\n \n \n 命令克隆到本地，然后进入到本地仓库，在这里打开命令行工具(也就是cmd或者git bash。**注意，路径是当前文件夹路径**)输入\n \n \n     hexo init\n \n \n 等一段时间后程序会帮你安装好*hexo*所需要的依赖。  \n \n 安装完后，在命令行工具输入\n \n \n     hexo generate(或者 hexo g)\n     \n\n等待一段时间后，输入\n\n\n    hexo server(或者hexo s)\n    \n    \n然后进入[localhost:4000](http://localhost:4000/)查看是否出现hexo的界面(有的人可能会发现样式没加载出来，不急，先往下看)   \n\n如果出现界面的话，至此，所有准备工作基本完成，你离成功不远了！\n\n\n## 全局配置\n\n\n首先，得找到根目录的`_config.yml`文件，打开以后，把最上面的`Site`的博客基本信息填写完毕。  \n\n**特别注意**：在冒号后面有空格，这个空格不能少  \n\n然后来到下面的`URL`填写你博客的网址，例如我的：\n\n\n    https:JayZangwill.github.io/blog\n    \n \n\n然后看到下面的这个`root`填写的是`io`后面的内容，我的是`/blog`(如果没有，那就是`/`**特别注意**：`root`后面不能为空)，之前说的样式没有加载很有可能是这个原因(如果还没加载出来，不急，再往下看)  \n\n完之后，看到`_config.yml`文件的最下面，找到`deploy:`，另起一行输入：\n\n\n    type: git\n    repository: 你项目的ssh\n    branch: gh-pages(如果博客地址是yourname.github.io，分支名就是master)\n\n\n至此，全局配置就完成了。这个时候，你需要再在命令行工具输入：\n\n\n    hexo generate(或者 hexo g)\n    hexo server(或者hexo s)\n\n\n如果标题变为你`_config.yml`文件最上面`title`输入的东西，那么文件就更新成功了！   \n\n## 上传到*github*\n\n在上传到github之前还需要安装一个东西，在命令行输入：\n\n\n    npm install hexo-deployer-git --save\n    \n这样才能上传到*github*上，不然上传的话会报错  \n\n之后在命令行工具输入：\n\n\n    hexo deploy(或者hexo d)\n\n\n即可上传到*github*上。   \n\n传到*github*上以后那些样式和图片肯定都能加载上去了，如果还不能加载的在浏览器里按f12点击*network*选项卡看看路径怎么错了之后再调调根目录的`_config.yml`文件里的`root`吧！  \n\n\n## 改变主题\n\n\n我在改变主题这里花了蛮多的时间，一是因为没有找到符合胃口的主题，还有就是在主题更新这里走了很大弯路。直奔主题吧，伤心的会议不要再提！  \n\n首先，我用的是[jacman](http://jacman.wuchong.me/2014/11/20/how-to-use-jacman)主题，界面还算看得过去。过几天有时间了在自己写个主题。给的网址上面说得很清楚主题是如何安装和配置的，我就不在赘述。  \n\n我想说的是，上面说的更新：\n\n\n    cd themes/jacman\n    git pull origin master\n    \n    \n是主题的源文件更新，不是我们博客的更新，我们博客更新是：\n\n\n\n    hexo g\n\n\n我在这就转了很大弯。。。我们在配置完主题的`_config.yml`文件后到根目录的命令行输入上面的命令更新博客后上传到*github*上就行了。  \n\n**注意**：如果上传到*github*上有些链接点不开或者有些图片出不来，需要到本地仓库的public文件夹里的*index.html*或者*css*文件夹里的*style.css*里讲一些链接还有图片的链接进行微调,然后再更新上传即可\n\n\n## 增加tags\n\n\n当文章多了以后，我们需要一个标签来标记，想要增加标签，首先得安装一个东西：  \n\n\n    npm i hexo-generator-tag --save\n\n\n安装完后输入：  \n\n\n    hexo new page \"tags\"   \n\n\n然后会发现source里多出个tags的文件夹，这个文件夹里有个md文件，点开，在第二条横线下加个  \n\n\n    type: \"tags\"\n\n\n保存就好了。之后在根目录的命令行输入：  \n\n\n    hexo new \"文件名\"  \n\n\n你会发现在文章开头有个`tags: `，在后面填上标签即可。  \n\n同理，新建分类也是一样的把`tags`换成`categories`就行了  \n\n## 添加rss订阅\n\n\n要想添加订阅功能首先得安装一个东西：\n\n\n    npm install hexo-generator-feed\n\n\n安装完以后再输入：\n\n\n    hexo g\n    \n之后，你会发现在public里多了一个`atom.xml`文件，那就证明*rss*订阅功能已经添加了。  \n\n\n至此，一个hexo博客就基本搭建完成了，如有疑问直接在下面留言，我有时间就会回复的。","source":"_posts/Hexo+github quickly build personal blog.md","raw":"---\ntitle: hexo+github快速搭建个人博客\ndate: 2016-07-31 09:31:24\ntags: hexo\n---\n# 开场白\n\n\n昨天用*hexo*搭建了自己的一个个人博客，费了不少劲，网上的资料有的不全，有的是太老了现在用不了，废话不多说了，直奔主题吧。\n\n<!-- more-->\n\n## 正文\n\n\n因为*hexo*是基于*node*的所以安装的时候非常方便\n\n\n## 准备工作\n\n\n 首先，我们来到[node官网](https://nodejs.org/en/)下载node(建议下载稳定版的)安装包，下载完后运行安装程序，然后一直点下一步就行了(安装的时候建议使用默认路径)。  \n \n 然后，打开*cmd*或者*git bash*输入：\n \n \n     node -v\n     \n \n 如果出现版本号说明安装成功。  \n \n 接着，使用*node*自带的包管理工具*npm*安装*hexo*：\n \n \n     输入npm install -g hexo(或者npm i -g hexo)\n     \n     \n 安装全局的*hexo*  \n \n 上面的工作做完后来到[github官网](https://github.com/)，没注册的先注册。然后点击**New repository**新建一个项目，名字为：`yourname.github.io` **注意：一个账号只能有一个yourname.github.io，如果有了就随便新建一个项目**。  \n \n 新建完后，将仓库用\n \n \n     git clone\n \n \n 命令克隆到本地，然后进入到本地仓库，在这里打开命令行工具(也就是cmd或者git bash。**注意，路径是当前文件夹路径**)输入\n \n \n     hexo init\n \n \n 等一段时间后程序会帮你安装好*hexo*所需要的依赖。  \n \n 安装完后，在命令行工具输入\n \n \n     hexo generate(或者 hexo g)\n     \n\n等待一段时间后，输入\n\n\n    hexo server(或者hexo s)\n    \n    \n然后进入[localhost:4000](http://localhost:4000/)查看是否出现hexo的界面(有的人可能会发现样式没加载出来，不急，先往下看)   \n\n如果出现界面的话，至此，所有准备工作基本完成，你离成功不远了！\n\n\n## 全局配置\n\n\n首先，得找到根目录的`_config.yml`文件，打开以后，把最上面的`Site`的博客基本信息填写完毕。  \n\n**特别注意**：在冒号后面有空格，这个空格不能少  \n\n然后来到下面的`URL`填写你博客的网址，例如我的：\n\n\n    https:JayZangwill.github.io/blog\n    \n \n\n然后看到下面的这个`root`填写的是`io`后面的内容，我的是`/blog`(如果没有，那就是`/`**特别注意**：`root`后面不能为空)，之前说的样式没有加载很有可能是这个原因(如果还没加载出来，不急，再往下看)  \n\n完之后，看到`_config.yml`文件的最下面，找到`deploy:`，另起一行输入：\n\n\n    type: git\n    repository: 你项目的ssh\n    branch: gh-pages(如果博客地址是yourname.github.io，分支名就是master)\n\n\n至此，全局配置就完成了。这个时候，你需要再在命令行工具输入：\n\n\n    hexo generate(或者 hexo g)\n    hexo server(或者hexo s)\n\n\n如果标题变为你`_config.yml`文件最上面`title`输入的东西，那么文件就更新成功了！   \n\n## 上传到*github*\n\n在上传到github之前还需要安装一个东西，在命令行输入：\n\n\n    npm install hexo-deployer-git --save\n    \n这样才能上传到*github*上，不然上传的话会报错  \n\n之后在命令行工具输入：\n\n\n    hexo deploy(或者hexo d)\n\n\n即可上传到*github*上。   \n\n传到*github*上以后那些样式和图片肯定都能加载上去了，如果还不能加载的在浏览器里按f12点击*network*选项卡看看路径怎么错了之后再调调根目录的`_config.yml`文件里的`root`吧！  \n\n\n## 改变主题\n\n\n我在改变主题这里花了蛮多的时间，一是因为没有找到符合胃口的主题，还有就是在主题更新这里走了很大弯路。直奔主题吧，伤心的会议不要再提！  \n\n首先，我用的是[jacman](http://jacman.wuchong.me/2014/11/20/how-to-use-jacman)主题，界面还算看得过去。过几天有时间了在自己写个主题。给的网址上面说得很清楚主题是如何安装和配置的，我就不在赘述。  \n\n我想说的是，上面说的更新：\n\n\n    cd themes/jacman\n    git pull origin master\n    \n    \n是主题的源文件更新，不是我们博客的更新，我们博客更新是：\n\n\n\n    hexo g\n\n\n我在这就转了很大弯。。。我们在配置完主题的`_config.yml`文件后到根目录的命令行输入上面的命令更新博客后上传到*github*上就行了。  \n\n**注意**：如果上传到*github*上有些链接点不开或者有些图片出不来，需要到本地仓库的public文件夹里的*index.html*或者*css*文件夹里的*style.css*里讲一些链接还有图片的链接进行微调,然后再更新上传即可\n\n\n## 增加tags\n\n\n当文章多了以后，我们需要一个标签来标记，想要增加标签，首先得安装一个东西：  \n\n\n    npm i hexo-generator-tag --save\n\n\n安装完后输入：  \n\n\n    hexo new page \"tags\"   \n\n\n然后会发现source里多出个tags的文件夹，这个文件夹里有个md文件，点开，在第二条横线下加个  \n\n\n    type: \"tags\"\n\n\n保存就好了。之后在根目录的命令行输入：  \n\n\n    hexo new \"文件名\"  \n\n\n你会发现在文章开头有个`tags: `，在后面填上标签即可。  \n\n同理，新建分类也是一样的把`tags`换成`categories`就行了  \n\n## 添加rss订阅\n\n\n要想添加订阅功能首先得安装一个东西：\n\n\n    npm install hexo-generator-feed\n\n\n安装完以后再输入：\n\n\n    hexo g\n    \n之后，你会发现在public里多了一个`atom.xml`文件，那就证明*rss*订阅功能已经添加了。  \n\n\n至此，一个hexo博客就基本搭建完成了，如有疑问直接在下面留言，我有时间就会回复的。","slug":"Hexo+github quickly build personal blog","published":1,"updated":"2020-04-07T03:29:17.929Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8qzc33v00032cl6wglj4ewi","content":"<h1 id=\"开场白\"><a href=\"#开场白\" class=\"headerlink\" title=\"开场白\"></a>开场白</h1><p>昨天用<em>hexo</em>搭建了自己的一个个人博客，费了不少劲，网上的资料有的不全，有的是太老了现在用不了，废话不多说了，直奔主题吧。</p>\n<a id=\"more\"></a>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>因为<em>hexo</em>是基于<em>node</em>的所以安装的时候非常方便</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p> 首先，我们来到<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">node官网</a>下载node(建议下载稳定版的)安装包，下载完后运行安装程序，然后一直点下一步就行了(安装的时候建议使用默认路径)。  </p>\n<p> 然后，打开<em>cmd</em>或者<em>git bash</em>输入：</p>\n<pre><code>node -v\n</code></pre><p> 如果出现版本号说明安装成功。  </p>\n<p> 接着，使用<em>node</em>自带的包管理工具<em>npm</em>安装<em>hexo</em>：</p>\n<pre><code>输入npm install -g hexo(或者npm i -g hexo)\n</code></pre><p> 安装全局的<em>hexo</em>  </p>\n<p> 上面的工作做完后来到<a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">github官网</a>，没注册的先注册。然后点击<strong>New repository</strong>新建一个项目，名字为：<code>yourname.github.io</code> <strong>注意：一个账号只能有一个yourname.github.io，如果有了就随便新建一个项目</strong>。  </p>\n<p> 新建完后，将仓库用</p>\n<pre><code>git clone\n</code></pre><p> 命令克隆到本地，然后进入到本地仓库，在这里打开命令行工具(也就是cmd或者git bash。<strong>注意，路径是当前文件夹路径</strong>)输入</p>\n<pre><code>hexo init\n</code></pre><p> 等一段时间后程序会帮你安装好<em>hexo</em>所需要的依赖。  </p>\n<p> 安装完后，在命令行工具输入</p>\n<pre><code>hexo generate(或者 hexo g)\n</code></pre><p>等待一段时间后，输入</p>\n<pre><code>hexo server(或者hexo s)\n</code></pre><p>然后进入<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">localhost:4000</a>查看是否出现hexo的界面(有的人可能会发现样式没加载出来，不急，先往下看)   </p>\n<p>如果出现界面的话，至此，所有准备工作基本完成，你离成功不远了！</p>\n<h2 id=\"全局配置\"><a href=\"#全局配置\" class=\"headerlink\" title=\"全局配置\"></a>全局配置</h2><p>首先，得找到根目录的<code>_config.yml</code>文件，打开以后，把最上面的<code>Site</code>的博客基本信息填写完毕。  </p>\n<p><strong>特别注意</strong>：在冒号后面有空格，这个空格不能少  </p>\n<p>然后来到下面的<code>URL</code>填写你博客的网址，例如我的：</p>\n<pre><code>https:JayZangwill.github.io/blog\n</code></pre><p>然后看到下面的这个<code>root</code>填写的是<code>io</code>后面的内容，我的是<code>/blog</code>(如果没有，那就是<code>/</code><strong>特别注意</strong>：<code>root</code>后面不能为空)，之前说的样式没有加载很有可能是这个原因(如果还没加载出来，不急，再往下看)  </p>\n<p>完之后，看到<code>_config.yml</code>文件的最下面，找到<code>deploy:</code>，另起一行输入：</p>\n<pre><code>type: git\nrepository: 你项目的ssh\nbranch: gh-pages(如果博客地址是yourname.github.io，分支名就是master)\n</code></pre><p>至此，全局配置就完成了。这个时候，你需要再在命令行工具输入：</p>\n<pre><code>hexo generate(或者 hexo g)\nhexo server(或者hexo s)\n</code></pre><p>如果标题变为你<code>_config.yml</code>文件最上面<code>title</code>输入的东西，那么文件就更新成功了！   </p>\n<h2 id=\"上传到github\"><a href=\"#上传到github\" class=\"headerlink\" title=\"上传到github\"></a>上传到<em>github</em></h2><p>在上传到github之前还需要安装一个东西，在命令行输入：</p>\n<pre><code>npm install hexo-deployer-git --save\n</code></pre><p>这样才能上传到<em>github</em>上，不然上传的话会报错  </p>\n<p>之后在命令行工具输入：</p>\n<pre><code>hexo deploy(或者hexo d)\n</code></pre><p>即可上传到<em>github</em>上。   </p>\n<p>传到<em>github</em>上以后那些样式和图片肯定都能加载上去了，如果还不能加载的在浏览器里按f12点击<em>network</em>选项卡看看路径怎么错了之后再调调根目录的<code>_config.yml</code>文件里的<code>root</code>吧！  </p>\n<h2 id=\"改变主题\"><a href=\"#改变主题\" class=\"headerlink\" title=\"改变主题\"></a>改变主题</h2><p>我在改变主题这里花了蛮多的时间，一是因为没有找到符合胃口的主题，还有就是在主题更新这里走了很大弯路。直奔主题吧，伤心的会议不要再提！  </p>\n<p>首先，我用的是<a href=\"http://jacman.wuchong.me/2014/11/20/how-to-use-jacman\" target=\"_blank\" rel=\"noopener\">jacman</a>主题，界面还算看得过去。过几天有时间了在自己写个主题。给的网址上面说得很清楚主题是如何安装和配置的，我就不在赘述。  </p>\n<p>我想说的是，上面说的更新：</p>\n<pre><code>cd themes/jacman\ngit pull origin master\n</code></pre><p>是主题的源文件更新，不是我们博客的更新，我们博客更新是：</p>\n<pre><code>hexo g\n</code></pre><p>我在这就转了很大弯。。。我们在配置完主题的<code>_config.yml</code>文件后到根目录的命令行输入上面的命令更新博客后上传到<em>github</em>上就行了。  </p>\n<p><strong>注意</strong>：如果上传到<em>github</em>上有些链接点不开或者有些图片出不来，需要到本地仓库的public文件夹里的<em>index.html</em>或者<em>css</em>文件夹里的<em>style.css</em>里讲一些链接还有图片的链接进行微调,然后再更新上传即可</p>\n<h2 id=\"增加tags\"><a href=\"#增加tags\" class=\"headerlink\" title=\"增加tags\"></a>增加tags</h2><p>当文章多了以后，我们需要一个标签来标记，想要增加标签，首先得安装一个东西：  </p>\n<pre><code>npm i hexo-generator-tag --save\n</code></pre><p>安装完后输入：  </p>\n<pre><code>hexo new page &quot;tags&quot;   \n</code></pre><p>然后会发现source里多出个tags的文件夹，这个文件夹里有个md文件，点开，在第二条横线下加个  </p>\n<pre><code>type: &quot;tags&quot;\n</code></pre><p>保存就好了。之后在根目录的命令行输入：  </p>\n<pre><code>hexo new &quot;文件名&quot;  \n</code></pre><p>你会发现在文章开头有个<code>tags:</code>，在后面填上标签即可。  </p>\n<p>同理，新建分类也是一样的把<code>tags</code>换成<code>categories</code>就行了  </p>\n<h2 id=\"添加rss订阅\"><a href=\"#添加rss订阅\" class=\"headerlink\" title=\"添加rss订阅\"></a>添加rss订阅</h2><p>要想添加订阅功能首先得安装一个东西：</p>\n<pre><code>npm install hexo-generator-feed\n</code></pre><p>安装完以后再输入：</p>\n<pre><code>hexo g\n</code></pre><p>之后，你会发现在public里多了一个<code>atom.xml</code>文件，那就证明<em>rss</em>订阅功能已经添加了。  </p>\n<p>至此，一个hexo博客就基本搭建完成了，如有疑问直接在下面留言，我有时间就会回复的。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"开场白\"><a href=\"#开场白\" class=\"headerlink\" title=\"开场白\"></a>开场白</h1><p>昨天用<em>hexo</em>搭建了自己的一个个人博客，费了不少劲，网上的资料有的不全，有的是太老了现在用不了，废话不多说了，直奔主题吧。</p>","more":"<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>因为<em>hexo</em>是基于<em>node</em>的所以安装的时候非常方便</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p> 首先，我们来到<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">node官网</a>下载node(建议下载稳定版的)安装包，下载完后运行安装程序，然后一直点下一步就行了(安装的时候建议使用默认路径)。  </p>\n<p> 然后，打开<em>cmd</em>或者<em>git bash</em>输入：</p>\n<pre><code>node -v\n</code></pre><p> 如果出现版本号说明安装成功。  </p>\n<p> 接着，使用<em>node</em>自带的包管理工具<em>npm</em>安装<em>hexo</em>：</p>\n<pre><code>输入npm install -g hexo(或者npm i -g hexo)\n</code></pre><p> 安装全局的<em>hexo</em>  </p>\n<p> 上面的工作做完后来到<a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">github官网</a>，没注册的先注册。然后点击<strong>New repository</strong>新建一个项目，名字为：<code>yourname.github.io</code> <strong>注意：一个账号只能有一个yourname.github.io，如果有了就随便新建一个项目</strong>。  </p>\n<p> 新建完后，将仓库用</p>\n<pre><code>git clone\n</code></pre><p> 命令克隆到本地，然后进入到本地仓库，在这里打开命令行工具(也就是cmd或者git bash。<strong>注意，路径是当前文件夹路径</strong>)输入</p>\n<pre><code>hexo init\n</code></pre><p> 等一段时间后程序会帮你安装好<em>hexo</em>所需要的依赖。  </p>\n<p> 安装完后，在命令行工具输入</p>\n<pre><code>hexo generate(或者 hexo g)\n</code></pre><p>等待一段时间后，输入</p>\n<pre><code>hexo server(或者hexo s)\n</code></pre><p>然后进入<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">localhost:4000</a>查看是否出现hexo的界面(有的人可能会发现样式没加载出来，不急，先往下看)   </p>\n<p>如果出现界面的话，至此，所有准备工作基本完成，你离成功不远了！</p>\n<h2 id=\"全局配置\"><a href=\"#全局配置\" class=\"headerlink\" title=\"全局配置\"></a>全局配置</h2><p>首先，得找到根目录的<code>_config.yml</code>文件，打开以后，把最上面的<code>Site</code>的博客基本信息填写完毕。  </p>\n<p><strong>特别注意</strong>：在冒号后面有空格，这个空格不能少  </p>\n<p>然后来到下面的<code>URL</code>填写你博客的网址，例如我的：</p>\n<pre><code>https:JayZangwill.github.io/blog\n</code></pre><p>然后看到下面的这个<code>root</code>填写的是<code>io</code>后面的内容，我的是<code>/blog</code>(如果没有，那就是<code>/</code><strong>特别注意</strong>：<code>root</code>后面不能为空)，之前说的样式没有加载很有可能是这个原因(如果还没加载出来，不急，再往下看)  </p>\n<p>完之后，看到<code>_config.yml</code>文件的最下面，找到<code>deploy:</code>，另起一行输入：</p>\n<pre><code>type: git\nrepository: 你项目的ssh\nbranch: gh-pages(如果博客地址是yourname.github.io，分支名就是master)\n</code></pre><p>至此，全局配置就完成了。这个时候，你需要再在命令行工具输入：</p>\n<pre><code>hexo generate(或者 hexo g)\nhexo server(或者hexo s)\n</code></pre><p>如果标题变为你<code>_config.yml</code>文件最上面<code>title</code>输入的东西，那么文件就更新成功了！   </p>\n<h2 id=\"上传到github\"><a href=\"#上传到github\" class=\"headerlink\" title=\"上传到github\"></a>上传到<em>github</em></h2><p>在上传到github之前还需要安装一个东西，在命令行输入：</p>\n<pre><code>npm install hexo-deployer-git --save\n</code></pre><p>这样才能上传到<em>github</em>上，不然上传的话会报错  </p>\n<p>之后在命令行工具输入：</p>\n<pre><code>hexo deploy(或者hexo d)\n</code></pre><p>即可上传到<em>github</em>上。   </p>\n<p>传到<em>github</em>上以后那些样式和图片肯定都能加载上去了，如果还不能加载的在浏览器里按f12点击<em>network</em>选项卡看看路径怎么错了之后再调调根目录的<code>_config.yml</code>文件里的<code>root</code>吧！  </p>\n<h2 id=\"改变主题\"><a href=\"#改变主题\" class=\"headerlink\" title=\"改变主题\"></a>改变主题</h2><p>我在改变主题这里花了蛮多的时间，一是因为没有找到符合胃口的主题，还有就是在主题更新这里走了很大弯路。直奔主题吧，伤心的会议不要再提！  </p>\n<p>首先，我用的是<a href=\"http://jacman.wuchong.me/2014/11/20/how-to-use-jacman\" target=\"_blank\" rel=\"noopener\">jacman</a>主题，界面还算看得过去。过几天有时间了在自己写个主题。给的网址上面说得很清楚主题是如何安装和配置的，我就不在赘述。  </p>\n<p>我想说的是，上面说的更新：</p>\n<pre><code>cd themes/jacman\ngit pull origin master\n</code></pre><p>是主题的源文件更新，不是我们博客的更新，我们博客更新是：</p>\n<pre><code>hexo g\n</code></pre><p>我在这就转了很大弯。。。我们在配置完主题的<code>_config.yml</code>文件后到根目录的命令行输入上面的命令更新博客后上传到<em>github</em>上就行了。  </p>\n<p><strong>注意</strong>：如果上传到<em>github</em>上有些链接点不开或者有些图片出不来，需要到本地仓库的public文件夹里的<em>index.html</em>或者<em>css</em>文件夹里的<em>style.css</em>里讲一些链接还有图片的链接进行微调,然后再更新上传即可</p>\n<h2 id=\"增加tags\"><a href=\"#增加tags\" class=\"headerlink\" title=\"增加tags\"></a>增加tags</h2><p>当文章多了以后，我们需要一个标签来标记，想要增加标签，首先得安装一个东西：  </p>\n<pre><code>npm i hexo-generator-tag --save\n</code></pre><p>安装完后输入：  </p>\n<pre><code>hexo new page &quot;tags&quot;   \n</code></pre><p>然后会发现source里多出个tags的文件夹，这个文件夹里有个md文件，点开，在第二条横线下加个  </p>\n<pre><code>type: &quot;tags&quot;\n</code></pre><p>保存就好了。之后在根目录的命令行输入：  </p>\n<pre><code>hexo new &quot;文件名&quot;  \n</code></pre><p>你会发现在文章开头有个<code>tags:</code>，在后面填上标签即可。  </p>\n<p>同理，新建分类也是一样的把<code>tags</code>换成<code>categories</code>就行了  </p>\n<h2 id=\"添加rss订阅\"><a href=\"#添加rss订阅\" class=\"headerlink\" title=\"添加rss订阅\"></a>添加rss订阅</h2><p>要想添加订阅功能首先得安装一个东西：</p>\n<pre><code>npm install hexo-generator-feed\n</code></pre><p>安装完以后再输入：</p>\n<pre><code>hexo g\n</code></pre><p>之后，你会发现在public里多了一个<code>atom.xml</code>文件，那就证明<em>rss</em>订阅功能已经添加了。  </p>\n<p>至此，一个hexo博客就基本搭建完成了，如有疑问直接在下面留言，我有时间就会回复的。</p>"},{"title":"几个让我印象深刻的面试题(一)","date":"2017-03-01T08:35:41.000Z","_content":"\n## 前言\n\n[原文地址](https://jayzangwill.github.io/blog/2017/03/01/Some%20of%20the%20interview%20questions%20that%20impressed%20me/)&&[我的博客](https://jayzangwill.github.io/blog/)\n[知乎](https://zhuanlan.zhihu.com/p/25514220)&&[知乎专栏](https://zhuanlan.zhihu.com/jayzangwill)\n[河南前端交流群官网](http://henanjs.org/)\n\n时间不知不觉已经来到了大三的下学期，各大企业的春招也陆续的开始，自己也开始做些面试题，一来了解了解面试题一般会问什么，二来通过面试题可以发现自己还有哪方面不足赶紧弥补，以备战今年的春招。\n通过最近的学习，我总结了一下一些我遇到的让我印象深刻的一些面试题，大家可以先看看题目自己想想答案，然后再看我的答案(**我的答案经供参考，如有更好的想法欢迎在下面评论区提出自己的意见**)。\n\n<!-- more-->\n\n## 正文\n\n1.  给一个div设置它的宽度为`100px`，然后再设置它的`padding-top`为`20%`。问：现在这个div有多高？\n2.  如下代码：\n\n\n\tfunction fn1(){\n\t\tfor(var i=0;i<4;i++){\n\t\t\tvar tc=setTimeout(function(i){\n\t\t\t\tconsole.log(i);\n\t\t\t\tclearTimeout(tc)\n\t\t\t},10,i);\n\t\t}\n\t}\n\tfunction fn2(){\n\t\tfor(var i=0;i<4;i++){\n\t\t\tvar tc=setInterval(function(i,tc){\n\t\t\t\tconsole.log(i);\n\t\t\t\tclearInterval(tc)\n\t\t\t},10,i,tc);\n\t\t}\n\t}\n\tfn1();\n\tfn2();\n\n请问分别会输出什么？\n\n3.  如下代码：\n\n\n\tvar fn=function(a,b,c){\n\t\treturn a+b+c;\n\t}\n\n需要写一个函数，满足`curry(fn)(1)(2)(3) //6`\n\n4.  使用原生JS实现：`(10).add(10).reduce(2).add(10) //28`，意思是10加上10减去2加上10等于28。\n\n你可以自己思考答案后在参考我给的参考答案。\n\n## 答案揭晓\n\n### 第一个问题\n\n这题主要考察了对**w3c**标准的了解。如果你亲自去浏览器去试的话会发现这个`div`的高为：`316.8`(**注意**：不同分辨率的电脑测试会有不同的效果，这里以我的电脑1600x900为参考)，其实到这里这题已经是解开了，但是可能还有些同学没明白这个`316.8`是如何计算得来的。别急，请听我细细道来。\n![div的高](/blog/img/face/padding-top.png)\n如果你搞不懂结果为何是这个的话可能会去查[w3school](http://www.w3school.com.cn/cssref/pr_padding.asp)，你可能会看到：\n![w3school上的介绍](/blog/img/face/w3c.png)\n但是可以这么说上面的所说的是错的，或者说，表述不准确。\n例如一下情况：\n\n\t//css\n\t.inner{\n\t\t\tposition: absolute;\n\t\t\twidth: 100px;\n\t\t\tpadding-top: 20%;\n\t}\n\t.mid{\n\t\twidth: 200px;\n\t}\n\t.wrap{\n\t\tposition: relative;\n\t\twidth: 300px;\n\t}\n\t//html\n\t<div class=\"wrap\">\n\t\t<div class=\"mid\">\n\t\t\t<div class=\"inner\"></div>\n\t\t</div>\n\t</div>\n\t\n![加了定位后div的高](/blog/img/face/absolute-padding.png)\n如果按照[w3school](http://www.w3school.com.cn/cssref/pr_padding.asp)说的，这个`inner`的高应该是`40px`，但是实际不是，而是`60px`，是以`wrap`的宽度计算的，由此可见，w3school的说法不成立。\n那么，当`padding`设置为`%`时到底以谁为参考呢？\n事到如今我也不给大家卖关子了，其实是以[包含块](http://www.ayqy.net/doc/css2-1/visudet.html#containing-block-details)为参考的。通俗点来说就是谁包含它，它就以谁为参考，在这里`inner`设置了`position:absolute`脱离了原来的文档流，就会去寻找它的祖先元素设置了`position:relative`的元素作为它的包含块。如果还不懂包含块是啥的同学建议仔细阅读我刚刚给的链接，同时还可以参考我在[segmentfault](https://segmentfault.com/q/1010000008362925)上的这个问题。\n\n### 第二个问题\n\n这题考察了对闭包和定时器另外还有js执行顺序的理解。\n先来说说`fn1`，如果把`clearTimeout`去掉，相信大家一定很熟悉，都会说`10ms`延迟后会依次输出`0,1,2,3`。\n但是，请注意这里加了个`clearTimeout`，如果你去控制台实验的话会发现只输出了`0,1,2`，那`3`呢？\n先别急，请听我慢慢道来：\n**请注意：**这个`tc`是定义在闭包外面的，也就是说`tc`并没有被闭包保存，所以这里的`tc`指的是最后一个循环留下来的`tc`，所以最后一个`3`被清除了，没有输出。\n\n再来看看`fn2`，可以发现区别就是把`setTimeout`改为了`setInterval`,同时把定时器也传到了闭包里。\n那么结果又会有什么不同呢？如果亲自去实验的同学就会发现输出`0,1,2,3,3,3...`。\n什么鬼？为毛最后一个定时器没被删除。说实话，我在这里也想了很久，为何最后一个定时器没被删除。后来我为了调试方便把`i<4`改为了`i<2`并把触发时间改为3s，在浏览器中单步调试，发现3s后第一次触发回调函数执行的时候`tc`的值是`undefined`第二次触发的时候有值了。这个时候我顿悟，这和程序的执行顺序有关。我们知道js正常情况下是从上到下，从右到左执行的。\n所以这里每次循环先设置定时器，然后把定时器的返回值赋值给`tc`。在第一次循环的时候`tc`并没有被赋值，所以是`undefined`，在第二次循环的时候，定时器其实清理的是上一个循环的定时器。所以导致每次循环都是清理上一次的定时器，而最后一次循环的定时器没被清理，导致一直输出`3`。\n\n### 第三个问题\n\n这题很明显，考察函数的柯里化，函数的柯里化还不懂是啥的童鞋可以看[这里](http://www.zhangxinxu.com/wordpress/2013/02/js-currying/)。\n这题我的解题思路可能会有点愚笨，不过为了抛砖引玉，还是硬着头皮把我的方法写上来吧，欢迎大家在下面评论给意见。\n按照题目的要求需要把`fn`作为第一个参数传进去，而且给出结果刚好是`fn`运算后给出的结果。\n所以我的思路是要有一个函数将`fn`函数所需参数全部集中到一个数组上，集中完毕后调用`fn`函数，我的代码如下：\n\n\tvar fn = function(a,b,c) {\n\t\treturn a+b+c;\n\t}\n\t\t\t\n\tfunction curry(fn) {\n\t\tvar arr = [],\n\t\tmySlice = arr.slice\n\t\tfnLen = fn.length;\n\t\t\t\n\t\tfunction curring() {\n\t\t\tarr = arr.concat(mySlice.call(arguments));\n\t\t\tif(arr.length < fnLen) {\n\t\t\t\treturn curring;\n\t\t\t}\n\t\t\treturn fn.apply(this, arr);\n\t\t}\n\t\treturn curring\n\t}\n\tcurry(fn)(1)(2)(3);//6\n\n### 第四题\n\n这题主要考察对函数原型的理解。\n相信大多数同学看到题目可能会一脸懵逼。`(10)`是什么鬼？函数调用？如果是函数调用你的函数名咧？\n但是如果你多看两眼`(10)`不就是普通的`10`嘛，就是这个`10`在调用它原型下的`add`函数，然后后面一串链式调用你懂的！\n如果搞清楚这点的话这题就简单了，直接在`Number`的原型下加方法：\n\n\tNumber.prototype.add=function(num){\n\t\treturn this+num;\n\t}\n\tNumber.prototype.reduce=function(num){\n\t\treturn this-num;\n\t}\n\n就是这么简单。\n\n## 说在最后的话\n\n祝各位和我一样奋斗在春招一线的同学早日拿到心怡的offer，另外，我的博客还会持续更新关于面试题的一些技术文章，欢迎大家关注。\n[我的简历](http://www.jayzangwill.cn/resume.html)。\n\n## 参考\n\n[一个面试题衍生出来的问题推荐答案](https://segmentfault.com/q/1010000008362925)\n[JS中的柯里化](http://www.zhangxinxu.com/wordpress/2013/02/js-currying/)\n[Web前端面试题，求解答](https://www.zhihu.com/question/54822257)\n","source":"_posts/Some of the interview questions that impressed me-1.md","raw":"---\ntitle: 几个让我印象深刻的面试题(一)\ndate: 2017-03-01 16:35:41\ntags: [面试,基础,javascript]\n---\n\n## 前言\n\n[原文地址](https://jayzangwill.github.io/blog/2017/03/01/Some%20of%20the%20interview%20questions%20that%20impressed%20me/)&&[我的博客](https://jayzangwill.github.io/blog/)\n[知乎](https://zhuanlan.zhihu.com/p/25514220)&&[知乎专栏](https://zhuanlan.zhihu.com/jayzangwill)\n[河南前端交流群官网](http://henanjs.org/)\n\n时间不知不觉已经来到了大三的下学期，各大企业的春招也陆续的开始，自己也开始做些面试题，一来了解了解面试题一般会问什么，二来通过面试题可以发现自己还有哪方面不足赶紧弥补，以备战今年的春招。\n通过最近的学习，我总结了一下一些我遇到的让我印象深刻的一些面试题，大家可以先看看题目自己想想答案，然后再看我的答案(**我的答案经供参考，如有更好的想法欢迎在下面评论区提出自己的意见**)。\n\n<!-- more-->\n\n## 正文\n\n1.  给一个div设置它的宽度为`100px`，然后再设置它的`padding-top`为`20%`。问：现在这个div有多高？\n2.  如下代码：\n\n\n\tfunction fn1(){\n\t\tfor(var i=0;i<4;i++){\n\t\t\tvar tc=setTimeout(function(i){\n\t\t\t\tconsole.log(i);\n\t\t\t\tclearTimeout(tc)\n\t\t\t},10,i);\n\t\t}\n\t}\n\tfunction fn2(){\n\t\tfor(var i=0;i<4;i++){\n\t\t\tvar tc=setInterval(function(i,tc){\n\t\t\t\tconsole.log(i);\n\t\t\t\tclearInterval(tc)\n\t\t\t},10,i,tc);\n\t\t}\n\t}\n\tfn1();\n\tfn2();\n\n请问分别会输出什么？\n\n3.  如下代码：\n\n\n\tvar fn=function(a,b,c){\n\t\treturn a+b+c;\n\t}\n\n需要写一个函数，满足`curry(fn)(1)(2)(3) //6`\n\n4.  使用原生JS实现：`(10).add(10).reduce(2).add(10) //28`，意思是10加上10减去2加上10等于28。\n\n你可以自己思考答案后在参考我给的参考答案。\n\n## 答案揭晓\n\n### 第一个问题\n\n这题主要考察了对**w3c**标准的了解。如果你亲自去浏览器去试的话会发现这个`div`的高为：`316.8`(**注意**：不同分辨率的电脑测试会有不同的效果，这里以我的电脑1600x900为参考)，其实到这里这题已经是解开了，但是可能还有些同学没明白这个`316.8`是如何计算得来的。别急，请听我细细道来。\n![div的高](/blog/img/face/padding-top.png)\n如果你搞不懂结果为何是这个的话可能会去查[w3school](http://www.w3school.com.cn/cssref/pr_padding.asp)，你可能会看到：\n![w3school上的介绍](/blog/img/face/w3c.png)\n但是可以这么说上面的所说的是错的，或者说，表述不准确。\n例如一下情况：\n\n\t//css\n\t.inner{\n\t\t\tposition: absolute;\n\t\t\twidth: 100px;\n\t\t\tpadding-top: 20%;\n\t}\n\t.mid{\n\t\twidth: 200px;\n\t}\n\t.wrap{\n\t\tposition: relative;\n\t\twidth: 300px;\n\t}\n\t//html\n\t<div class=\"wrap\">\n\t\t<div class=\"mid\">\n\t\t\t<div class=\"inner\"></div>\n\t\t</div>\n\t</div>\n\t\n![加了定位后div的高](/blog/img/face/absolute-padding.png)\n如果按照[w3school](http://www.w3school.com.cn/cssref/pr_padding.asp)说的，这个`inner`的高应该是`40px`，但是实际不是，而是`60px`，是以`wrap`的宽度计算的，由此可见，w3school的说法不成立。\n那么，当`padding`设置为`%`时到底以谁为参考呢？\n事到如今我也不给大家卖关子了，其实是以[包含块](http://www.ayqy.net/doc/css2-1/visudet.html#containing-block-details)为参考的。通俗点来说就是谁包含它，它就以谁为参考，在这里`inner`设置了`position:absolute`脱离了原来的文档流，就会去寻找它的祖先元素设置了`position:relative`的元素作为它的包含块。如果还不懂包含块是啥的同学建议仔细阅读我刚刚给的链接，同时还可以参考我在[segmentfault](https://segmentfault.com/q/1010000008362925)上的这个问题。\n\n### 第二个问题\n\n这题考察了对闭包和定时器另外还有js执行顺序的理解。\n先来说说`fn1`，如果把`clearTimeout`去掉，相信大家一定很熟悉，都会说`10ms`延迟后会依次输出`0,1,2,3`。\n但是，请注意这里加了个`clearTimeout`，如果你去控制台实验的话会发现只输出了`0,1,2`，那`3`呢？\n先别急，请听我慢慢道来：\n**请注意：**这个`tc`是定义在闭包外面的，也就是说`tc`并没有被闭包保存，所以这里的`tc`指的是最后一个循环留下来的`tc`，所以最后一个`3`被清除了，没有输出。\n\n再来看看`fn2`，可以发现区别就是把`setTimeout`改为了`setInterval`,同时把定时器也传到了闭包里。\n那么结果又会有什么不同呢？如果亲自去实验的同学就会发现输出`0,1,2,3,3,3...`。\n什么鬼？为毛最后一个定时器没被删除。说实话，我在这里也想了很久，为何最后一个定时器没被删除。后来我为了调试方便把`i<4`改为了`i<2`并把触发时间改为3s，在浏览器中单步调试，发现3s后第一次触发回调函数执行的时候`tc`的值是`undefined`第二次触发的时候有值了。这个时候我顿悟，这和程序的执行顺序有关。我们知道js正常情况下是从上到下，从右到左执行的。\n所以这里每次循环先设置定时器，然后把定时器的返回值赋值给`tc`。在第一次循环的时候`tc`并没有被赋值，所以是`undefined`，在第二次循环的时候，定时器其实清理的是上一个循环的定时器。所以导致每次循环都是清理上一次的定时器，而最后一次循环的定时器没被清理，导致一直输出`3`。\n\n### 第三个问题\n\n这题很明显，考察函数的柯里化，函数的柯里化还不懂是啥的童鞋可以看[这里](http://www.zhangxinxu.com/wordpress/2013/02/js-currying/)。\n这题我的解题思路可能会有点愚笨，不过为了抛砖引玉，还是硬着头皮把我的方法写上来吧，欢迎大家在下面评论给意见。\n按照题目的要求需要把`fn`作为第一个参数传进去，而且给出结果刚好是`fn`运算后给出的结果。\n所以我的思路是要有一个函数将`fn`函数所需参数全部集中到一个数组上，集中完毕后调用`fn`函数，我的代码如下：\n\n\tvar fn = function(a,b,c) {\n\t\treturn a+b+c;\n\t}\n\t\t\t\n\tfunction curry(fn) {\n\t\tvar arr = [],\n\t\tmySlice = arr.slice\n\t\tfnLen = fn.length;\n\t\t\t\n\t\tfunction curring() {\n\t\t\tarr = arr.concat(mySlice.call(arguments));\n\t\t\tif(arr.length < fnLen) {\n\t\t\t\treturn curring;\n\t\t\t}\n\t\t\treturn fn.apply(this, arr);\n\t\t}\n\t\treturn curring\n\t}\n\tcurry(fn)(1)(2)(3);//6\n\n### 第四题\n\n这题主要考察对函数原型的理解。\n相信大多数同学看到题目可能会一脸懵逼。`(10)`是什么鬼？函数调用？如果是函数调用你的函数名咧？\n但是如果你多看两眼`(10)`不就是普通的`10`嘛，就是这个`10`在调用它原型下的`add`函数，然后后面一串链式调用你懂的！\n如果搞清楚这点的话这题就简单了，直接在`Number`的原型下加方法：\n\n\tNumber.prototype.add=function(num){\n\t\treturn this+num;\n\t}\n\tNumber.prototype.reduce=function(num){\n\t\treturn this-num;\n\t}\n\n就是这么简单。\n\n## 说在最后的话\n\n祝各位和我一样奋斗在春招一线的同学早日拿到心怡的offer，另外，我的博客还会持续更新关于面试题的一些技术文章，欢迎大家关注。\n[我的简历](http://www.jayzangwill.cn/resume.html)。\n\n## 参考\n\n[一个面试题衍生出来的问题推荐答案](https://segmentfault.com/q/1010000008362925)\n[JS中的柯里化](http://www.zhangxinxu.com/wordpress/2013/02/js-currying/)\n[Web前端面试题，求解答](https://www.zhihu.com/question/54822257)\n","slug":"Some of the interview questions that impressed me-1","published":1,"updated":"2020-04-07T03:29:17.930Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8qzc33y00042cl6we9f0jbp","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><a href=\"https://jayzangwill.github.io/blog/2017/03/01/Some%20of%20the%20interview%20questions%20that%20impressed%20me/\">原文地址</a>&amp;&amp;<a href=\"https://jayzangwill.github.io/blog/\">我的博客</a><br><a href=\"https://zhuanlan.zhihu.com/p/25514220\" target=\"_blank\" rel=\"noopener\">知乎</a>&amp;&amp;<a href=\"https://zhuanlan.zhihu.com/jayzangwill\" target=\"_blank\" rel=\"noopener\">知乎专栏</a><br><a href=\"http://henanjs.org/\" target=\"_blank\" rel=\"noopener\">河南前端交流群官网</a></p>\n<p>时间不知不觉已经来到了大三的下学期，各大企业的春招也陆续的开始，自己也开始做些面试题，一来了解了解面试题一般会问什么，二来通过面试题可以发现自己还有哪方面不足赶紧弥补，以备战今年的春招。<br>通过最近的学习，我总结了一下一些我遇到的让我印象深刻的一些面试题，大家可以先看看题目自己想想答案，然后再看我的答案(<strong>我的答案经供参考，如有更好的想法欢迎在下面评论区提出自己的意见</strong>)。</p>\n<a id=\"more\"></a>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><ol>\n<li>给一个div设置它的宽度为<code>100px</code>，然后再设置它的<code>padding-top</code>为<code>20%</code>。问：现在这个div有多高？</li>\n<li>如下代码：</li>\n</ol>\n<pre><code>function fn1(){\n    for(var i=0;i&lt;4;i++){\n        var tc=setTimeout(function(i){\n            console.log(i);\n            clearTimeout(tc)\n        },10,i);\n    }\n}\nfunction fn2(){\n    for(var i=0;i&lt;4;i++){\n        var tc=setInterval(function(i,tc){\n            console.log(i);\n            clearInterval(tc)\n        },10,i,tc);\n    }\n}\nfn1();\nfn2();\n</code></pre><p>请问分别会输出什么？</p>\n<ol start=\"3\">\n<li>如下代码：</li>\n</ol>\n<pre><code>var fn=function(a,b,c){\n    return a+b+c;\n}\n</code></pre><p>需要写一个函数，满足<code>curry(fn)(1)(2)(3) //6</code></p>\n<ol start=\"4\">\n<li>使用原生JS实现：<code>(10).add(10).reduce(2).add(10) //28</code>，意思是10加上10减去2加上10等于28。</li>\n</ol>\n<p>你可以自己思考答案后在参考我给的参考答案。</p>\n<h2 id=\"答案揭晓\"><a href=\"#答案揭晓\" class=\"headerlink\" title=\"答案揭晓\"></a>答案揭晓</h2><h3 id=\"第一个问题\"><a href=\"#第一个问题\" class=\"headerlink\" title=\"第一个问题\"></a>第一个问题</h3><p>这题主要考察了对<strong>w3c</strong>标准的了解。如果你亲自去浏览器去试的话会发现这个<code>div</code>的高为：<code>316.8</code>(<strong>注意</strong>：不同分辨率的电脑测试会有不同的效果，这里以我的电脑1600x900为参考)，其实到这里这题已经是解开了，但是可能还有些同学没明白这个<code>316.8</code>是如何计算得来的。别急，请听我细细道来。<br><img src=\"/blog/img/face/padding-top.png\" alt=\"div的高\"><br>如果你搞不懂结果为何是这个的话可能会去查<a href=\"http://www.w3school.com.cn/cssref/pr_padding.asp\" target=\"_blank\" rel=\"noopener\">w3school</a>，你可能会看到：<br><img src=\"/blog/img/face/w3c.png\" alt=\"w3school上的介绍\"><br>但是可以这么说上面的所说的是错的，或者说，表述不准确。<br>例如一下情况：</p>\n<pre><code>//css\n.inner{\n        position: absolute;\n        width: 100px;\n        padding-top: 20%;\n}\n.mid{\n    width: 200px;\n}\n.wrap{\n    position: relative;\n    width: 300px;\n}\n//html\n&lt;div class=&quot;wrap&quot;&gt;\n    &lt;div class=&quot;mid&quot;&gt;\n        &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p><img src=\"/blog/img/face/absolute-padding.png\" alt=\"加了定位后div的高\"><br>如果按照<a href=\"http://www.w3school.com.cn/cssref/pr_padding.asp\" target=\"_blank\" rel=\"noopener\">w3school</a>说的，这个<code>inner</code>的高应该是<code>40px</code>，但是实际不是，而是<code>60px</code>，是以<code>wrap</code>的宽度计算的，由此可见，w3school的说法不成立。<br>那么，当<code>padding</code>设置为<code>%</code>时到底以谁为参考呢？<br>事到如今我也不给大家卖关子了，其实是以<a href=\"http://www.ayqy.net/doc/css2-1/visudet.html#containing-block-details\" target=\"_blank\" rel=\"noopener\">包含块</a>为参考的。通俗点来说就是谁包含它，它就以谁为参考，在这里<code>inner</code>设置了<code>position:absolute</code>脱离了原来的文档流，就会去寻找它的祖先元素设置了<code>position:relative</code>的元素作为它的包含块。如果还不懂包含块是啥的同学建议仔细阅读我刚刚给的链接，同时还可以参考我在<a href=\"https://segmentfault.com/q/1010000008362925\" target=\"_blank\" rel=\"noopener\">segmentfault</a>上的这个问题。</p>\n<h3 id=\"第二个问题\"><a href=\"#第二个问题\" class=\"headerlink\" title=\"第二个问题\"></a>第二个问题</h3><p>这题考察了对闭包和定时器另外还有js执行顺序的理解。<br>先来说说<code>fn1</code>，如果把<code>clearTimeout</code>去掉，相信大家一定很熟悉，都会说<code>10ms</code>延迟后会依次输出<code>0,1,2,3</code>。<br>但是，请注意这里加了个<code>clearTimeout</code>，如果你去控制台实验的话会发现只输出了<code>0,1,2</code>，那<code>3</code>呢？<br>先别急，请听我慢慢道来：<br><strong>请注意：</strong>这个<code>tc</code>是定义在闭包外面的，也就是说<code>tc</code>并没有被闭包保存，所以这里的<code>tc</code>指的是最后一个循环留下来的<code>tc</code>，所以最后一个<code>3</code>被清除了，没有输出。</p>\n<p>再来看看<code>fn2</code>，可以发现区别就是把<code>setTimeout</code>改为了<code>setInterval</code>,同时把定时器也传到了闭包里。<br>那么结果又会有什么不同呢？如果亲自去实验的同学就会发现输出<code>0,1,2,3,3,3...</code>。<br>什么鬼？为毛最后一个定时器没被删除。说实话，我在这里也想了很久，为何最后一个定时器没被删除。后来我为了调试方便把<code>i&lt;4</code>改为了<code>i&lt;2</code>并把触发时间改为3s，在浏览器中单步调试，发现3s后第一次触发回调函数执行的时候<code>tc</code>的值是<code>undefined</code>第二次触发的时候有值了。这个时候我顿悟，这和程序的执行顺序有关。我们知道js正常情况下是从上到下，从右到左执行的。<br>所以这里每次循环先设置定时器，然后把定时器的返回值赋值给<code>tc</code>。在第一次循环的时候<code>tc</code>并没有被赋值，所以是<code>undefined</code>，在第二次循环的时候，定时器其实清理的是上一个循环的定时器。所以导致每次循环都是清理上一次的定时器，而最后一次循环的定时器没被清理，导致一直输出<code>3</code>。</p>\n<h3 id=\"第三个问题\"><a href=\"#第三个问题\" class=\"headerlink\" title=\"第三个问题\"></a>第三个问题</h3><p>这题很明显，考察函数的柯里化，函数的柯里化还不懂是啥的童鞋可以看<a href=\"http://www.zhangxinxu.com/wordpress/2013/02/js-currying/\" target=\"_blank\" rel=\"noopener\">这里</a>。<br>这题我的解题思路可能会有点愚笨，不过为了抛砖引玉，还是硬着头皮把我的方法写上来吧，欢迎大家在下面评论给意见。<br>按照题目的要求需要把<code>fn</code>作为第一个参数传进去，而且给出结果刚好是<code>fn</code>运算后给出的结果。<br>所以我的思路是要有一个函数将<code>fn</code>函数所需参数全部集中到一个数组上，集中完毕后调用<code>fn</code>函数，我的代码如下：</p>\n<pre><code>var fn = function(a,b,c) {\n    return a+b+c;\n}\n\nfunction curry(fn) {\n    var arr = [],\n    mySlice = arr.slice\n    fnLen = fn.length;\n\n    function curring() {\n        arr = arr.concat(mySlice.call(arguments));\n        if(arr.length &lt; fnLen) {\n            return curring;\n        }\n        return fn.apply(this, arr);\n    }\n    return curring\n}\ncurry(fn)(1)(2)(3);//6\n</code></pre><h3 id=\"第四题\"><a href=\"#第四题\" class=\"headerlink\" title=\"第四题\"></a>第四题</h3><p>这题主要考察对函数原型的理解。<br>相信大多数同学看到题目可能会一脸懵逼。<code>(10)</code>是什么鬼？函数调用？如果是函数调用你的函数名咧？<br>但是如果你多看两眼<code>(10)</code>不就是普通的<code>10</code>嘛，就是这个<code>10</code>在调用它原型下的<code>add</code>函数，然后后面一串链式调用你懂的！<br>如果搞清楚这点的话这题就简单了，直接在<code>Number</code>的原型下加方法：</p>\n<pre><code>Number.prototype.add=function(num){\n    return this+num;\n}\nNumber.prototype.reduce=function(num){\n    return this-num;\n}\n</code></pre><p>就是这么简单。</p>\n<h2 id=\"说在最后的话\"><a href=\"#说在最后的话\" class=\"headerlink\" title=\"说在最后的话\"></a>说在最后的话</h2><p>祝各位和我一样奋斗在春招一线的同学早日拿到心怡的offer，另外，我的博客还会持续更新关于面试题的一些技术文章，欢迎大家关注。<br><a href=\"http://www.jayzangwill.cn/resume.html\" target=\"_blank\" rel=\"noopener\">我的简历</a>。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://segmentfault.com/q/1010000008362925\" target=\"_blank\" rel=\"noopener\">一个面试题衍生出来的问题推荐答案</a><br><a href=\"http://www.zhangxinxu.com/wordpress/2013/02/js-currying/\" target=\"_blank\" rel=\"noopener\">JS中的柯里化</a><br><a href=\"https://www.zhihu.com/question/54822257\" target=\"_blank\" rel=\"noopener\">Web前端面试题，求解答</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><a href=\"https://jayzangwill.github.io/blog/2017/03/01/Some%20of%20the%20interview%20questions%20that%20impressed%20me/\">原文地址</a>&amp;&amp;<a href=\"https://jayzangwill.github.io/blog/\">我的博客</a><br><a href=\"https://zhuanlan.zhihu.com/p/25514220\" target=\"_blank\" rel=\"noopener\">知乎</a>&amp;&amp;<a href=\"https://zhuanlan.zhihu.com/jayzangwill\" target=\"_blank\" rel=\"noopener\">知乎专栏</a><br><a href=\"http://henanjs.org/\" target=\"_blank\" rel=\"noopener\">河南前端交流群官网</a></p>\n<p>时间不知不觉已经来到了大三的下学期，各大企业的春招也陆续的开始，自己也开始做些面试题，一来了解了解面试题一般会问什么，二来通过面试题可以发现自己还有哪方面不足赶紧弥补，以备战今年的春招。<br>通过最近的学习，我总结了一下一些我遇到的让我印象深刻的一些面试题，大家可以先看看题目自己想想答案，然后再看我的答案(<strong>我的答案经供参考，如有更好的想法欢迎在下面评论区提出自己的意见</strong>)。</p>","more":"<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><ol>\n<li>给一个div设置它的宽度为<code>100px</code>，然后再设置它的<code>padding-top</code>为<code>20%</code>。问：现在这个div有多高？</li>\n<li>如下代码：</li>\n</ol>\n<pre><code>function fn1(){\n    for(var i=0;i&lt;4;i++){\n        var tc=setTimeout(function(i){\n            console.log(i);\n            clearTimeout(tc)\n        },10,i);\n    }\n}\nfunction fn2(){\n    for(var i=0;i&lt;4;i++){\n        var tc=setInterval(function(i,tc){\n            console.log(i);\n            clearInterval(tc)\n        },10,i,tc);\n    }\n}\nfn1();\nfn2();\n</code></pre><p>请问分别会输出什么？</p>\n<ol start=\"3\">\n<li>如下代码：</li>\n</ol>\n<pre><code>var fn=function(a,b,c){\n    return a+b+c;\n}\n</code></pre><p>需要写一个函数，满足<code>curry(fn)(1)(2)(3) //6</code></p>\n<ol start=\"4\">\n<li>使用原生JS实现：<code>(10).add(10).reduce(2).add(10) //28</code>，意思是10加上10减去2加上10等于28。</li>\n</ol>\n<p>你可以自己思考答案后在参考我给的参考答案。</p>\n<h2 id=\"答案揭晓\"><a href=\"#答案揭晓\" class=\"headerlink\" title=\"答案揭晓\"></a>答案揭晓</h2><h3 id=\"第一个问题\"><a href=\"#第一个问题\" class=\"headerlink\" title=\"第一个问题\"></a>第一个问题</h3><p>这题主要考察了对<strong>w3c</strong>标准的了解。如果你亲自去浏览器去试的话会发现这个<code>div</code>的高为：<code>316.8</code>(<strong>注意</strong>：不同分辨率的电脑测试会有不同的效果，这里以我的电脑1600x900为参考)，其实到这里这题已经是解开了，但是可能还有些同学没明白这个<code>316.8</code>是如何计算得来的。别急，请听我细细道来。<br><img src=\"/blog/img/face/padding-top.png\" alt=\"div的高\"><br>如果你搞不懂结果为何是这个的话可能会去查<a href=\"http://www.w3school.com.cn/cssref/pr_padding.asp\" target=\"_blank\" rel=\"noopener\">w3school</a>，你可能会看到：<br><img src=\"/blog/img/face/w3c.png\" alt=\"w3school上的介绍\"><br>但是可以这么说上面的所说的是错的，或者说，表述不准确。<br>例如一下情况：</p>\n<pre><code>//css\n.inner{\n        position: absolute;\n        width: 100px;\n        padding-top: 20%;\n}\n.mid{\n    width: 200px;\n}\n.wrap{\n    position: relative;\n    width: 300px;\n}\n//html\n&lt;div class=&quot;wrap&quot;&gt;\n    &lt;div class=&quot;mid&quot;&gt;\n        &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p><img src=\"/blog/img/face/absolute-padding.png\" alt=\"加了定位后div的高\"><br>如果按照<a href=\"http://www.w3school.com.cn/cssref/pr_padding.asp\" target=\"_blank\" rel=\"noopener\">w3school</a>说的，这个<code>inner</code>的高应该是<code>40px</code>，但是实际不是，而是<code>60px</code>，是以<code>wrap</code>的宽度计算的，由此可见，w3school的说法不成立。<br>那么，当<code>padding</code>设置为<code>%</code>时到底以谁为参考呢？<br>事到如今我也不给大家卖关子了，其实是以<a href=\"http://www.ayqy.net/doc/css2-1/visudet.html#containing-block-details\" target=\"_blank\" rel=\"noopener\">包含块</a>为参考的。通俗点来说就是谁包含它，它就以谁为参考，在这里<code>inner</code>设置了<code>position:absolute</code>脱离了原来的文档流，就会去寻找它的祖先元素设置了<code>position:relative</code>的元素作为它的包含块。如果还不懂包含块是啥的同学建议仔细阅读我刚刚给的链接，同时还可以参考我在<a href=\"https://segmentfault.com/q/1010000008362925\" target=\"_blank\" rel=\"noopener\">segmentfault</a>上的这个问题。</p>\n<h3 id=\"第二个问题\"><a href=\"#第二个问题\" class=\"headerlink\" title=\"第二个问题\"></a>第二个问题</h3><p>这题考察了对闭包和定时器另外还有js执行顺序的理解。<br>先来说说<code>fn1</code>，如果把<code>clearTimeout</code>去掉，相信大家一定很熟悉，都会说<code>10ms</code>延迟后会依次输出<code>0,1,2,3</code>。<br>但是，请注意这里加了个<code>clearTimeout</code>，如果你去控制台实验的话会发现只输出了<code>0,1,2</code>，那<code>3</code>呢？<br>先别急，请听我慢慢道来：<br><strong>请注意：</strong>这个<code>tc</code>是定义在闭包外面的，也就是说<code>tc</code>并没有被闭包保存，所以这里的<code>tc</code>指的是最后一个循环留下来的<code>tc</code>，所以最后一个<code>3</code>被清除了，没有输出。</p>\n<p>再来看看<code>fn2</code>，可以发现区别就是把<code>setTimeout</code>改为了<code>setInterval</code>,同时把定时器也传到了闭包里。<br>那么结果又会有什么不同呢？如果亲自去实验的同学就会发现输出<code>0,1,2,3,3,3...</code>。<br>什么鬼？为毛最后一个定时器没被删除。说实话，我在这里也想了很久，为何最后一个定时器没被删除。后来我为了调试方便把<code>i&lt;4</code>改为了<code>i&lt;2</code>并把触发时间改为3s，在浏览器中单步调试，发现3s后第一次触发回调函数执行的时候<code>tc</code>的值是<code>undefined</code>第二次触发的时候有值了。这个时候我顿悟，这和程序的执行顺序有关。我们知道js正常情况下是从上到下，从右到左执行的。<br>所以这里每次循环先设置定时器，然后把定时器的返回值赋值给<code>tc</code>。在第一次循环的时候<code>tc</code>并没有被赋值，所以是<code>undefined</code>，在第二次循环的时候，定时器其实清理的是上一个循环的定时器。所以导致每次循环都是清理上一次的定时器，而最后一次循环的定时器没被清理，导致一直输出<code>3</code>。</p>\n<h3 id=\"第三个问题\"><a href=\"#第三个问题\" class=\"headerlink\" title=\"第三个问题\"></a>第三个问题</h3><p>这题很明显，考察函数的柯里化，函数的柯里化还不懂是啥的童鞋可以看<a href=\"http://www.zhangxinxu.com/wordpress/2013/02/js-currying/\" target=\"_blank\" rel=\"noopener\">这里</a>。<br>这题我的解题思路可能会有点愚笨，不过为了抛砖引玉，还是硬着头皮把我的方法写上来吧，欢迎大家在下面评论给意见。<br>按照题目的要求需要把<code>fn</code>作为第一个参数传进去，而且给出结果刚好是<code>fn</code>运算后给出的结果。<br>所以我的思路是要有一个函数将<code>fn</code>函数所需参数全部集中到一个数组上，集中完毕后调用<code>fn</code>函数，我的代码如下：</p>\n<pre><code>var fn = function(a,b,c) {\n    return a+b+c;\n}\n\nfunction curry(fn) {\n    var arr = [],\n    mySlice = arr.slice\n    fnLen = fn.length;\n\n    function curring() {\n        arr = arr.concat(mySlice.call(arguments));\n        if(arr.length &lt; fnLen) {\n            return curring;\n        }\n        return fn.apply(this, arr);\n    }\n    return curring\n}\ncurry(fn)(1)(2)(3);//6\n</code></pre><h3 id=\"第四题\"><a href=\"#第四题\" class=\"headerlink\" title=\"第四题\"></a>第四题</h3><p>这题主要考察对函数原型的理解。<br>相信大多数同学看到题目可能会一脸懵逼。<code>(10)</code>是什么鬼？函数调用？如果是函数调用你的函数名咧？<br>但是如果你多看两眼<code>(10)</code>不就是普通的<code>10</code>嘛，就是这个<code>10</code>在调用它原型下的<code>add</code>函数，然后后面一串链式调用你懂的！<br>如果搞清楚这点的话这题就简单了，直接在<code>Number</code>的原型下加方法：</p>\n<pre><code>Number.prototype.add=function(num){\n    return this+num;\n}\nNumber.prototype.reduce=function(num){\n    return this-num;\n}\n</code></pre><p>就是这么简单。</p>\n<h2 id=\"说在最后的话\"><a href=\"#说在最后的话\" class=\"headerlink\" title=\"说在最后的话\"></a>说在最后的话</h2><p>祝各位和我一样奋斗在春招一线的同学早日拿到心怡的offer，另外，我的博客还会持续更新关于面试题的一些技术文章，欢迎大家关注。<br><a href=\"http://www.jayzangwill.cn/resume.html\" target=\"_blank\" rel=\"noopener\">我的简历</a>。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://segmentfault.com/q/1010000008362925\" target=\"_blank\" rel=\"noopener\">一个面试题衍生出来的问题推荐答案</a><br><a href=\"http://www.zhangxinxu.com/wordpress/2013/02/js-currying/\" target=\"_blank\" rel=\"noopener\">JS中的柯里化</a><br><a href=\"https://www.zhihu.com/question/54822257\" target=\"_blank\" rel=\"noopener\">Web前端面试题，求解答</a></p>"},{"title":"javscript的数据类型","date":"2016-11-07T01:24:10.000Z","_content":"# javscript数据类型\n\n之前学到javascript的数据类型时遇到了一些困惑，因为之前和一些大神交流和自己百度+谷歌查到的还有在红宝书上看到的答案不一样，最近通过查阅了一些资料终于把自己的困惑解决了，现在来写一些笔记记录记录。\n\n<!-- more-->\n\n之前和一些大神交流了一下javascript的数据类型的问题，这些大神大多数都把js的数据类型分为：\n\n* number\n\n* string\n\n* undefined\n\n* function\n\n* boolean\n\n* object\n\n当时我就把javascript的数据类型分为这几种了，但是后来我又在网上发现有其他的一种分类：\n\n* number\n\n* string\n\n* undefined\n\n* null\n\n* boolean\n\n* symbol (es6新增)\n\n* object\n\n可以发现，这两种分类的分歧在`function`和`null`上。\n\n可以判断：前者是根据`typeof`返回的值来分数据类型的，根据我所查到的[资料](https://www.zhihu.com/question/24804474)说根据`typeof`来定义数据类型是不正确的，因为它只是一个运算符，它的返回值不能作为数据类型的依据。\n\n[资料](https://www.zhihu.com/question/24804474)上面还说了`typeof null`返回的`object`是个历史性的错误，按理来说应该返回`null` \n\n**注意：**在javascript中\n\n    console.log(null==undefined) //true\n    console.lof(null===undefined) //false\n    \n在[ECMASscript标准中](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-data-types-and-values)也很详细地说了数据类型和它们的值，发现都是以第二种分类为准。\n\n至于新加的符号类型可以[戳这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)","source":"_posts/Javscript data type.md","raw":"---\ntitle: javscript的数据类型\ndate: 2016-11-07 09:24:10\ntags: [javascript,基础]\n---\n# javscript数据类型\n\n之前学到javascript的数据类型时遇到了一些困惑，因为之前和一些大神交流和自己百度+谷歌查到的还有在红宝书上看到的答案不一样，最近通过查阅了一些资料终于把自己的困惑解决了，现在来写一些笔记记录记录。\n\n<!-- more-->\n\n之前和一些大神交流了一下javascript的数据类型的问题，这些大神大多数都把js的数据类型分为：\n\n* number\n\n* string\n\n* undefined\n\n* function\n\n* boolean\n\n* object\n\n当时我就把javascript的数据类型分为这几种了，但是后来我又在网上发现有其他的一种分类：\n\n* number\n\n* string\n\n* undefined\n\n* null\n\n* boolean\n\n* symbol (es6新增)\n\n* object\n\n可以发现，这两种分类的分歧在`function`和`null`上。\n\n可以判断：前者是根据`typeof`返回的值来分数据类型的，根据我所查到的[资料](https://www.zhihu.com/question/24804474)说根据`typeof`来定义数据类型是不正确的，因为它只是一个运算符，它的返回值不能作为数据类型的依据。\n\n[资料](https://www.zhihu.com/question/24804474)上面还说了`typeof null`返回的`object`是个历史性的错误，按理来说应该返回`null` \n\n**注意：**在javascript中\n\n    console.log(null==undefined) //true\n    console.lof(null===undefined) //false\n    \n在[ECMASscript标准中](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-data-types-and-values)也很详细地说了数据类型和它们的值，发现都是以第二种分类为准。\n\n至于新加的符号类型可以[戳这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)","slug":"Javscript data type","published":1,"updated":"2020-04-07T03:29:17.929Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8qzc34300052cl6u9jwtz7t","content":"<h1 id=\"javscript数据类型\"><a href=\"#javscript数据类型\" class=\"headerlink\" title=\"javscript数据类型\"></a>javscript数据类型</h1><p>之前学到javascript的数据类型时遇到了一些困惑，因为之前和一些大神交流和自己百度+谷歌查到的还有在红宝书上看到的答案不一样，最近通过查阅了一些资料终于把自己的困惑解决了，现在来写一些笔记记录记录。</p>\n<a id=\"more\"></a>\n<p>之前和一些大神交流了一下javascript的数据类型的问题，这些大神大多数都把js的数据类型分为：</p>\n<ul>\n<li><p>number</p>\n</li>\n<li><p>string</p>\n</li>\n<li><p>undefined</p>\n</li>\n<li><p>function</p>\n</li>\n<li><p>boolean</p>\n</li>\n<li><p>object</p>\n</li>\n</ul>\n<p>当时我就把javascript的数据类型分为这几种了，但是后来我又在网上发现有其他的一种分类：</p>\n<ul>\n<li><p>number</p>\n</li>\n<li><p>string</p>\n</li>\n<li><p>undefined</p>\n</li>\n<li><p>null</p>\n</li>\n<li><p>boolean</p>\n</li>\n<li><p>symbol (es6新增)</p>\n</li>\n<li><p>object</p>\n</li>\n</ul>\n<p>可以发现，这两种分类的分歧在<code>function</code>和<code>null</code>上。</p>\n<p>可以判断：前者是根据<code>typeof</code>返回的值来分数据类型的，根据我所查到的<a href=\"https://www.zhihu.com/question/24804474\" target=\"_blank\" rel=\"noopener\">资料</a>说根据<code>typeof</code>来定义数据类型是不正确的，因为它只是一个运算符，它的返回值不能作为数据类型的依据。</p>\n<p><a href=\"https://www.zhihu.com/question/24804474\" target=\"_blank\" rel=\"noopener\">资料</a>上面还说了<code>typeof null</code>返回的<code>object</code>是个历史性的错误，按理来说应该返回<code>null</code> </p>\n<p><strong>注意：</strong>在javascript中</p>\n<pre><code>console.log(null==undefined) //true\nconsole.lof(null===undefined) //false\n</code></pre><p>在<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-data-types-and-values\" target=\"_blank\" rel=\"noopener\">ECMASscript标准中</a>也很详细地说了数据类型和它们的值，发现都是以第二种分类为准。</p>\n<p>至于新加的符号类型可以<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol\" target=\"_blank\" rel=\"noopener\">戳这里</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"javscript数据类型\"><a href=\"#javscript数据类型\" class=\"headerlink\" title=\"javscript数据类型\"></a>javscript数据类型</h1><p>之前学到javascript的数据类型时遇到了一些困惑，因为之前和一些大神交流和自己百度+谷歌查到的还有在红宝书上看到的答案不一样，最近通过查阅了一些资料终于把自己的困惑解决了，现在来写一些笔记记录记录。</p>","more":"<p>之前和一些大神交流了一下javascript的数据类型的问题，这些大神大多数都把js的数据类型分为：</p>\n<ul>\n<li><p>number</p>\n</li>\n<li><p>string</p>\n</li>\n<li><p>undefined</p>\n</li>\n<li><p>function</p>\n</li>\n<li><p>boolean</p>\n</li>\n<li><p>object</p>\n</li>\n</ul>\n<p>当时我就把javascript的数据类型分为这几种了，但是后来我又在网上发现有其他的一种分类：</p>\n<ul>\n<li><p>number</p>\n</li>\n<li><p>string</p>\n</li>\n<li><p>undefined</p>\n</li>\n<li><p>null</p>\n</li>\n<li><p>boolean</p>\n</li>\n<li><p>symbol (es6新增)</p>\n</li>\n<li><p>object</p>\n</li>\n</ul>\n<p>可以发现，这两种分类的分歧在<code>function</code>和<code>null</code>上。</p>\n<p>可以判断：前者是根据<code>typeof</code>返回的值来分数据类型的，根据我所查到的<a href=\"https://www.zhihu.com/question/24804474\" target=\"_blank\" rel=\"noopener\">资料</a>说根据<code>typeof</code>来定义数据类型是不正确的，因为它只是一个运算符，它的返回值不能作为数据类型的依据。</p>\n<p><a href=\"https://www.zhihu.com/question/24804474\" target=\"_blank\" rel=\"noopener\">资料</a>上面还说了<code>typeof null</code>返回的<code>object</code>是个历史性的错误，按理来说应该返回<code>null</code> </p>\n<p><strong>注意：</strong>在javascript中</p>\n<pre><code>console.log(null==undefined) //true\nconsole.lof(null===undefined) //false\n</code></pre><p>在<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-data-types-and-values\" target=\"_blank\" rel=\"noopener\">ECMASscript标准中</a>也很详细地说了数据类型和它们的值，发现都是以第二种分类为准。</p>\n<p>至于新加的符号类型可以<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol\" target=\"_blank\" rel=\"noopener\">戳这里</a></p>"},{"title":"四月北京面试之旅","date":"2017-04-25T02:25:36.000Z","_content":"\n此次面试之旅虽然只面试了两家，但是在这其中学到了蛮多同时也意识到了自己的很多不足。\n\n以下面试情况都是凭着记忆中的印象写的，面试的问题要比我写的多，我就写些印象深刻的。\n\n<!-- more -->\n\n### 搜狗\n\n感觉能拿到搜狗的面试机会个人觉得有运气也有实力吧。刚开始先是在拉钩上投了搜狗的这个前端重构师这个职位(这个职位注重html,css基础)，没过几天搜狗就给我打电话来了，那时还是中午，我在午休，突然接到一个电话说是搜狗的。当时我吓得脑子一片空白(出现这个情况的原因是身为一个末流二本的学生居然这么快接到了大公司的面试。爱情来的太快就像龙卷风，让我防不胜防)。稍微整理好心情以后(当时还在没睡醒的状态)，面试官开始问我一些基础问题：\n\n面试官：清除浮动的原理\n\n睡眼朦胧的我(答了怎么清除浮动)：我常用的有两种方法一种是`overflow:hidden`还有一种就是用`:after`清除浮动(这个方法相信大家都懂，我就不写了)...\n\n面试官：你好像有点紧张啊，我问的是原理，你给我答怎么清除浮动？\n\n我：(中间我还答了些有的没的这里就省略了)哦！`overflow:hidden`创建了`BFC`利用`BFC`计算高度的时候浮动元素也要计算在内。`:after`是利用了父元素必须把非浮动元素的位置考虑进去(支支吾吾的答完了这题)。\n\n面试官：怎么创建`BFC`？\n\n我：`overflow:hidden`，`visibility`不为`visible`，定位(其实是`position`为`absolute`或`fixed`);\n\n面试官：你平时都用哪些自动化工具，都用它们的什么插件？\n\n我：用`gulp`像图片压缩，js、css压缩合并，文件连接，`bable`，`js-hit`。\n\n面试官：这样吧，我给你发一个设计图过去，你把它还原成网页...(省略)。\n\n不久，面试官给我发来了设计图，于是我就开始做了，第二天这样给面试官发过去了。没想到面试官当天就给我回信给我点评了一些不足，还说可以不用做这么快的(这让我万万没想到啊，还有点评)，于是我又按照点评改了改，再在此之上加了些优化，过了两天给面试官发过去了。大概等了1,2个星期没音，我以为是跪了。没想到又过了几天面试官给我打电话邀请我到搜狐大厦去面试(超高兴，能去参观参观大厂，去那面试)。\n\n按照约定时间我来到了搜狐网络大厦(本来想提前15分钟这样到的，没想到突然犯路痴，结果刚好是约定的时间到)...省略一些有的没的，直接进入面试吧：\n\n面试官：自我介绍下吧。\n\n我：balabala\n\n面试官：如何实现左边图片右边文字的布局，都是不定宽的。\n\n我：(省略一些有的没的回答)给它们都加上浮动。\n\n面试官：这样不行\n\n我：（惊讶脸）啊！不行？！我现在暂时想不到其他方法了。\n\n面试官：不考虑浏览器兼容性呢？\n\n我：啊！可以用`flex`，后面还balabala一些有的没的让面试官对答案不满意了，其实在父容器加个`display:flex`就得了。\n\n中间一些项目的问答。\n\n面试官：你平时切图切出来的图片都保存为什么格式，为什么？\n\n我：保存为png-24，因为它比较小(这里答得不理想啊，应该是png压缩后比jpg小，而且png是无损压缩，jpg是有损压缩)\n\n面试官：你平时有没有用过什么工具来提高的的开发效率？\n\n我：(和上面电话面试的回答差不多)\n\n面试官可能是看上面我的回答不怎么好于是拿出几道js题给我做。\n\n第一题大概是这样的(考察作用域)：\n```javascript\nvar a=1;\nfunction fun(a){\n    var a=b=2;\n    return function e(){\n        var c=3\n    }\n}\nvar d=fun(a);\nconsole.log(a,b,typeof c,typeof d,typeof e)\n```\n\n题目大概是这样，记不太清了，做出来以后和面试官解释为什么会这样。\n答案是：1 2 undefined function undefined，至于为什么会这样我就不多说了，稍微有点基础的同学应该能一眼看出来。\n\n第二题：给不支持es5的浏览器写一个Array，prototype.map：\n\n答案：\n```javascript\nif(!Array，prototype.map){\n    Array，prototype.map=function(fn){\n        var len=this.length,\n            i=0,\n            result=[];\n        for(;i<len;i++){\n        \tresult.push(fn.call(this,this[i],i,this));\n        }\n    }\n    return result;\n}\n```\n\n### 去哪儿\n\n#### 一面\n\n项目的一些问答\n\n面试官：ajax的过程\n\n我：先打开请求的地址，然后发送请求，然后处理数据并将数据反馈到页面。\n\n面试官：假设我有一个ul，里面有好多个li，我如何知道用户点了哪个？\n\n我：在ul上绑一个点击事件，利用回调函数的e参数的target获取用户点的li，然后获取这个ul里面的li用slice转为真正的数组，调用数组的indexOf(e.target)就知道用户点了哪个\n\n代码：\n```javascript\nvar ul=document.getElementById('ul'),\n    li=ul.getElementsByTagName('li');\n    ul.addEventListener('click',function(e){\n        console.log([].slice.call(li).indexOf(e.target));\n    });\n```\n\n面试官：如果我li里面套了一个span，这个时候我又怎么知道用户点了第几个span\n\n我：直接把上面的li换成span\n\n面试官：你知不知道这个时候的`e.currentTarget`指向谁，为什么？\n\n我：ul，因为`e.currentTarget`指的是当前被绑定事件的元素。\n\n面试官：new的过程\n\n我：首先会新创建一个对象，然后将构造函数的`prototype`赋值给新创建对象的`__proto__`，将构造函数的`this`指向这个对象，并执行构造函数里的代码，最后判断返回值(如果返回值是简单数据类型直接返回新创建的对象，如果是复杂数据类型会返回这个复杂数据类型)\n\n面试官：Promise的三个状态？\n\n我：pedding resolve reject...(省略)\n\n面试官：实现继承的方法？\n\n我：(回来在写这篇文章的时候翻看发现自己答得不是很理想)，可以看看高程的162-173页的继承。\n\n面试官：http的状态码常用的有哪些？\n\n我：(这个我就不打在这了，问题太过于简单)贴个[链接](http://www.cnblogs.com/loveyakamoz/archive/2011/09/03/2165266.html)\n\n面试官：我现在第一次载入这个网页以后按刷新，这个时候会出现哪些状态码？\n\n我：(我觉得面试官应该是问缓存会出现哪些状态码)于是我就答200(from memory cache) 和304，并和面试官解释这两个的差异；前者是直接从cache里面获取后者是向服务端发出确认没变然后再从cache里面取的。\n\n面试官：假如现在我有一个数组[1,2,3,4,5,6,7,9]我想知道8应该在数组的哪个位置该怎么做？\n\n我：把这个8`push`到数组里，排序，然后indexOf(8)\n\n面试官：还有更好的办法吗？\n\n我：没了(寻求更好的办法)。\n\n面试官：css的优先级是怎么样的？\n\n我：important>id>class>element然后，内嵌>内联>外联\n\n面试官：我css有两个类c1和c2，他们内部分别定义了`background-color:red`和`background-color:green`把它们同时加到一个div上，这个时候他们的背景颜色是什么颜色？\n\n我：这个取决于这两个类在css文件中定义的位置了，谁靠后就取谁的颜色。\n\n面试官：我先定义c1在定义c2\n\n我：那就是green了\n\n面试官：如果我给这个div外面再套个div这个div类名为box，我在css文件中修改c1为`.box .c1`，这个时候颜色是啥？\n\n我：那就是red了(为什么会这样就不用我多说了，相信大家都知道)\n\n有了解过AMD/CMD、commonJS吗\n\n我：(回答的大致意思在[这里](http://www.jianshu.com/p/d67bc79976e6))\n\n一面下来感觉就是碾压，问的东西非常基础，面试官看起来也特别满意，于是就让我去二面。\n\n#### 二面\n\n上来就让我手写快排，还好之前有复习，不过久没写字了，写得比较慢，最后没写完，不过我和面试官讲解了思路，面试官看起来貌似蛮满意。\n\n面试官：你给我介绍一些网络的知识吧。\n\n我：balabala。\n\n面试官：网络七层协议？\n\n我：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层\n\n面试官：你操作系统怎么样？\n\n我：这方面比较弱。\n\n面试官：你给我介绍一下多进程和死锁吧。\n\n我：...\n\n面试官：如何证明node是单线程的？\n\n我：给两段代码中间加个循环次数特别多的循环(这个问题没回答好，可以参考《了不起的Node js 将JavaScript进行到底》27页的例子)\n\n```javascript\nvar start=Date.now();\nsetTimeout(function(){\n    console.log(Date.now()-start);\n    for(var i=0;i<1000000000;i++){}\n},1000);\nsetTimeout(function(){\n    console.log(Date.now()-start);\n},2000);\n```\n\n面试官：最近有学什么新技术吗？\n\n我：es6、了解了es7的async await还有最新的清除浮动的方法[display:flow-root](http://www.w3cplus.com/css3/display-flow-root.html)\n\n接下来的一些问题记不太清了。。总之，二面被虐得很惨。","source":"_posts/Interview in Beijing in April.md","raw":"---\ntitle: 四月北京面试之旅\ndate: 2017-04-25 10:25:36\ntags: [面试,心情]\n---\n\n此次面试之旅虽然只面试了两家，但是在这其中学到了蛮多同时也意识到了自己的很多不足。\n\n以下面试情况都是凭着记忆中的印象写的，面试的问题要比我写的多，我就写些印象深刻的。\n\n<!-- more -->\n\n### 搜狗\n\n感觉能拿到搜狗的面试机会个人觉得有运气也有实力吧。刚开始先是在拉钩上投了搜狗的这个前端重构师这个职位(这个职位注重html,css基础)，没过几天搜狗就给我打电话来了，那时还是中午，我在午休，突然接到一个电话说是搜狗的。当时我吓得脑子一片空白(出现这个情况的原因是身为一个末流二本的学生居然这么快接到了大公司的面试。爱情来的太快就像龙卷风，让我防不胜防)。稍微整理好心情以后(当时还在没睡醒的状态)，面试官开始问我一些基础问题：\n\n面试官：清除浮动的原理\n\n睡眼朦胧的我(答了怎么清除浮动)：我常用的有两种方法一种是`overflow:hidden`还有一种就是用`:after`清除浮动(这个方法相信大家都懂，我就不写了)...\n\n面试官：你好像有点紧张啊，我问的是原理，你给我答怎么清除浮动？\n\n我：(中间我还答了些有的没的这里就省略了)哦！`overflow:hidden`创建了`BFC`利用`BFC`计算高度的时候浮动元素也要计算在内。`:after`是利用了父元素必须把非浮动元素的位置考虑进去(支支吾吾的答完了这题)。\n\n面试官：怎么创建`BFC`？\n\n我：`overflow:hidden`，`visibility`不为`visible`，定位(其实是`position`为`absolute`或`fixed`);\n\n面试官：你平时都用哪些自动化工具，都用它们的什么插件？\n\n我：用`gulp`像图片压缩，js、css压缩合并，文件连接，`bable`，`js-hit`。\n\n面试官：这样吧，我给你发一个设计图过去，你把它还原成网页...(省略)。\n\n不久，面试官给我发来了设计图，于是我就开始做了，第二天这样给面试官发过去了。没想到面试官当天就给我回信给我点评了一些不足，还说可以不用做这么快的(这让我万万没想到啊，还有点评)，于是我又按照点评改了改，再在此之上加了些优化，过了两天给面试官发过去了。大概等了1,2个星期没音，我以为是跪了。没想到又过了几天面试官给我打电话邀请我到搜狐大厦去面试(超高兴，能去参观参观大厂，去那面试)。\n\n按照约定时间我来到了搜狐网络大厦(本来想提前15分钟这样到的，没想到突然犯路痴，结果刚好是约定的时间到)...省略一些有的没的，直接进入面试吧：\n\n面试官：自我介绍下吧。\n\n我：balabala\n\n面试官：如何实现左边图片右边文字的布局，都是不定宽的。\n\n我：(省略一些有的没的回答)给它们都加上浮动。\n\n面试官：这样不行\n\n我：（惊讶脸）啊！不行？！我现在暂时想不到其他方法了。\n\n面试官：不考虑浏览器兼容性呢？\n\n我：啊！可以用`flex`，后面还balabala一些有的没的让面试官对答案不满意了，其实在父容器加个`display:flex`就得了。\n\n中间一些项目的问答。\n\n面试官：你平时切图切出来的图片都保存为什么格式，为什么？\n\n我：保存为png-24，因为它比较小(这里答得不理想啊，应该是png压缩后比jpg小，而且png是无损压缩，jpg是有损压缩)\n\n面试官：你平时有没有用过什么工具来提高的的开发效率？\n\n我：(和上面电话面试的回答差不多)\n\n面试官可能是看上面我的回答不怎么好于是拿出几道js题给我做。\n\n第一题大概是这样的(考察作用域)：\n```javascript\nvar a=1;\nfunction fun(a){\n    var a=b=2;\n    return function e(){\n        var c=3\n    }\n}\nvar d=fun(a);\nconsole.log(a,b,typeof c,typeof d,typeof e)\n```\n\n题目大概是这样，记不太清了，做出来以后和面试官解释为什么会这样。\n答案是：1 2 undefined function undefined，至于为什么会这样我就不多说了，稍微有点基础的同学应该能一眼看出来。\n\n第二题：给不支持es5的浏览器写一个Array，prototype.map：\n\n答案：\n```javascript\nif(!Array，prototype.map){\n    Array，prototype.map=function(fn){\n        var len=this.length,\n            i=0,\n            result=[];\n        for(;i<len;i++){\n        \tresult.push(fn.call(this,this[i],i,this));\n        }\n    }\n    return result;\n}\n```\n\n### 去哪儿\n\n#### 一面\n\n项目的一些问答\n\n面试官：ajax的过程\n\n我：先打开请求的地址，然后发送请求，然后处理数据并将数据反馈到页面。\n\n面试官：假设我有一个ul，里面有好多个li，我如何知道用户点了哪个？\n\n我：在ul上绑一个点击事件，利用回调函数的e参数的target获取用户点的li，然后获取这个ul里面的li用slice转为真正的数组，调用数组的indexOf(e.target)就知道用户点了哪个\n\n代码：\n```javascript\nvar ul=document.getElementById('ul'),\n    li=ul.getElementsByTagName('li');\n    ul.addEventListener('click',function(e){\n        console.log([].slice.call(li).indexOf(e.target));\n    });\n```\n\n面试官：如果我li里面套了一个span，这个时候我又怎么知道用户点了第几个span\n\n我：直接把上面的li换成span\n\n面试官：你知不知道这个时候的`e.currentTarget`指向谁，为什么？\n\n我：ul，因为`e.currentTarget`指的是当前被绑定事件的元素。\n\n面试官：new的过程\n\n我：首先会新创建一个对象，然后将构造函数的`prototype`赋值给新创建对象的`__proto__`，将构造函数的`this`指向这个对象，并执行构造函数里的代码，最后判断返回值(如果返回值是简单数据类型直接返回新创建的对象，如果是复杂数据类型会返回这个复杂数据类型)\n\n面试官：Promise的三个状态？\n\n我：pedding resolve reject...(省略)\n\n面试官：实现继承的方法？\n\n我：(回来在写这篇文章的时候翻看发现自己答得不是很理想)，可以看看高程的162-173页的继承。\n\n面试官：http的状态码常用的有哪些？\n\n我：(这个我就不打在这了，问题太过于简单)贴个[链接](http://www.cnblogs.com/loveyakamoz/archive/2011/09/03/2165266.html)\n\n面试官：我现在第一次载入这个网页以后按刷新，这个时候会出现哪些状态码？\n\n我：(我觉得面试官应该是问缓存会出现哪些状态码)于是我就答200(from memory cache) 和304，并和面试官解释这两个的差异；前者是直接从cache里面获取后者是向服务端发出确认没变然后再从cache里面取的。\n\n面试官：假如现在我有一个数组[1,2,3,4,5,6,7,9]我想知道8应该在数组的哪个位置该怎么做？\n\n我：把这个8`push`到数组里，排序，然后indexOf(8)\n\n面试官：还有更好的办法吗？\n\n我：没了(寻求更好的办法)。\n\n面试官：css的优先级是怎么样的？\n\n我：important>id>class>element然后，内嵌>内联>外联\n\n面试官：我css有两个类c1和c2，他们内部分别定义了`background-color:red`和`background-color:green`把它们同时加到一个div上，这个时候他们的背景颜色是什么颜色？\n\n我：这个取决于这两个类在css文件中定义的位置了，谁靠后就取谁的颜色。\n\n面试官：我先定义c1在定义c2\n\n我：那就是green了\n\n面试官：如果我给这个div外面再套个div这个div类名为box，我在css文件中修改c1为`.box .c1`，这个时候颜色是啥？\n\n我：那就是red了(为什么会这样就不用我多说了，相信大家都知道)\n\n有了解过AMD/CMD、commonJS吗\n\n我：(回答的大致意思在[这里](http://www.jianshu.com/p/d67bc79976e6))\n\n一面下来感觉就是碾压，问的东西非常基础，面试官看起来也特别满意，于是就让我去二面。\n\n#### 二面\n\n上来就让我手写快排，还好之前有复习，不过久没写字了，写得比较慢，最后没写完，不过我和面试官讲解了思路，面试官看起来貌似蛮满意。\n\n面试官：你给我介绍一些网络的知识吧。\n\n我：balabala。\n\n面试官：网络七层协议？\n\n我：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层\n\n面试官：你操作系统怎么样？\n\n我：这方面比较弱。\n\n面试官：你给我介绍一下多进程和死锁吧。\n\n我：...\n\n面试官：如何证明node是单线程的？\n\n我：给两段代码中间加个循环次数特别多的循环(这个问题没回答好，可以参考《了不起的Node js 将JavaScript进行到底》27页的例子)\n\n```javascript\nvar start=Date.now();\nsetTimeout(function(){\n    console.log(Date.now()-start);\n    for(var i=0;i<1000000000;i++){}\n},1000);\nsetTimeout(function(){\n    console.log(Date.now()-start);\n},2000);\n```\n\n面试官：最近有学什么新技术吗？\n\n我：es6、了解了es7的async await还有最新的清除浮动的方法[display:flow-root](http://www.w3cplus.com/css3/display-flow-root.html)\n\n接下来的一些问题记不太清了。。总之，二面被虐得很惨。","slug":"Interview in Beijing in April","published":1,"updated":"2020-04-07T03:29:17.929Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8qzc34500072cl6p763v83e","content":"<p>此次面试之旅虽然只面试了两家，但是在这其中学到了蛮多同时也意识到了自己的很多不足。</p>\n<p>以下面试情况都是凭着记忆中的印象写的，面试的问题要比我写的多，我就写些印象深刻的。</p>\n<a id=\"more\"></a>\n<h3 id=\"搜狗\"><a href=\"#搜狗\" class=\"headerlink\" title=\"搜狗\"></a>搜狗</h3><p>感觉能拿到搜狗的面试机会个人觉得有运气也有实力吧。刚开始先是在拉钩上投了搜狗的这个前端重构师这个职位(这个职位注重html,css基础)，没过几天搜狗就给我打电话来了，那时还是中午，我在午休，突然接到一个电话说是搜狗的。当时我吓得脑子一片空白(出现这个情况的原因是身为一个末流二本的学生居然这么快接到了大公司的面试。爱情来的太快就像龙卷风，让我防不胜防)。稍微整理好心情以后(当时还在没睡醒的状态)，面试官开始问我一些基础问题：</p>\n<p>面试官：清除浮动的原理</p>\n<p>睡眼朦胧的我(答了怎么清除浮动)：我常用的有两种方法一种是<code>overflow:hidden</code>还有一种就是用<code>:after</code>清除浮动(这个方法相信大家都懂，我就不写了)…</p>\n<p>面试官：你好像有点紧张啊，我问的是原理，你给我答怎么清除浮动？</p>\n<p>我：(中间我还答了些有的没的这里就省略了)哦！<code>overflow:hidden</code>创建了<code>BFC</code>利用<code>BFC</code>计算高度的时候浮动元素也要计算在内。<code>:after</code>是利用了父元素必须把非浮动元素的位置考虑进去(支支吾吾的答完了这题)。</p>\n<p>面试官：怎么创建<code>BFC</code>？</p>\n<p>我：<code>overflow:hidden</code>，<code>visibility</code>不为<code>visible</code>，定位(其实是<code>position</code>为<code>absolute</code>或<code>fixed</code>);</p>\n<p>面试官：你平时都用哪些自动化工具，都用它们的什么插件？</p>\n<p>我：用<code>gulp</code>像图片压缩，js、css压缩合并，文件连接，<code>bable</code>，<code>js-hit</code>。</p>\n<p>面试官：这样吧，我给你发一个设计图过去，你把它还原成网页…(省略)。</p>\n<p>不久，面试官给我发来了设计图，于是我就开始做了，第二天这样给面试官发过去了。没想到面试官当天就给我回信给我点评了一些不足，还说可以不用做这么快的(这让我万万没想到啊，还有点评)，于是我又按照点评改了改，再在此之上加了些优化，过了两天给面试官发过去了。大概等了1,2个星期没音，我以为是跪了。没想到又过了几天面试官给我打电话邀请我到搜狐大厦去面试(超高兴，能去参观参观大厂，去那面试)。</p>\n<p>按照约定时间我来到了搜狐网络大厦(本来想提前15分钟这样到的，没想到突然犯路痴，结果刚好是约定的时间到)…省略一些有的没的，直接进入面试吧：</p>\n<p>面试官：自我介绍下吧。</p>\n<p>我：balabala</p>\n<p>面试官：如何实现左边图片右边文字的布局，都是不定宽的。</p>\n<p>我：(省略一些有的没的回答)给它们都加上浮动。</p>\n<p>面试官：这样不行</p>\n<p>我：（惊讶脸）啊！不行？！我现在暂时想不到其他方法了。</p>\n<p>面试官：不考虑浏览器兼容性呢？</p>\n<p>我：啊！可以用<code>flex</code>，后面还balabala一些有的没的让面试官对答案不满意了，其实在父容器加个<code>display:flex</code>就得了。</p>\n<p>中间一些项目的问答。</p>\n<p>面试官：你平时切图切出来的图片都保存为什么格式，为什么？</p>\n<p>我：保存为png-24，因为它比较小(这里答得不理想啊，应该是png压缩后比jpg小，而且png是无损压缩，jpg是有损压缩)</p>\n<p>面试官：你平时有没有用过什么工具来提高的的开发效率？</p>\n<p>我：(和上面电话面试的回答差不多)</p>\n<p>面试官可能是看上面我的回答不怎么好于是拿出几道js题给我做。</p>\n<p>第一题大概是这样的(考察作用域)：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a=b=<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">e</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> c=<span class=\"number\">3</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> d=fun(a);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a,b,<span class=\"keyword\">typeof</span> c,<span class=\"keyword\">typeof</span> d,<span class=\"keyword\">typeof</span> e)</span><br></pre></td></tr></table></figure></p>\n<p>题目大概是这样，记不太清了，做出来以后和面试官解释为什么会这样。<br>答案是：1 2 undefined function undefined，至于为什么会这样我就不多说了，稍微有点基础的同学应该能一眼看出来。</p>\n<p>第二题：给不支持es5的浏览器写一个Array，prototype.map：</p>\n<p>答案：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!<span class=\"built_in\">Array</span>，prototype.map)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Array</span>，prototype.map=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> len=<span class=\"keyword\">this</span>.length,</span><br><span class=\"line\">            i=<span class=\"number\">0</span>,</span><br><span class=\"line\">            result=[];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(;i&lt;len;i++)&#123;</span><br><span class=\"line\">        \tresult.push(fn.call(<span class=\"keyword\">this</span>,<span class=\"keyword\">this</span>[i],i,<span class=\"keyword\">this</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"去哪儿\"><a href=\"#去哪儿\" class=\"headerlink\" title=\"去哪儿\"></a>去哪儿</h3><h4 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h4><p>项目的一些问答</p>\n<p>面试官：ajax的过程</p>\n<p>我：先打开请求的地址，然后发送请求，然后处理数据并将数据反馈到页面。</p>\n<p>面试官：假设我有一个ul，里面有好多个li，我如何知道用户点了哪个？</p>\n<p>我：在ul上绑一个点击事件，利用回调函数的e参数的target获取用户点的li，然后获取这个ul里面的li用slice转为真正的数组，调用数组的indexOf(e.target)就知道用户点了哪个</p>\n<p>代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ul=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'ul'</span>),</span><br><span class=\"line\">    li=ul.getElementsByTagName(<span class=\"string\">'li'</span>);</span><br><span class=\"line\">    ul.addEventListener(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log([].slice.call(li).indexOf(e.target));</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>面试官：如果我li里面套了一个span，这个时候我又怎么知道用户点了第几个span</p>\n<p>我：直接把上面的li换成span</p>\n<p>面试官：你知不知道这个时候的<code>e.currentTarget</code>指向谁，为什么？</p>\n<p>我：ul，因为<code>e.currentTarget</code>指的是当前被绑定事件的元素。</p>\n<p>面试官：new的过程</p>\n<p>我：首先会新创建一个对象，然后将构造函数的<code>prototype</code>赋值给新创建对象的<code>__proto__</code>，将构造函数的<code>this</code>指向这个对象，并执行构造函数里的代码，最后判断返回值(如果返回值是简单数据类型直接返回新创建的对象，如果是复杂数据类型会返回这个复杂数据类型)</p>\n<p>面试官：Promise的三个状态？</p>\n<p>我：pedding resolve reject…(省略)</p>\n<p>面试官：实现继承的方法？</p>\n<p>我：(回来在写这篇文章的时候翻看发现自己答得不是很理想)，可以看看高程的162-173页的继承。</p>\n<p>面试官：http的状态码常用的有哪些？</p>\n<p>我：(这个我就不打在这了，问题太过于简单)贴个<a href=\"http://www.cnblogs.com/loveyakamoz/archive/2011/09/03/2165266.html\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<p>面试官：我现在第一次载入这个网页以后按刷新，这个时候会出现哪些状态码？</p>\n<p>我：(我觉得面试官应该是问缓存会出现哪些状态码)于是我就答200(from memory cache) 和304，并和面试官解释这两个的差异；前者是直接从cache里面获取后者是向服务端发出确认没变然后再从cache里面取的。</p>\n<p>面试官：假如现在我有一个数组[1,2,3,4,5,6,7,9]我想知道8应该在数组的哪个位置该怎么做？</p>\n<p>我：把这个8<code>push</code>到数组里，排序，然后indexOf(8)</p>\n<p>面试官：还有更好的办法吗？</p>\n<p>我：没了(寻求更好的办法)。</p>\n<p>面试官：css的优先级是怎么样的？</p>\n<p>我：important&gt;id&gt;class&gt;element然后，内嵌&gt;内联&gt;外联</p>\n<p>面试官：我css有两个类c1和c2，他们内部分别定义了<code>background-color:red</code>和<code>background-color:green</code>把它们同时加到一个div上，这个时候他们的背景颜色是什么颜色？</p>\n<p>我：这个取决于这两个类在css文件中定义的位置了，谁靠后就取谁的颜色。</p>\n<p>面试官：我先定义c1在定义c2</p>\n<p>我：那就是green了</p>\n<p>面试官：如果我给这个div外面再套个div这个div类名为box，我在css文件中修改c1为<code>.box .c1</code>，这个时候颜色是啥？</p>\n<p>我：那就是red了(为什么会这样就不用我多说了，相信大家都知道)</p>\n<p>有了解过AMD/CMD、commonJS吗</p>\n<p>我：(回答的大致意思在<a href=\"http://www.jianshu.com/p/d67bc79976e6\" target=\"_blank\" rel=\"noopener\">这里</a>)</p>\n<p>一面下来感觉就是碾压，问的东西非常基础，面试官看起来也特别满意，于是就让我去二面。</p>\n<h4 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h4><p>上来就让我手写快排，还好之前有复习，不过久没写字了，写得比较慢，最后没写完，不过我和面试官讲解了思路，面试官看起来貌似蛮满意。</p>\n<p>面试官：你给我介绍一些网络的知识吧。</p>\n<p>我：balabala。</p>\n<p>面试官：网络七层协议？</p>\n<p>我：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>\n<p>面试官：你操作系统怎么样？</p>\n<p>我：这方面比较弱。</p>\n<p>面试官：你给我介绍一下多进程和死锁吧。</p>\n<p>我：…</p>\n<p>面试官：如何证明node是单线程的？</p>\n<p>我：给两段代码中间加个循环次数特别多的循环(这个问题没回答好，可以参考《了不起的Node js 将JavaScript进行到底》27页的例子)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> start=<span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Date</span>.now()-start);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">1000000000</span>;i++)&#123;&#125;</span><br><span class=\"line\">&#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Date</span>.now()-start);</span><br><span class=\"line\">&#125;,<span class=\"number\">2000</span>);</span><br></pre></td></tr></table></figure>\n<p>面试官：最近有学什么新技术吗？</p>\n<p>我：es6、了解了es7的async await还有最新的清除浮动的方法<a href=\"http://www.w3cplus.com/css3/display-flow-root.html\" target=\"_blank\" rel=\"noopener\">display:flow-root</a></p>\n<p>接下来的一些问题记不太清了。。总之，二面被虐得很惨。</p>\n","site":{"data":{}},"excerpt":"<p>此次面试之旅虽然只面试了两家，但是在这其中学到了蛮多同时也意识到了自己的很多不足。</p>\n<p>以下面试情况都是凭着记忆中的印象写的，面试的问题要比我写的多，我就写些印象深刻的。</p>","more":"<h3 id=\"搜狗\"><a href=\"#搜狗\" class=\"headerlink\" title=\"搜狗\"></a>搜狗</h3><p>感觉能拿到搜狗的面试机会个人觉得有运气也有实力吧。刚开始先是在拉钩上投了搜狗的这个前端重构师这个职位(这个职位注重html,css基础)，没过几天搜狗就给我打电话来了，那时还是中午，我在午休，突然接到一个电话说是搜狗的。当时我吓得脑子一片空白(出现这个情况的原因是身为一个末流二本的学生居然这么快接到了大公司的面试。爱情来的太快就像龙卷风，让我防不胜防)。稍微整理好心情以后(当时还在没睡醒的状态)，面试官开始问我一些基础问题：</p>\n<p>面试官：清除浮动的原理</p>\n<p>睡眼朦胧的我(答了怎么清除浮动)：我常用的有两种方法一种是<code>overflow:hidden</code>还有一种就是用<code>:after</code>清除浮动(这个方法相信大家都懂，我就不写了)…</p>\n<p>面试官：你好像有点紧张啊，我问的是原理，你给我答怎么清除浮动？</p>\n<p>我：(中间我还答了些有的没的这里就省略了)哦！<code>overflow:hidden</code>创建了<code>BFC</code>利用<code>BFC</code>计算高度的时候浮动元素也要计算在内。<code>:after</code>是利用了父元素必须把非浮动元素的位置考虑进去(支支吾吾的答完了这题)。</p>\n<p>面试官：怎么创建<code>BFC</code>？</p>\n<p>我：<code>overflow:hidden</code>，<code>visibility</code>不为<code>visible</code>，定位(其实是<code>position</code>为<code>absolute</code>或<code>fixed</code>);</p>\n<p>面试官：你平时都用哪些自动化工具，都用它们的什么插件？</p>\n<p>我：用<code>gulp</code>像图片压缩，js、css压缩合并，文件连接，<code>bable</code>，<code>js-hit</code>。</p>\n<p>面试官：这样吧，我给你发一个设计图过去，你把它还原成网页…(省略)。</p>\n<p>不久，面试官给我发来了设计图，于是我就开始做了，第二天这样给面试官发过去了。没想到面试官当天就给我回信给我点评了一些不足，还说可以不用做这么快的(这让我万万没想到啊，还有点评)，于是我又按照点评改了改，再在此之上加了些优化，过了两天给面试官发过去了。大概等了1,2个星期没音，我以为是跪了。没想到又过了几天面试官给我打电话邀请我到搜狐大厦去面试(超高兴，能去参观参观大厂，去那面试)。</p>\n<p>按照约定时间我来到了搜狐网络大厦(本来想提前15分钟这样到的，没想到突然犯路痴，结果刚好是约定的时间到)…省略一些有的没的，直接进入面试吧：</p>\n<p>面试官：自我介绍下吧。</p>\n<p>我：balabala</p>\n<p>面试官：如何实现左边图片右边文字的布局，都是不定宽的。</p>\n<p>我：(省略一些有的没的回答)给它们都加上浮动。</p>\n<p>面试官：这样不行</p>\n<p>我：（惊讶脸）啊！不行？！我现在暂时想不到其他方法了。</p>\n<p>面试官：不考虑浏览器兼容性呢？</p>\n<p>我：啊！可以用<code>flex</code>，后面还balabala一些有的没的让面试官对答案不满意了，其实在父容器加个<code>display:flex</code>就得了。</p>\n<p>中间一些项目的问答。</p>\n<p>面试官：你平时切图切出来的图片都保存为什么格式，为什么？</p>\n<p>我：保存为png-24，因为它比较小(这里答得不理想啊，应该是png压缩后比jpg小，而且png是无损压缩，jpg是有损压缩)</p>\n<p>面试官：你平时有没有用过什么工具来提高的的开发效率？</p>\n<p>我：(和上面电话面试的回答差不多)</p>\n<p>面试官可能是看上面我的回答不怎么好于是拿出几道js题给我做。</p>\n<p>第一题大概是这样的(考察作用域)：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a=b=<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">e</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> c=<span class=\"number\">3</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> d=fun(a);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a,b,<span class=\"keyword\">typeof</span> c,<span class=\"keyword\">typeof</span> d,<span class=\"keyword\">typeof</span> e)</span><br></pre></td></tr></table></figure></p>\n<p>题目大概是这样，记不太清了，做出来以后和面试官解释为什么会这样。<br>答案是：1 2 undefined function undefined，至于为什么会这样我就不多说了，稍微有点基础的同学应该能一眼看出来。</p>\n<p>第二题：给不支持es5的浏览器写一个Array，prototype.map：</p>\n<p>答案：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!<span class=\"built_in\">Array</span>，prototype.map)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Array</span>，prototype.map=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> len=<span class=\"keyword\">this</span>.length,</span><br><span class=\"line\">            i=<span class=\"number\">0</span>,</span><br><span class=\"line\">            result=[];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(;i&lt;len;i++)&#123;</span><br><span class=\"line\">        \tresult.push(fn.call(<span class=\"keyword\">this</span>,<span class=\"keyword\">this</span>[i],i,<span class=\"keyword\">this</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"去哪儿\"><a href=\"#去哪儿\" class=\"headerlink\" title=\"去哪儿\"></a>去哪儿</h3><h4 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h4><p>项目的一些问答</p>\n<p>面试官：ajax的过程</p>\n<p>我：先打开请求的地址，然后发送请求，然后处理数据并将数据反馈到页面。</p>\n<p>面试官：假设我有一个ul，里面有好多个li，我如何知道用户点了哪个？</p>\n<p>我：在ul上绑一个点击事件，利用回调函数的e参数的target获取用户点的li，然后获取这个ul里面的li用slice转为真正的数组，调用数组的indexOf(e.target)就知道用户点了哪个</p>\n<p>代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ul=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'ul'</span>),</span><br><span class=\"line\">    li=ul.getElementsByTagName(<span class=\"string\">'li'</span>);</span><br><span class=\"line\">    ul.addEventListener(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log([].slice.call(li).indexOf(e.target));</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>面试官：如果我li里面套了一个span，这个时候我又怎么知道用户点了第几个span</p>\n<p>我：直接把上面的li换成span</p>\n<p>面试官：你知不知道这个时候的<code>e.currentTarget</code>指向谁，为什么？</p>\n<p>我：ul，因为<code>e.currentTarget</code>指的是当前被绑定事件的元素。</p>\n<p>面试官：new的过程</p>\n<p>我：首先会新创建一个对象，然后将构造函数的<code>prototype</code>赋值给新创建对象的<code>__proto__</code>，将构造函数的<code>this</code>指向这个对象，并执行构造函数里的代码，最后判断返回值(如果返回值是简单数据类型直接返回新创建的对象，如果是复杂数据类型会返回这个复杂数据类型)</p>\n<p>面试官：Promise的三个状态？</p>\n<p>我：pedding resolve reject…(省略)</p>\n<p>面试官：实现继承的方法？</p>\n<p>我：(回来在写这篇文章的时候翻看发现自己答得不是很理想)，可以看看高程的162-173页的继承。</p>\n<p>面试官：http的状态码常用的有哪些？</p>\n<p>我：(这个我就不打在这了，问题太过于简单)贴个<a href=\"http://www.cnblogs.com/loveyakamoz/archive/2011/09/03/2165266.html\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<p>面试官：我现在第一次载入这个网页以后按刷新，这个时候会出现哪些状态码？</p>\n<p>我：(我觉得面试官应该是问缓存会出现哪些状态码)于是我就答200(from memory cache) 和304，并和面试官解释这两个的差异；前者是直接从cache里面获取后者是向服务端发出确认没变然后再从cache里面取的。</p>\n<p>面试官：假如现在我有一个数组[1,2,3,4,5,6,7,9]我想知道8应该在数组的哪个位置该怎么做？</p>\n<p>我：把这个8<code>push</code>到数组里，排序，然后indexOf(8)</p>\n<p>面试官：还有更好的办法吗？</p>\n<p>我：没了(寻求更好的办法)。</p>\n<p>面试官：css的优先级是怎么样的？</p>\n<p>我：important&gt;id&gt;class&gt;element然后，内嵌&gt;内联&gt;外联</p>\n<p>面试官：我css有两个类c1和c2，他们内部分别定义了<code>background-color:red</code>和<code>background-color:green</code>把它们同时加到一个div上，这个时候他们的背景颜色是什么颜色？</p>\n<p>我：这个取决于这两个类在css文件中定义的位置了，谁靠后就取谁的颜色。</p>\n<p>面试官：我先定义c1在定义c2</p>\n<p>我：那就是green了</p>\n<p>面试官：如果我给这个div外面再套个div这个div类名为box，我在css文件中修改c1为<code>.box .c1</code>，这个时候颜色是啥？</p>\n<p>我：那就是red了(为什么会这样就不用我多说了，相信大家都知道)</p>\n<p>有了解过AMD/CMD、commonJS吗</p>\n<p>我：(回答的大致意思在<a href=\"http://www.jianshu.com/p/d67bc79976e6\" target=\"_blank\" rel=\"noopener\">这里</a>)</p>\n<p>一面下来感觉就是碾压，问的东西非常基础，面试官看起来也特别满意，于是就让我去二面。</p>\n<h4 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h4><p>上来就让我手写快排，还好之前有复习，不过久没写字了，写得比较慢，最后没写完，不过我和面试官讲解了思路，面试官看起来貌似蛮满意。</p>\n<p>面试官：你给我介绍一些网络的知识吧。</p>\n<p>我：balabala。</p>\n<p>面试官：网络七层协议？</p>\n<p>我：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>\n<p>面试官：你操作系统怎么样？</p>\n<p>我：这方面比较弱。</p>\n<p>面试官：你给我介绍一下多进程和死锁吧。</p>\n<p>我：…</p>\n<p>面试官：如何证明node是单线程的？</p>\n<p>我：给两段代码中间加个循环次数特别多的循环(这个问题没回答好，可以参考《了不起的Node js 将JavaScript进行到底》27页的例子)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> start=<span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Date</span>.now()-start);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">1000000000</span>;i++)&#123;&#125;</span><br><span class=\"line\">&#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Date</span>.now()-start);</span><br><span class=\"line\">&#125;,<span class=\"number\">2000</span>);</span><br></pre></td></tr></table></figure>\n<p>面试官：最近有学什么新技术吗？</p>\n<p>我：es6、了解了es7的async await还有最新的清除浮动的方法<a href=\"http://www.w3cplus.com/css3/display-flow-root.html\" target=\"_blank\" rel=\"noopener\">display:flow-root</a></p>\n<p>接下来的一些问题记不太清了。。总之，二面被虐得很惨。</p>"},{"title":"angular学习笔记(2)","date":"2016-10-14T00:05:20.000Z","_content":"\n# angular学习笔记(2)\n\n这里接着上一篇继续写笔记，废话不多说，直接进入正题……\n\n# angular的服务\n\n上篇文章说到，不要去试图复用`controller`。但是如果两个`controller`中有相同的功能该怎么办？\n\n这个时候服务就起到作用了。angular内置有很多服务给我们使用，当然也可以给我们自定义服务。\n\n<!-- more-->\n\n## $http服务\n\n$http服务是angular中使用得最频繁的服务，因为前台要不断和后台交互，所以$http使用得最频繁的一个服务。\n\nHTML：\n\n    <div ng-controller=\"myController\">\n        <ul>\n            <li ng-repeat=\"data in datas\">{{data.data}}</li>\n        </ul>\n    </div>\n    \nJS：\n\n    myApp.controller(\"myController\",[\"$scope\",\"$http\",function($scope,$http){\n        $http({\n            method:\"GET\",\n            url:\"dataUrl\"\n        }).success(function(data,status){\n            $scope.datas=data;\n        }).error(function(data,status){\n            consloe.log(\"error\")\n        });\n    }]);\n\n模拟的数据：\n\n    [\n        {\n            \"data\":\"1\"\n        },\n        {\n            \"data\":\"2\"\n        },\n        {\n            \"data\":\"3\"\n        }\n    ]\n\n这样就会在页面输出：\n\n    ·1\n    ·2\n    ·3\n\n这个和jquery的`$.ajax`方法很相似,[这个是$http的API](https://docs.angularjs.org/api/ng/service/$http)，嘿嘿~。\n\n## $filter服务\n\n`$filte`也是angular中比较常用的服务，angular内置了9个filter分别是：currency(货币)，date(日期)，json(将数据转化为json)，lowercase(小写)，number(数字)，orderBy(排序)，uppercase(大写)，limitTo(限定字符串或者数组长度)。\n\nfilter可以嵌套使用(使用管道符号|分隔)。\n\n    <p>{{time| date:\"y-M-d H-m-s\"}}</p>\n\n例如上面这个会在页面输出年、月、日、时、分、秒。\n\n## 自定义过滤器\n\n这里用上面的http的例子：\n\nHTML改为：\n\n    <div ng-controller=\"myController\">\n        <ul>\n            <li ng-repeat=\"data in datas | myFilter\">{{data.data}}</li>\n        </ul>\n    </div>\n\nJS中添加：\n\n    myApp.filter(\"myFilter\", function () {\n            return function (obj) {\n                var newObj = [];\n                angular.forEach(obj, function (obj) {\n                    if (obj.data.indexOf(\"1\") !== -1) {\n                        newObj.push(obj);\n                    }\n                });\n                return newObj;\n            }\n        });\n\n上面代码执行完以后会在页面打印出：\n\n    ·1\n    \n当然，还有一种方法是在`$scope`上定义一个方法用作过滤器：\n\nHTML：\n\n        <div ng-controller=\"myController\">\n            <ul>\n                <li ng-repeat=\"data in datas | filter: myFilter\">{{data.data}}</li>\n            </ul>\n        </div>\n\nJS：\n\n    myApp.filter(\"myFilter\", function () {\n            return function (obj) {\n                var newObj = [];\n                angular.forEach(obj, function (obj) {\n                    if (obj.data.indexOf(\"1\") !== -1) {\n                        newObj.push(obj);\n                    }\n                });\n                return newObj;\n            }\n            $scope.myFilter=function(obj){\n                if (obj.data.indexOf(\"1\") !== -1) {\n                        return true;\n                    }\n                return false;\n            }\n        });\n        \n这样也可以得到同样的结果。\n\n当然，还有其他方法，在这我就不一一列举了。\n\n## 自定义服务\n\n在angular中有三种方法自定义服务，分别是`$provide.provider`，`factory`，`server`，这些方法的本质都是`provider`，只不过是后面两种方法将`$provide.provider`封装了一下，让我们使用起来更方便。\n\nHTML：\n\n    <div ng-controller=\"myController\"></div>\n\nJS:\n\n    var myApp = angular.module(\"myApp\", [], [\"$provide\",function ($provide) {\n            $provide.provider(\"myServer\", function () {\n                this.$get = function () {\n                    return function () {\n                        console.log(\"myServer\");\n                    }\n                }\n            });\n            \n            $provide.factory(\"myServer2\",function(){\n               return function(){\n                   console.log(\"myServer2\");\n               } \n            });\n            \n            $provide.service(\"myServer3\",function(){\n               return function(){\n                   console.log(\"myServer3\");\n               } \n            });         \n        }]);\n    \n    myApp.controller(\"myController\",[\"$scope\",\"myServer\",\"myServer2\",\"myServer3\",function($scope,myServer,myServer2,myServer3){\n        myServer();\n        myServer2();\n        myServer3();\n    }]);\n    \n在上面，用三种方法创建了三个服务，运行以后在控制台会输出*myServer*、*myServer2*、*myServer3*。下面两个方法虽然写法一样，但是还是有些不同的，`factory`能返回所有数据类型的数据，而`service`只能返回对象或者应用类型的数据，例如：`service`不能直接返回字符串。\n\n后面两种快捷方法可以不用写在回调函数里面，可以写成：\n\n    myApp.factory(\"serverName\",function(){\n        return ...\n    });\n    myApp.service(\"serverName\",function(){\n        return ...\n    });\n    \n## 路由\n\nangular提供了一个路由的功能用于改变视图。只要链接改变，就可以改变相应的视图。如果需要使用得通过npm把*angular-router*从网上下下来。\n\n使用的时候需要先注册：\n\n    var myApp = angular.module(\"myApp\", ['ngRoute']); \n    \n完以后就可以使用了，首先，主html文件里面加上：\n\n    <div ng-view></div>\n    \n*1.html*文件上(文件名可以随意取，文件内容也可以自己定)：\n\n    <ul>\n        <li ng-repeat=\"t in texts\"></li>\n    </ul>\n    \n*2.html*：\n\n    <h1>我是标题</h1>\n    <p ng-bind=\"text\"></p>\n\nJS：\n\n    myApp.controller(\"helloCtrl\",[\"$scope\",function($scope){\n            $scope.texts=[\"hello world\",\"hello angular\"];\n        }]);\n        \n    myApp.controller(\"textCtrl\",[\"$scope\",function($scope){\n            $scope.text=\"我是内容\";\n        }]);\n\n    /*路由的配置*/\n    myApp.config(function($routeProvider){\n        $routerProvider.when(\"/hello\",{\n            templateUrl:\"1.html\",\n            controller:\"helloCtrl\"\n        }).when(\"/text\",{\n            templateUrl:\"2.html\",\n            controller:\"textCtrl\"\n        }).otherwise({\n            redirectTo:\"/hello\"\n        })\n    });\n    \n从上面的js文件的配置可以看出，当地址栏输入`/hello`结尾的当前服务器地址时会将`1.html`里的内容放到主html文件的`<div ng-view></div>`内，当输入`/text`时就是`2.html`，其他的都默认为以`/hello`结尾，下面的控制器是必不可少的，用于控制相应的视图。\n\n如果细心观察，会发现地址栏上的`/`前面会有个`#`，这个是为了防止浏览器向后台发送请求。\n\nangular自带的路由有个缺陷，就是不能进行深层的嵌套路由。深层的嵌套路由就是路由里面还有路由。\n\n不过，有个第三方的angular插件填补了这个缺陷，那就是[ui-router](https://ui-router.github.io/)，这个插件也得用npm下载：`npm i angular-ui-router`\n\n使用时，也需要像angular-router一样那样注册：\n\n    var myApp = angular.module(\"myApp\", ['ui.router']);\n    \n主html改为：\n\n    <div ui-view></div>\n\n1.html：\n\n    <h1>1 page</h1>\n    <p>1</p>\n    <div ui-view=\"home\"></div>\n\nhome.html：\n\n    <hr>\n    <h1>home page</h1>\n    <a ui-sref=\"link\">link</a>\n    \nlink.html：\n\n    <h1>link page</h1>\n    \nJS：\n\n    myApp.config(function($stateProvider,$urlRouterProvider){\n        $urlRouterProvider.otherwise(\"/index\");\n        $stateProvider.state(\"index\",{\n            url:\"/index\",\n            views:{\n                \"\":{\n                    templateUrl:\"1.html\"\n                },\n                \"home@index\":{\n                    templateUrl:\"home.html\"\n                }\n            }\n        }).state(\"link\",{\n            url:\"/link\",\n            views:{\n                \"\":{\n                    templateUrl:\"link.html\"\n                }\n            }\n        });\n    });\n    \n从js的配置可以看出，打开页面默认是以`/index`结尾的视图。\n\n打开页面可以看到*1.html*的内容(一个标题，一段文字)，*1.html*里面又嵌套了一个*home.html*的视图(一条线，一个标题，一个链接)，链接点开后会转到*link.html*的视图(一个标题)。\n\n**tip**：`home@index`的`home`代表主页面嵌套视图里面的`ui-view`的值，a链接里的`ui-sref`的值代表`state`的第一个参数。","source":"_posts/angular Study notes-2.md","raw":"---\ntitle: angular学习笔记(2)\ndate: 2016-10-14 8:05:20\ntags: [angular,基础]\n---\n\n# angular学习笔记(2)\n\n这里接着上一篇继续写笔记，废话不多说，直接进入正题……\n\n# angular的服务\n\n上篇文章说到，不要去试图复用`controller`。但是如果两个`controller`中有相同的功能该怎么办？\n\n这个时候服务就起到作用了。angular内置有很多服务给我们使用，当然也可以给我们自定义服务。\n\n<!-- more-->\n\n## $http服务\n\n$http服务是angular中使用得最频繁的服务，因为前台要不断和后台交互，所以$http使用得最频繁的一个服务。\n\nHTML：\n\n    <div ng-controller=\"myController\">\n        <ul>\n            <li ng-repeat=\"data in datas\">{{data.data}}</li>\n        </ul>\n    </div>\n    \nJS：\n\n    myApp.controller(\"myController\",[\"$scope\",\"$http\",function($scope,$http){\n        $http({\n            method:\"GET\",\n            url:\"dataUrl\"\n        }).success(function(data,status){\n            $scope.datas=data;\n        }).error(function(data,status){\n            consloe.log(\"error\")\n        });\n    }]);\n\n模拟的数据：\n\n    [\n        {\n            \"data\":\"1\"\n        },\n        {\n            \"data\":\"2\"\n        },\n        {\n            \"data\":\"3\"\n        }\n    ]\n\n这样就会在页面输出：\n\n    ·1\n    ·2\n    ·3\n\n这个和jquery的`$.ajax`方法很相似,[这个是$http的API](https://docs.angularjs.org/api/ng/service/$http)，嘿嘿~。\n\n## $filter服务\n\n`$filte`也是angular中比较常用的服务，angular内置了9个filter分别是：currency(货币)，date(日期)，json(将数据转化为json)，lowercase(小写)，number(数字)，orderBy(排序)，uppercase(大写)，limitTo(限定字符串或者数组长度)。\n\nfilter可以嵌套使用(使用管道符号|分隔)。\n\n    <p>{{time| date:\"y-M-d H-m-s\"}}</p>\n\n例如上面这个会在页面输出年、月、日、时、分、秒。\n\n## 自定义过滤器\n\n这里用上面的http的例子：\n\nHTML改为：\n\n    <div ng-controller=\"myController\">\n        <ul>\n            <li ng-repeat=\"data in datas | myFilter\">{{data.data}}</li>\n        </ul>\n    </div>\n\nJS中添加：\n\n    myApp.filter(\"myFilter\", function () {\n            return function (obj) {\n                var newObj = [];\n                angular.forEach(obj, function (obj) {\n                    if (obj.data.indexOf(\"1\") !== -1) {\n                        newObj.push(obj);\n                    }\n                });\n                return newObj;\n            }\n        });\n\n上面代码执行完以后会在页面打印出：\n\n    ·1\n    \n当然，还有一种方法是在`$scope`上定义一个方法用作过滤器：\n\nHTML：\n\n        <div ng-controller=\"myController\">\n            <ul>\n                <li ng-repeat=\"data in datas | filter: myFilter\">{{data.data}}</li>\n            </ul>\n        </div>\n\nJS：\n\n    myApp.filter(\"myFilter\", function () {\n            return function (obj) {\n                var newObj = [];\n                angular.forEach(obj, function (obj) {\n                    if (obj.data.indexOf(\"1\") !== -1) {\n                        newObj.push(obj);\n                    }\n                });\n                return newObj;\n            }\n            $scope.myFilter=function(obj){\n                if (obj.data.indexOf(\"1\") !== -1) {\n                        return true;\n                    }\n                return false;\n            }\n        });\n        \n这样也可以得到同样的结果。\n\n当然，还有其他方法，在这我就不一一列举了。\n\n## 自定义服务\n\n在angular中有三种方法自定义服务，分别是`$provide.provider`，`factory`，`server`，这些方法的本质都是`provider`，只不过是后面两种方法将`$provide.provider`封装了一下，让我们使用起来更方便。\n\nHTML：\n\n    <div ng-controller=\"myController\"></div>\n\nJS:\n\n    var myApp = angular.module(\"myApp\", [], [\"$provide\",function ($provide) {\n            $provide.provider(\"myServer\", function () {\n                this.$get = function () {\n                    return function () {\n                        console.log(\"myServer\");\n                    }\n                }\n            });\n            \n            $provide.factory(\"myServer2\",function(){\n               return function(){\n                   console.log(\"myServer2\");\n               } \n            });\n            \n            $provide.service(\"myServer3\",function(){\n               return function(){\n                   console.log(\"myServer3\");\n               } \n            });         \n        }]);\n    \n    myApp.controller(\"myController\",[\"$scope\",\"myServer\",\"myServer2\",\"myServer3\",function($scope,myServer,myServer2,myServer3){\n        myServer();\n        myServer2();\n        myServer3();\n    }]);\n    \n在上面，用三种方法创建了三个服务，运行以后在控制台会输出*myServer*、*myServer2*、*myServer3*。下面两个方法虽然写法一样，但是还是有些不同的，`factory`能返回所有数据类型的数据，而`service`只能返回对象或者应用类型的数据，例如：`service`不能直接返回字符串。\n\n后面两种快捷方法可以不用写在回调函数里面，可以写成：\n\n    myApp.factory(\"serverName\",function(){\n        return ...\n    });\n    myApp.service(\"serverName\",function(){\n        return ...\n    });\n    \n## 路由\n\nangular提供了一个路由的功能用于改变视图。只要链接改变，就可以改变相应的视图。如果需要使用得通过npm把*angular-router*从网上下下来。\n\n使用的时候需要先注册：\n\n    var myApp = angular.module(\"myApp\", ['ngRoute']); \n    \n完以后就可以使用了，首先，主html文件里面加上：\n\n    <div ng-view></div>\n    \n*1.html*文件上(文件名可以随意取，文件内容也可以自己定)：\n\n    <ul>\n        <li ng-repeat=\"t in texts\"></li>\n    </ul>\n    \n*2.html*：\n\n    <h1>我是标题</h1>\n    <p ng-bind=\"text\"></p>\n\nJS：\n\n    myApp.controller(\"helloCtrl\",[\"$scope\",function($scope){\n            $scope.texts=[\"hello world\",\"hello angular\"];\n        }]);\n        \n    myApp.controller(\"textCtrl\",[\"$scope\",function($scope){\n            $scope.text=\"我是内容\";\n        }]);\n\n    /*路由的配置*/\n    myApp.config(function($routeProvider){\n        $routerProvider.when(\"/hello\",{\n            templateUrl:\"1.html\",\n            controller:\"helloCtrl\"\n        }).when(\"/text\",{\n            templateUrl:\"2.html\",\n            controller:\"textCtrl\"\n        }).otherwise({\n            redirectTo:\"/hello\"\n        })\n    });\n    \n从上面的js文件的配置可以看出，当地址栏输入`/hello`结尾的当前服务器地址时会将`1.html`里的内容放到主html文件的`<div ng-view></div>`内，当输入`/text`时就是`2.html`，其他的都默认为以`/hello`结尾，下面的控制器是必不可少的，用于控制相应的视图。\n\n如果细心观察，会发现地址栏上的`/`前面会有个`#`，这个是为了防止浏览器向后台发送请求。\n\nangular自带的路由有个缺陷，就是不能进行深层的嵌套路由。深层的嵌套路由就是路由里面还有路由。\n\n不过，有个第三方的angular插件填补了这个缺陷，那就是[ui-router](https://ui-router.github.io/)，这个插件也得用npm下载：`npm i angular-ui-router`\n\n使用时，也需要像angular-router一样那样注册：\n\n    var myApp = angular.module(\"myApp\", ['ui.router']);\n    \n主html改为：\n\n    <div ui-view></div>\n\n1.html：\n\n    <h1>1 page</h1>\n    <p>1</p>\n    <div ui-view=\"home\"></div>\n\nhome.html：\n\n    <hr>\n    <h1>home page</h1>\n    <a ui-sref=\"link\">link</a>\n    \nlink.html：\n\n    <h1>link page</h1>\n    \nJS：\n\n    myApp.config(function($stateProvider,$urlRouterProvider){\n        $urlRouterProvider.otherwise(\"/index\");\n        $stateProvider.state(\"index\",{\n            url:\"/index\",\n            views:{\n                \"\":{\n                    templateUrl:\"1.html\"\n                },\n                \"home@index\":{\n                    templateUrl:\"home.html\"\n                }\n            }\n        }).state(\"link\",{\n            url:\"/link\",\n            views:{\n                \"\":{\n                    templateUrl:\"link.html\"\n                }\n            }\n        });\n    });\n    \n从js的配置可以看出，打开页面默认是以`/index`结尾的视图。\n\n打开页面可以看到*1.html*的内容(一个标题，一段文字)，*1.html*里面又嵌套了一个*home.html*的视图(一条线，一个标题，一个链接)，链接点开后会转到*link.html*的视图(一个标题)。\n\n**tip**：`home@index`的`home`代表主页面嵌套视图里面的`ui-view`的值，a链接里的`ui-sref`的值代表`state`的第一个参数。","slug":"angular Study notes-2","published":1,"updated":"2020-04-07T03:29:17.932Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8qzc34700082cl6y0pkn4ow","content":"<h1 id=\"angular学习笔记-2\"><a href=\"#angular学习笔记-2\" class=\"headerlink\" title=\"angular学习笔记(2)\"></a>angular学习笔记(2)</h1><p>这里接着上一篇继续写笔记，废话不多说，直接进入正题……</p>\n<h1 id=\"angular的服务\"><a href=\"#angular的服务\" class=\"headerlink\" title=\"angular的服务\"></a>angular的服务</h1><p>上篇文章说到，不要去试图复用<code>controller</code>。但是如果两个<code>controller</code>中有相同的功能该怎么办？</p>\n<p>这个时候服务就起到作用了。angular内置有很多服务给我们使用，当然也可以给我们自定义服务。</p>\n<a id=\"more\"></a>\n<h2 id=\"http服务\"><a href=\"#http服务\" class=\"headerlink\" title=\"$http服务\"></a>$http服务</h2><p>$http服务是angular中使用得最频繁的服务，因为前台要不断和后台交互，所以$http使用得最频繁的一个服务。</p>\n<p>HTML：</p>\n<pre><code>&lt;div ng-controller=&quot;myController&quot;&gt;\n    &lt;ul&gt;\n        &lt;li ng-repeat=&quot;data in datas&quot;&gt;{{data.data}}&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.controller(&quot;myController&quot;,[&quot;$scope&quot;,&quot;$http&quot;,function($scope,$http){\n    $http({\n        method:&quot;GET&quot;,\n        url:&quot;dataUrl&quot;\n    }).success(function(data,status){\n        $scope.datas=data;\n    }).error(function(data,status){\n        consloe.log(&quot;error&quot;)\n    });\n}]);\n</code></pre><p>模拟的数据：</p>\n<pre><code>[\n    {\n        &quot;data&quot;:&quot;1&quot;\n    },\n    {\n        &quot;data&quot;:&quot;2&quot;\n    },\n    {\n        &quot;data&quot;:&quot;3&quot;\n    }\n]\n</code></pre><p>这样就会在页面输出：</p>\n<pre><code>·1\n·2\n·3\n</code></pre><p>这个和jquery的<code>$.ajax</code>方法很相似,<a href=\"https://docs.angularjs.org/api/ng/service/$http\" target=\"_blank\" rel=\"noopener\">这个是$http的API</a>，嘿嘿~。</p>\n<h2 id=\"filter服务\"><a href=\"#filter服务\" class=\"headerlink\" title=\"$filter服务\"></a>$filter服务</h2><p><code>$filte</code>也是angular中比较常用的服务，angular内置了9个filter分别是：currency(货币)，date(日期)，json(将数据转化为json)，lowercase(小写)，number(数字)，orderBy(排序)，uppercase(大写)，limitTo(限定字符串或者数组长度)。</p>\n<p>filter可以嵌套使用(使用管道符号|分隔)。</p>\n<pre><code>&lt;p&gt;{{time| date:\"y-M-d H-m-s\"}}&lt;/p&gt;\n</code></pre><p>例如上面这个会在页面输出年、月、日、时、分、秒。</p>\n<h2 id=\"自定义过滤器\"><a href=\"#自定义过滤器\" class=\"headerlink\" title=\"自定义过滤器\"></a>自定义过滤器</h2><p>这里用上面的http的例子：</p>\n<p>HTML改为：</p>\n<pre><code>&lt;div ng-controller=&quot;myController&quot;&gt;\n    &lt;ul&gt;\n        &lt;li ng-repeat=&quot;data in datas | myFilter&quot;&gt;{{data.data}}&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre><p>JS中添加：</p>\n<pre><code>myApp.filter(&quot;myFilter&quot;, function () {\n        return function (obj) {\n            var newObj = [];\n            angular.forEach(obj, function (obj) {\n                if (obj.data.indexOf(&quot;1&quot;) !== -1) {\n                    newObj.push(obj);\n                }\n            });\n            return newObj;\n        }\n    });\n</code></pre><p>上面代码执行完以后会在页面打印出：</p>\n<pre><code>·1\n</code></pre><p>当然，还有一种方法是在<code>$scope</code>上定义一个方法用作过滤器：</p>\n<p>HTML：</p>\n<pre><code>&lt;div ng-controller=&quot;myController&quot;&gt;\n    &lt;ul&gt;\n        &lt;li ng-repeat=&quot;data in datas | filter: myFilter&quot;&gt;{{data.data}}&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.filter(&quot;myFilter&quot;, function () {\n        return function (obj) {\n            var newObj = [];\n            angular.forEach(obj, function (obj) {\n                if (obj.data.indexOf(&quot;1&quot;) !== -1) {\n                    newObj.push(obj);\n                }\n            });\n            return newObj;\n        }\n        $scope.myFilter=function(obj){\n            if (obj.data.indexOf(&quot;1&quot;) !== -1) {\n                    return true;\n                }\n            return false;\n        }\n    });\n</code></pre><p>这样也可以得到同样的结果。</p>\n<p>当然，还有其他方法，在这我就不一一列举了。</p>\n<h2 id=\"自定义服务\"><a href=\"#自定义服务\" class=\"headerlink\" title=\"自定义服务\"></a>自定义服务</h2><p>在angular中有三种方法自定义服务，分别是<code>$provide.provider</code>，<code>factory</code>，<code>server</code>，这些方法的本质都是<code>provider</code>，只不过是后面两种方法将<code>$provide.provider</code>封装了一下，让我们使用起来更方便。</p>\n<p>HTML：</p>\n<pre><code>&lt;div ng-controller=&quot;myController&quot;&gt;&lt;/div&gt;\n</code></pre><p>JS:</p>\n<pre><code>var myApp = angular.module(&quot;myApp&quot;, [], [&quot;$provide&quot;,function ($provide) {\n        $provide.provider(&quot;myServer&quot;, function () {\n            this.$get = function () {\n                return function () {\n                    console.log(&quot;myServer&quot;);\n                }\n            }\n        });\n\n        $provide.factory(&quot;myServer2&quot;,function(){\n           return function(){\n               console.log(&quot;myServer2&quot;);\n           } \n        });\n\n        $provide.service(&quot;myServer3&quot;,function(){\n           return function(){\n               console.log(&quot;myServer3&quot;);\n           } \n        });         \n    }]);\n\nmyApp.controller(&quot;myController&quot;,[&quot;$scope&quot;,&quot;myServer&quot;,&quot;myServer2&quot;,&quot;myServer3&quot;,function($scope,myServer,myServer2,myServer3){\n    myServer();\n    myServer2();\n    myServer3();\n}]);\n</code></pre><p>在上面，用三种方法创建了三个服务，运行以后在控制台会输出<em>myServer</em>、<em>myServer2</em>、<em>myServer3</em>。下面两个方法虽然写法一样，但是还是有些不同的，<code>factory</code>能返回所有数据类型的数据，而<code>service</code>只能返回对象或者应用类型的数据，例如：<code>service</code>不能直接返回字符串。</p>\n<p>后面两种快捷方法可以不用写在回调函数里面，可以写成：</p>\n<pre><code>myApp.factory(&quot;serverName&quot;,function(){\n    return ...\n});\nmyApp.service(&quot;serverName&quot;,function(){\n    return ...\n});\n</code></pre><h2 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h2><p>angular提供了一个路由的功能用于改变视图。只要链接改变，就可以改变相应的视图。如果需要使用得通过npm把<em>angular-router</em>从网上下下来。</p>\n<p>使用的时候需要先注册：</p>\n<pre><code>var myApp = angular.module(&quot;myApp&quot;, [&apos;ngRoute&apos;]); \n</code></pre><p>完以后就可以使用了，首先，主html文件里面加上：</p>\n<pre><code>&lt;div ng-view&gt;&lt;/div&gt;\n</code></pre><p><em>1.html</em>文件上(文件名可以随意取，文件内容也可以自己定)：</p>\n<pre><code>&lt;ul&gt;\n    &lt;li ng-repeat=&quot;t in texts&quot;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre><p><em>2.html</em>：</p>\n<pre><code>&lt;h1&gt;我是标题&lt;/h1&gt;\n&lt;p ng-bind=&quot;text&quot;&gt;&lt;/p&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.controller(&quot;helloCtrl&quot;,[&quot;$scope&quot;,function($scope){\n        $scope.texts=[&quot;hello world&quot;,&quot;hello angular&quot;];\n    }]);\n\nmyApp.controller(&quot;textCtrl&quot;,[&quot;$scope&quot;,function($scope){\n        $scope.text=&quot;我是内容&quot;;\n    }]);\n\n/*路由的配置*/\nmyApp.config(function($routeProvider){\n    $routerProvider.when(&quot;/hello&quot;,{\n        templateUrl:&quot;1.html&quot;,\n        controller:&quot;helloCtrl&quot;\n    }).when(&quot;/text&quot;,{\n        templateUrl:&quot;2.html&quot;,\n        controller:&quot;textCtrl&quot;\n    }).otherwise({\n        redirectTo:&quot;/hello&quot;\n    })\n});\n</code></pre><p>从上面的js文件的配置可以看出，当地址栏输入<code>/hello</code>结尾的当前服务器地址时会将<code>1.html</code>里的内容放到主html文件的<code>&lt;div ng-view&gt;&lt;/div&gt;</code>内，当输入<code>/text</code>时就是<code>2.html</code>，其他的都默认为以<code>/hello</code>结尾，下面的控制器是必不可少的，用于控制相应的视图。</p>\n<p>如果细心观察，会发现地址栏上的<code>/</code>前面会有个<code>#</code>，这个是为了防止浏览器向后台发送请求。</p>\n<p>angular自带的路由有个缺陷，就是不能进行深层的嵌套路由。深层的嵌套路由就是路由里面还有路由。</p>\n<p>不过，有个第三方的angular插件填补了这个缺陷，那就是<a href=\"https://ui-router.github.io/\" target=\"_blank\" rel=\"noopener\">ui-router</a>，这个插件也得用npm下载：<code>npm i angular-ui-router</code></p>\n<p>使用时，也需要像angular-router一样那样注册：</p>\n<pre><code>var myApp = angular.module(&quot;myApp&quot;, [&apos;ui.router&apos;]);\n</code></pre><p>主html改为：</p>\n<pre><code>&lt;div ui-view&gt;&lt;/div&gt;\n</code></pre><p>1.html：</p>\n<pre><code>&lt;h1&gt;1 page&lt;/h1&gt;\n&lt;p&gt;1&lt;/p&gt;\n&lt;div ui-view=&quot;home&quot;&gt;&lt;/div&gt;\n</code></pre><p>home.html：</p>\n<pre><code>&lt;hr&gt;\n&lt;h1&gt;home page&lt;/h1&gt;\n&lt;a ui-sref=&quot;link&quot;&gt;link&lt;/a&gt;\n</code></pre><p>link.html：</p>\n<pre><code>&lt;h1&gt;link page&lt;/h1&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.config(function($stateProvider,$urlRouterProvider){\n    $urlRouterProvider.otherwise(&quot;/index&quot;);\n    $stateProvider.state(&quot;index&quot;,{\n        url:&quot;/index&quot;,\n        views:{\n            &quot;&quot;:{\n                templateUrl:&quot;1.html&quot;\n            },\n            &quot;home@index&quot;:{\n                templateUrl:&quot;home.html&quot;\n            }\n        }\n    }).state(&quot;link&quot;,{\n        url:&quot;/link&quot;,\n        views:{\n            &quot;&quot;:{\n                templateUrl:&quot;link.html&quot;\n            }\n        }\n    });\n});\n</code></pre><p>从js的配置可以看出，打开页面默认是以<code>/index</code>结尾的视图。</p>\n<p>打开页面可以看到<em>1.html</em>的内容(一个标题，一段文字)，<em>1.html</em>里面又嵌套了一个<em>home.html</em>的视图(一条线，一个标题，一个链接)，链接点开后会转到<em>link.html</em>的视图(一个标题)。</p>\n<p><strong>tip</strong>：<code>home@index</code>的<code>home</code>代表主页面嵌套视图里面的<code>ui-view</code>的值，a链接里的<code>ui-sref</code>的值代表<code>state</code>的第一个参数。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"angular学习笔记-2\"><a href=\"#angular学习笔记-2\" class=\"headerlink\" title=\"angular学习笔记(2)\"></a>angular学习笔记(2)</h1><p>这里接着上一篇继续写笔记，废话不多说，直接进入正题……</p>\n<h1 id=\"angular的服务\"><a href=\"#angular的服务\" class=\"headerlink\" title=\"angular的服务\"></a>angular的服务</h1><p>上篇文章说到，不要去试图复用<code>controller</code>。但是如果两个<code>controller</code>中有相同的功能该怎么办？</p>\n<p>这个时候服务就起到作用了。angular内置有很多服务给我们使用，当然也可以给我们自定义服务。</p>","more":"<h2 id=\"http服务\"><a href=\"#http服务\" class=\"headerlink\" title=\"$http服务\"></a>$http服务</h2><p>$http服务是angular中使用得最频繁的服务，因为前台要不断和后台交互，所以$http使用得最频繁的一个服务。</p>\n<p>HTML：</p>\n<pre><code>&lt;div ng-controller=&quot;myController&quot;&gt;\n    &lt;ul&gt;\n        &lt;li ng-repeat=&quot;data in datas&quot;&gt;{{data.data}}&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.controller(&quot;myController&quot;,[&quot;$scope&quot;,&quot;$http&quot;,function($scope,$http){\n    $http({\n        method:&quot;GET&quot;,\n        url:&quot;dataUrl&quot;\n    }).success(function(data,status){\n        $scope.datas=data;\n    }).error(function(data,status){\n        consloe.log(&quot;error&quot;)\n    });\n}]);\n</code></pre><p>模拟的数据：</p>\n<pre><code>[\n    {\n        &quot;data&quot;:&quot;1&quot;\n    },\n    {\n        &quot;data&quot;:&quot;2&quot;\n    },\n    {\n        &quot;data&quot;:&quot;3&quot;\n    }\n]\n</code></pre><p>这样就会在页面输出：</p>\n<pre><code>·1\n·2\n·3\n</code></pre><p>这个和jquery的<code>$.ajax</code>方法很相似,<a href=\"https://docs.angularjs.org/api/ng/service/$http\" target=\"_blank\" rel=\"noopener\">这个是$http的API</a>，嘿嘿~。</p>\n<h2 id=\"filter服务\"><a href=\"#filter服务\" class=\"headerlink\" title=\"$filter服务\"></a>$filter服务</h2><p><code>$filte</code>也是angular中比较常用的服务，angular内置了9个filter分别是：currency(货币)，date(日期)，json(将数据转化为json)，lowercase(小写)，number(数字)，orderBy(排序)，uppercase(大写)，limitTo(限定字符串或者数组长度)。</p>\n<p>filter可以嵌套使用(使用管道符号|分隔)。</p>\n<pre><code>&lt;p&gt;{{time| date:\"y-M-d H-m-s\"}}&lt;/p&gt;\n</code></pre><p>例如上面这个会在页面输出年、月、日、时、分、秒。</p>\n<h2 id=\"自定义过滤器\"><a href=\"#自定义过滤器\" class=\"headerlink\" title=\"自定义过滤器\"></a>自定义过滤器</h2><p>这里用上面的http的例子：</p>\n<p>HTML改为：</p>\n<pre><code>&lt;div ng-controller=&quot;myController&quot;&gt;\n    &lt;ul&gt;\n        &lt;li ng-repeat=&quot;data in datas | myFilter&quot;&gt;{{data.data}}&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre><p>JS中添加：</p>\n<pre><code>myApp.filter(&quot;myFilter&quot;, function () {\n        return function (obj) {\n            var newObj = [];\n            angular.forEach(obj, function (obj) {\n                if (obj.data.indexOf(&quot;1&quot;) !== -1) {\n                    newObj.push(obj);\n                }\n            });\n            return newObj;\n        }\n    });\n</code></pre><p>上面代码执行完以后会在页面打印出：</p>\n<pre><code>·1\n</code></pre><p>当然，还有一种方法是在<code>$scope</code>上定义一个方法用作过滤器：</p>\n<p>HTML：</p>\n<pre><code>&lt;div ng-controller=&quot;myController&quot;&gt;\n    &lt;ul&gt;\n        &lt;li ng-repeat=&quot;data in datas | filter: myFilter&quot;&gt;{{data.data}}&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.filter(&quot;myFilter&quot;, function () {\n        return function (obj) {\n            var newObj = [];\n            angular.forEach(obj, function (obj) {\n                if (obj.data.indexOf(&quot;1&quot;) !== -1) {\n                    newObj.push(obj);\n                }\n            });\n            return newObj;\n        }\n        $scope.myFilter=function(obj){\n            if (obj.data.indexOf(&quot;1&quot;) !== -1) {\n                    return true;\n                }\n            return false;\n        }\n    });\n</code></pre><p>这样也可以得到同样的结果。</p>\n<p>当然，还有其他方法，在这我就不一一列举了。</p>\n<h2 id=\"自定义服务\"><a href=\"#自定义服务\" class=\"headerlink\" title=\"自定义服务\"></a>自定义服务</h2><p>在angular中有三种方法自定义服务，分别是<code>$provide.provider</code>，<code>factory</code>，<code>server</code>，这些方法的本质都是<code>provider</code>，只不过是后面两种方法将<code>$provide.provider</code>封装了一下，让我们使用起来更方便。</p>\n<p>HTML：</p>\n<pre><code>&lt;div ng-controller=&quot;myController&quot;&gt;&lt;/div&gt;\n</code></pre><p>JS:</p>\n<pre><code>var myApp = angular.module(&quot;myApp&quot;, [], [&quot;$provide&quot;,function ($provide) {\n        $provide.provider(&quot;myServer&quot;, function () {\n            this.$get = function () {\n                return function () {\n                    console.log(&quot;myServer&quot;);\n                }\n            }\n        });\n\n        $provide.factory(&quot;myServer2&quot;,function(){\n           return function(){\n               console.log(&quot;myServer2&quot;);\n           } \n        });\n\n        $provide.service(&quot;myServer3&quot;,function(){\n           return function(){\n               console.log(&quot;myServer3&quot;);\n           } \n        });         \n    }]);\n\nmyApp.controller(&quot;myController&quot;,[&quot;$scope&quot;,&quot;myServer&quot;,&quot;myServer2&quot;,&quot;myServer3&quot;,function($scope,myServer,myServer2,myServer3){\n    myServer();\n    myServer2();\n    myServer3();\n}]);\n</code></pre><p>在上面，用三种方法创建了三个服务，运行以后在控制台会输出<em>myServer</em>、<em>myServer2</em>、<em>myServer3</em>。下面两个方法虽然写法一样，但是还是有些不同的，<code>factory</code>能返回所有数据类型的数据，而<code>service</code>只能返回对象或者应用类型的数据，例如：<code>service</code>不能直接返回字符串。</p>\n<p>后面两种快捷方法可以不用写在回调函数里面，可以写成：</p>\n<pre><code>myApp.factory(&quot;serverName&quot;,function(){\n    return ...\n});\nmyApp.service(&quot;serverName&quot;,function(){\n    return ...\n});\n</code></pre><h2 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h2><p>angular提供了一个路由的功能用于改变视图。只要链接改变，就可以改变相应的视图。如果需要使用得通过npm把<em>angular-router</em>从网上下下来。</p>\n<p>使用的时候需要先注册：</p>\n<pre><code>var myApp = angular.module(&quot;myApp&quot;, [&apos;ngRoute&apos;]); \n</code></pre><p>完以后就可以使用了，首先，主html文件里面加上：</p>\n<pre><code>&lt;div ng-view&gt;&lt;/div&gt;\n</code></pre><p><em>1.html</em>文件上(文件名可以随意取，文件内容也可以自己定)：</p>\n<pre><code>&lt;ul&gt;\n    &lt;li ng-repeat=&quot;t in texts&quot;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre><p><em>2.html</em>：</p>\n<pre><code>&lt;h1&gt;我是标题&lt;/h1&gt;\n&lt;p ng-bind=&quot;text&quot;&gt;&lt;/p&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.controller(&quot;helloCtrl&quot;,[&quot;$scope&quot;,function($scope){\n        $scope.texts=[&quot;hello world&quot;,&quot;hello angular&quot;];\n    }]);\n\nmyApp.controller(&quot;textCtrl&quot;,[&quot;$scope&quot;,function($scope){\n        $scope.text=&quot;我是内容&quot;;\n    }]);\n\n/*路由的配置*/\nmyApp.config(function($routeProvider){\n    $routerProvider.when(&quot;/hello&quot;,{\n        templateUrl:&quot;1.html&quot;,\n        controller:&quot;helloCtrl&quot;\n    }).when(&quot;/text&quot;,{\n        templateUrl:&quot;2.html&quot;,\n        controller:&quot;textCtrl&quot;\n    }).otherwise({\n        redirectTo:&quot;/hello&quot;\n    })\n});\n</code></pre><p>从上面的js文件的配置可以看出，当地址栏输入<code>/hello</code>结尾的当前服务器地址时会将<code>1.html</code>里的内容放到主html文件的<code>&lt;div ng-view&gt;&lt;/div&gt;</code>内，当输入<code>/text</code>时就是<code>2.html</code>，其他的都默认为以<code>/hello</code>结尾，下面的控制器是必不可少的，用于控制相应的视图。</p>\n<p>如果细心观察，会发现地址栏上的<code>/</code>前面会有个<code>#</code>，这个是为了防止浏览器向后台发送请求。</p>\n<p>angular自带的路由有个缺陷，就是不能进行深层的嵌套路由。深层的嵌套路由就是路由里面还有路由。</p>\n<p>不过，有个第三方的angular插件填补了这个缺陷，那就是<a href=\"https://ui-router.github.io/\" target=\"_blank\" rel=\"noopener\">ui-router</a>，这个插件也得用npm下载：<code>npm i angular-ui-router</code></p>\n<p>使用时，也需要像angular-router一样那样注册：</p>\n<pre><code>var myApp = angular.module(&quot;myApp&quot;, [&apos;ui.router&apos;]);\n</code></pre><p>主html改为：</p>\n<pre><code>&lt;div ui-view&gt;&lt;/div&gt;\n</code></pre><p>1.html：</p>\n<pre><code>&lt;h1&gt;1 page&lt;/h1&gt;\n&lt;p&gt;1&lt;/p&gt;\n&lt;div ui-view=&quot;home&quot;&gt;&lt;/div&gt;\n</code></pre><p>home.html：</p>\n<pre><code>&lt;hr&gt;\n&lt;h1&gt;home page&lt;/h1&gt;\n&lt;a ui-sref=&quot;link&quot;&gt;link&lt;/a&gt;\n</code></pre><p>link.html：</p>\n<pre><code>&lt;h1&gt;link page&lt;/h1&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.config(function($stateProvider,$urlRouterProvider){\n    $urlRouterProvider.otherwise(&quot;/index&quot;);\n    $stateProvider.state(&quot;index&quot;,{\n        url:&quot;/index&quot;,\n        views:{\n            &quot;&quot;:{\n                templateUrl:&quot;1.html&quot;\n            },\n            &quot;home@index&quot;:{\n                templateUrl:&quot;home.html&quot;\n            }\n        }\n    }).state(&quot;link&quot;,{\n        url:&quot;/link&quot;,\n        views:{\n            &quot;&quot;:{\n                templateUrl:&quot;link.html&quot;\n            }\n        }\n    });\n});\n</code></pre><p>从js的配置可以看出，打开页面默认是以<code>/index</code>结尾的视图。</p>\n<p>打开页面可以看到<em>1.html</em>的内容(一个标题，一段文字)，<em>1.html</em>里面又嵌套了一个<em>home.html</em>的视图(一条线，一个标题，一个链接)，链接点开后会转到<em>link.html</em>的视图(一个标题)。</p>\n<p><strong>tip</strong>：<code>home@index</code>的<code>home</code>代表主页面嵌套视图里面的<code>ui-view</code>的值，a链接里的<code>ui-sref</code>的值代表<code>state</code>的第一个参数。</p>"},{"title":"初尝vue","date":"2016-08-14T02:14:47.000Z","_content":"\n# 初尝vue\n\n因为最近在做一个项目，感觉无从下手。因为老师给了一个漏洞百出的小破系统让我们自己研究做出个一模一样的出来(这里简单的吐槽一下)。在大神的建议下，开始学习vue，下面是我学习的一些笔记。\n\n<!-- more-->\n\n# Hellow World\n\nvue的**hellow world**很简单：  \n\nHTML：\n\n\n    <div id=\"app\">\n        {{message}}\n    </div>\n\n\njs：\n\n\n    new Vue({\n        el: '#app',\n        data: {\n            message: 'Hello Vue.js!'\n                }\n            });\n    \n    \n结果：  \n\n\n    Hello Vue.js!\n\n\n代码通过[el](http://vuejs.org.cn/api/#el)获取到HTML的节点，向节点中的`{{message}}`插入[data](http://vuejs.org.cn/api/#data)里的`message`的值。    \n\n**注意**HTML中的双括号里的名字和`data`里的名字一样\n\n# 双向绑定\n\n双向绑定就是用表单控件的`v-model`指令实现通过表单里的内容改变，来让`data`里的对象值改变，最后体现到页面上： \n\n\n在上面HTML代码的基础上加上： \n\n\n    <input type=\"text\" v-model=\"message\">\n\n\n就可以实现数据的双向绑定\n\n# 渲染列表\n\n直接上代码：  \n\nHTML： \n\n\n    <div id=\"app\">\n        <ul>\n        <li v-for=\"todo in todos\">\n            {{ todo.text }}\n        </li>\n        </ul>\n    </div>\n    \n    \nJS： \n\n\n    new Vue({\n        el: '#app',\n        data: {\n                todos: [\n                    { text: 'Learn JavaScript' },\n                    { text: 'Learn Vue.js' },\n                    { text: 'Build Something Awesome' }\n                        ]\n              }\n              });\n\n\n结果：  \n\n\n    · Learn JavaScript\n    · Learn Vue.js\n    · Build Something Awesome\n\n\n这是用了vue的[v-for](http://vuejs.org.cn/api/#v-for)指令，用来循环渲染出数据。  \n\n这个很像javascript里的`for-in`循环，`in`前面是自己定义的变量，`in`后面是要遍历的数组。这样，在这里通过`todo.text`就能取到`todos`数组里的东西，从而显示到页面上\n\n# 事件监听\n\n在vue中，可以使用指令[v-on](http://vuejs.org.cn/api/#v-on)监控对应的事件，可以缩写为`@`，例如： \n\n\n      <button v-on:click=\"dosomething\">Reverse Message</button>\n\n\n缩写为：\n\n\n    <button @:click=\"dosomething\">Reverse Message</button>\n\n\n实例：  \n\nHTML： \n\n\n    <div id=\"app\">\n        <p>{{ message }}</p>\n        <button @:click=\"reverseMessage\">Reverse Message</button>\n    </div>\n\n\nJS： \n\n\n    new Vue({\n        el: '#app',\n        data: {\n            message: 'Hello Vue.js!'\n        },\n        methods: {\n                reverseMessage: function () {\n                this.message = this.message.split('').reverse().join('')\n                }\n            }\n        });\n\n\n当点击按钮时，Hellow Vue.js!的字母会变成!sj.euV olleH，再点击就会变回来。  \n\n**注意**`methods`是用来放一些函数的，如果要想点击以后发生点什么，就把函数放到`methods`里。\n\n# 综合\n\n下列代码实现了向框里写一些东西后按回车就将框里的东西在下面显示出来，并且点击X按钮会删除对应的信息：  \n\nHTML： \n\n\n    <div id=\"app\">\n        <input v-model=\"newTodo\" v-on:keyup.enter=\"addTodo\">\n        <ul>\n            <li v-for=\"todo in todos\">\n                <span>{{ todo.text }}</span>\n                <button v-on:click=\"removeTodo($index)\">X</button>\n            </li>\n        </ul>\n    </div>\n\n\nJS： \n\n\n    new Vue({\n    el: '#app',\n    data: {\n        newTodo: '',\n        todos: [\n            { text: 'Add some todos' }\n            ]\n    },\n    methods: {\n        addTodo: function () {\n        var text = this.newTodo.trim()\n        if (text) {\n            this.todos.push({ text: text })\n            this.newTodo = ''\n        }\n    },\n      removeTodo: function (index) {\n      this.todos.splice(index, 1)\n    }\n    }\n    });\n\n\n在HTML代码中用到了`v-on:keyup.enter`，这句代码意思是监听回车按钮抬起事件。如果，回车按键抬起则执行后面的方法。下面的`$index`是取得当前列项的索引。  \n\n`addTodo`方法是讲输入框输入的内容两边去掉空格，然后判断是否为空。如果不为空将这个字符串放到`todos`数组里，并且清空输入框。  \n\n`removeTodo`方法是将用户选中的字符串删除。  \n\n当然，在学习中还接触了一些*es6*语法例如：\n\n* const 常量声明\n\n* import 变量 from \"路径\" 和var something=require(\"路径\")方法相似  \n\n以前没见过的的一些东西：\n\n* window.localStorage.getItem(key)，获取本地存储的一些数据。可以这么用： `JSON.parse(window.localStorage.getItem(STORAGE_KEY) || \"[]\")`意思是将获得的东西转化为JSON展示出来。\n\n* window.localStorage.setItem(key,data)，向本地存储一些数据，第一个参数是存储的键值，第二个是数据。可以这么用：`window.localStorage.setItem(key, JSON.stringify(data))`意思是讲数据变为JSON格式存储","source":"_posts/Taste vue.md","raw":"---\ntitle: 初尝vue\ndate: 2016-08-14 10:14:47\ntags: [vue,基础]\n---\n\n# 初尝vue\n\n因为最近在做一个项目，感觉无从下手。因为老师给了一个漏洞百出的小破系统让我们自己研究做出个一模一样的出来(这里简单的吐槽一下)。在大神的建议下，开始学习vue，下面是我学习的一些笔记。\n\n<!-- more-->\n\n# Hellow World\n\nvue的**hellow world**很简单：  \n\nHTML：\n\n\n    <div id=\"app\">\n        {{message}}\n    </div>\n\n\njs：\n\n\n    new Vue({\n        el: '#app',\n        data: {\n            message: 'Hello Vue.js!'\n                }\n            });\n    \n    \n结果：  \n\n\n    Hello Vue.js!\n\n\n代码通过[el](http://vuejs.org.cn/api/#el)获取到HTML的节点，向节点中的`{{message}}`插入[data](http://vuejs.org.cn/api/#data)里的`message`的值。    \n\n**注意**HTML中的双括号里的名字和`data`里的名字一样\n\n# 双向绑定\n\n双向绑定就是用表单控件的`v-model`指令实现通过表单里的内容改变，来让`data`里的对象值改变，最后体现到页面上： \n\n\n在上面HTML代码的基础上加上： \n\n\n    <input type=\"text\" v-model=\"message\">\n\n\n就可以实现数据的双向绑定\n\n# 渲染列表\n\n直接上代码：  \n\nHTML： \n\n\n    <div id=\"app\">\n        <ul>\n        <li v-for=\"todo in todos\">\n            {{ todo.text }}\n        </li>\n        </ul>\n    </div>\n    \n    \nJS： \n\n\n    new Vue({\n        el: '#app',\n        data: {\n                todos: [\n                    { text: 'Learn JavaScript' },\n                    { text: 'Learn Vue.js' },\n                    { text: 'Build Something Awesome' }\n                        ]\n              }\n              });\n\n\n结果：  \n\n\n    · Learn JavaScript\n    · Learn Vue.js\n    · Build Something Awesome\n\n\n这是用了vue的[v-for](http://vuejs.org.cn/api/#v-for)指令，用来循环渲染出数据。  \n\n这个很像javascript里的`for-in`循环，`in`前面是自己定义的变量，`in`后面是要遍历的数组。这样，在这里通过`todo.text`就能取到`todos`数组里的东西，从而显示到页面上\n\n# 事件监听\n\n在vue中，可以使用指令[v-on](http://vuejs.org.cn/api/#v-on)监控对应的事件，可以缩写为`@`，例如： \n\n\n      <button v-on:click=\"dosomething\">Reverse Message</button>\n\n\n缩写为：\n\n\n    <button @:click=\"dosomething\">Reverse Message</button>\n\n\n实例：  \n\nHTML： \n\n\n    <div id=\"app\">\n        <p>{{ message }}</p>\n        <button @:click=\"reverseMessage\">Reverse Message</button>\n    </div>\n\n\nJS： \n\n\n    new Vue({\n        el: '#app',\n        data: {\n            message: 'Hello Vue.js!'\n        },\n        methods: {\n                reverseMessage: function () {\n                this.message = this.message.split('').reverse().join('')\n                }\n            }\n        });\n\n\n当点击按钮时，Hellow Vue.js!的字母会变成!sj.euV olleH，再点击就会变回来。  \n\n**注意**`methods`是用来放一些函数的，如果要想点击以后发生点什么，就把函数放到`methods`里。\n\n# 综合\n\n下列代码实现了向框里写一些东西后按回车就将框里的东西在下面显示出来，并且点击X按钮会删除对应的信息：  \n\nHTML： \n\n\n    <div id=\"app\">\n        <input v-model=\"newTodo\" v-on:keyup.enter=\"addTodo\">\n        <ul>\n            <li v-for=\"todo in todos\">\n                <span>{{ todo.text }}</span>\n                <button v-on:click=\"removeTodo($index)\">X</button>\n            </li>\n        </ul>\n    </div>\n\n\nJS： \n\n\n    new Vue({\n    el: '#app',\n    data: {\n        newTodo: '',\n        todos: [\n            { text: 'Add some todos' }\n            ]\n    },\n    methods: {\n        addTodo: function () {\n        var text = this.newTodo.trim()\n        if (text) {\n            this.todos.push({ text: text })\n            this.newTodo = ''\n        }\n    },\n      removeTodo: function (index) {\n      this.todos.splice(index, 1)\n    }\n    }\n    });\n\n\n在HTML代码中用到了`v-on:keyup.enter`，这句代码意思是监听回车按钮抬起事件。如果，回车按键抬起则执行后面的方法。下面的`$index`是取得当前列项的索引。  \n\n`addTodo`方法是讲输入框输入的内容两边去掉空格，然后判断是否为空。如果不为空将这个字符串放到`todos`数组里，并且清空输入框。  \n\n`removeTodo`方法是将用户选中的字符串删除。  \n\n当然，在学习中还接触了一些*es6*语法例如：\n\n* const 常量声明\n\n* import 变量 from \"路径\" 和var something=require(\"路径\")方法相似  \n\n以前没见过的的一些东西：\n\n* window.localStorage.getItem(key)，获取本地存储的一些数据。可以这么用： `JSON.parse(window.localStorage.getItem(STORAGE_KEY) || \"[]\")`意思是将获得的东西转化为JSON展示出来。\n\n* window.localStorage.setItem(key,data)，向本地存储一些数据，第一个参数是存储的键值，第二个是数据。可以这么用：`window.localStorage.setItem(key, JSON.stringify(data))`意思是讲数据变为JSON格式存储","slug":"Taste vue","published":1,"updated":"2020-04-07T03:29:17.932Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8qzc34a000a2cl6fbr93pij","content":"<h1 id=\"初尝vue\"><a href=\"#初尝vue\" class=\"headerlink\" title=\"初尝vue\"></a>初尝vue</h1><p>因为最近在做一个项目，感觉无从下手。因为老师给了一个漏洞百出的小破系统让我们自己研究做出个一模一样的出来(这里简单的吐槽一下)。在大神的建议下，开始学习vue，下面是我学习的一些笔记。</p>\n<a id=\"more\"></a>\n<h1 id=\"Hellow-World\"><a href=\"#Hellow-World\" class=\"headerlink\" title=\"Hellow World\"></a>Hellow World</h1><p>vue的<strong>hellow world</strong>很简单：  </p>\n<p>HTML：</p>\n<pre><code>&lt;div id=&quot;app&quot;&gt;\n    {{message}}\n&lt;/div&gt;\n</code></pre><p>js：</p>\n<pre><code>new Vue({\n    el: &apos;#app&apos;,\n    data: {\n        message: &apos;Hello Vue.js!&apos;\n            }\n        });\n</code></pre><p>结果：  </p>\n<pre><code>Hello Vue.js!\n</code></pre><p>代码通过<a href=\"http://vuejs.org.cn/api/#el\" target=\"_blank\" rel=\"noopener\">el</a>获取到HTML的节点，向节点中的<code></code>插入<a href=\"http://vuejs.org.cn/api/#data\" target=\"_blank\" rel=\"noopener\">data</a>里的<code>message</code>的值。    </p>\n<p><strong>注意</strong>HTML中的双括号里的名字和<code>data</code>里的名字一样</p>\n<h1 id=\"双向绑定\"><a href=\"#双向绑定\" class=\"headerlink\" title=\"双向绑定\"></a>双向绑定</h1><p>双向绑定就是用表单控件的<code>v-model</code>指令实现通过表单里的内容改变，来让<code>data</code>里的对象值改变，最后体现到页面上： </p>\n<p>在上面HTML代码的基础上加上： </p>\n<pre><code>&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;\n</code></pre><p>就可以实现数据的双向绑定</p>\n<h1 id=\"渲染列表\"><a href=\"#渲染列表\" class=\"headerlink\" title=\"渲染列表\"></a>渲染列表</h1><p>直接上代码：  </p>\n<p>HTML： </p>\n<pre><code>&lt;div id=&quot;app&quot;&gt;\n    &lt;ul&gt;\n    &lt;li v-for=&quot;todo in todos&quot;&gt;\n        {{ todo.text }}\n    &lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre><p>JS： </p>\n<pre><code>new Vue({\n    el: &apos;#app&apos;,\n    data: {\n            todos: [\n                { text: &apos;Learn JavaScript&apos; },\n                { text: &apos;Learn Vue.js&apos; },\n                { text: &apos;Build Something Awesome&apos; }\n                    ]\n          }\n          });\n</code></pre><p>结果：  </p>\n<pre><code>· Learn JavaScript\n· Learn Vue.js\n· Build Something Awesome\n</code></pre><p>这是用了vue的<a href=\"http://vuejs.org.cn/api/#v-for\" target=\"_blank\" rel=\"noopener\">v-for</a>指令，用来循环渲染出数据。  </p>\n<p>这个很像javascript里的<code>for-in</code>循环，<code>in</code>前面是自己定义的变量，<code>in</code>后面是要遍历的数组。这样，在这里通过<code>todo.text</code>就能取到<code>todos</code>数组里的东西，从而显示到页面上</p>\n<h1 id=\"事件监听\"><a href=\"#事件监听\" class=\"headerlink\" title=\"事件监听\"></a>事件监听</h1><p>在vue中，可以使用指令<a href=\"http://vuejs.org.cn/api/#v-on\" target=\"_blank\" rel=\"noopener\">v-on</a>监控对应的事件，可以缩写为<code>@</code>，例如： </p>\n<pre><code>&lt;button v-on:click=&quot;dosomething&quot;&gt;Reverse Message&lt;/button&gt;\n</code></pre><p>缩写为：</p>\n<pre><code>&lt;button @:click=&quot;dosomething&quot;&gt;Reverse Message&lt;/button&gt;\n</code></pre><p>实例：  </p>\n<p>HTML： </p>\n<pre><code>&lt;div id=&quot;app&quot;&gt;\n    &lt;p&gt;{{ message }}&lt;/p&gt;\n    &lt;button @:click=&quot;reverseMessage&quot;&gt;Reverse Message&lt;/button&gt;\n&lt;/div&gt;\n</code></pre><p>JS： </p>\n<pre><code>new Vue({\n    el: &apos;#app&apos;,\n    data: {\n        message: &apos;Hello Vue.js!&apos;\n    },\n    methods: {\n            reverseMessage: function () {\n            this.message = this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)\n            }\n        }\n    });\n</code></pre><p>当点击按钮时，Hellow Vue.js!的字母会变成!sj.euV olleH，再点击就会变回来。  </p>\n<p><strong>注意</strong><code>methods</code>是用来放一些函数的，如果要想点击以后发生点什么，就把函数放到<code>methods</code>里。</p>\n<h1 id=\"综合\"><a href=\"#综合\" class=\"headerlink\" title=\"综合\"></a>综合</h1><p>下列代码实现了向框里写一些东西后按回车就将框里的东西在下面显示出来，并且点击X按钮会删除对应的信息：  </p>\n<p>HTML： </p>\n<pre><code>&lt;div id=&quot;app&quot;&gt;\n    &lt;input v-model=&quot;newTodo&quot; v-on:keyup.enter=&quot;addTodo&quot;&gt;\n    &lt;ul&gt;\n        &lt;li v-for=&quot;todo in todos&quot;&gt;\n            &lt;span&gt;{{ todo.text }}&lt;/span&gt;\n            &lt;button v-on:click=&quot;removeTodo($index)&quot;&gt;X&lt;/button&gt;\n        &lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre><p>JS： </p>\n<pre><code>new Vue({\nel: &apos;#app&apos;,\ndata: {\n    newTodo: &apos;&apos;,\n    todos: [\n        { text: &apos;Add some todos&apos; }\n        ]\n},\nmethods: {\n    addTodo: function () {\n    var text = this.newTodo.trim()\n    if (text) {\n        this.todos.push({ text: text })\n        this.newTodo = &apos;&apos;\n    }\n},\n  removeTodo: function (index) {\n  this.todos.splice(index, 1)\n}\n}\n});\n</code></pre><p>在HTML代码中用到了<code>v-on:keyup.enter</code>，这句代码意思是监听回车按钮抬起事件。如果，回车按键抬起则执行后面的方法。下面的<code>$index</code>是取得当前列项的索引。  </p>\n<p><code>addTodo</code>方法是讲输入框输入的内容两边去掉空格，然后判断是否为空。如果不为空将这个字符串放到<code>todos</code>数组里，并且清空输入框。  </p>\n<p><code>removeTodo</code>方法是将用户选中的字符串删除。  </p>\n<p>当然，在学习中还接触了一些<em>es6</em>语法例如：</p>\n<ul>\n<li><p>const 常量声明</p>\n</li>\n<li><p>import 变量 from “路径” 和var something=require(“路径”)方法相似  </p>\n</li>\n</ul>\n<p>以前没见过的的一些东西：</p>\n<ul>\n<li><p>window.localStorage.getItem(key)，获取本地存储的一些数据。可以这么用： <code>JSON.parse(window.localStorage.getItem(STORAGE_KEY) || &quot;[]&quot;)</code>意思是将获得的东西转化为JSON展示出来。</p>\n</li>\n<li><p>window.localStorage.setItem(key,data)，向本地存储一些数据，第一个参数是存储的键值，第二个是数据。可以这么用：<code>window.localStorage.setItem(key, JSON.stringify(data))</code>意思是讲数据变为JSON格式存储</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"初尝vue\"><a href=\"#初尝vue\" class=\"headerlink\" title=\"初尝vue\"></a>初尝vue</h1><p>因为最近在做一个项目，感觉无从下手。因为老师给了一个漏洞百出的小破系统让我们自己研究做出个一模一样的出来(这里简单的吐槽一下)。在大神的建议下，开始学习vue，下面是我学习的一些笔记。</p>","more":"<h1 id=\"Hellow-World\"><a href=\"#Hellow-World\" class=\"headerlink\" title=\"Hellow World\"></a>Hellow World</h1><p>vue的<strong>hellow world</strong>很简单：  </p>\n<p>HTML：</p>\n<pre><code>&lt;div id=&quot;app&quot;&gt;\n    {{message}}\n&lt;/div&gt;\n</code></pre><p>js：</p>\n<pre><code>new Vue({\n    el: &apos;#app&apos;,\n    data: {\n        message: &apos;Hello Vue.js!&apos;\n            }\n        });\n</code></pre><p>结果：  </p>\n<pre><code>Hello Vue.js!\n</code></pre><p>代码通过<a href=\"http://vuejs.org.cn/api/#el\" target=\"_blank\" rel=\"noopener\">el</a>获取到HTML的节点，向节点中的<code></code>插入<a href=\"http://vuejs.org.cn/api/#data\" target=\"_blank\" rel=\"noopener\">data</a>里的<code>message</code>的值。    </p>\n<p><strong>注意</strong>HTML中的双括号里的名字和<code>data</code>里的名字一样</p>\n<h1 id=\"双向绑定\"><a href=\"#双向绑定\" class=\"headerlink\" title=\"双向绑定\"></a>双向绑定</h1><p>双向绑定就是用表单控件的<code>v-model</code>指令实现通过表单里的内容改变，来让<code>data</code>里的对象值改变，最后体现到页面上： </p>\n<p>在上面HTML代码的基础上加上： </p>\n<pre><code>&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;\n</code></pre><p>就可以实现数据的双向绑定</p>\n<h1 id=\"渲染列表\"><a href=\"#渲染列表\" class=\"headerlink\" title=\"渲染列表\"></a>渲染列表</h1><p>直接上代码：  </p>\n<p>HTML： </p>\n<pre><code>&lt;div id=&quot;app&quot;&gt;\n    &lt;ul&gt;\n    &lt;li v-for=&quot;todo in todos&quot;&gt;\n        {{ todo.text }}\n    &lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre><p>JS： </p>\n<pre><code>new Vue({\n    el: &apos;#app&apos;,\n    data: {\n            todos: [\n                { text: &apos;Learn JavaScript&apos; },\n                { text: &apos;Learn Vue.js&apos; },\n                { text: &apos;Build Something Awesome&apos; }\n                    ]\n          }\n          });\n</code></pre><p>结果：  </p>\n<pre><code>· Learn JavaScript\n· Learn Vue.js\n· Build Something Awesome\n</code></pre><p>这是用了vue的<a href=\"http://vuejs.org.cn/api/#v-for\" target=\"_blank\" rel=\"noopener\">v-for</a>指令，用来循环渲染出数据。  </p>\n<p>这个很像javascript里的<code>for-in</code>循环，<code>in</code>前面是自己定义的变量，<code>in</code>后面是要遍历的数组。这样，在这里通过<code>todo.text</code>就能取到<code>todos</code>数组里的东西，从而显示到页面上</p>\n<h1 id=\"事件监听\"><a href=\"#事件监听\" class=\"headerlink\" title=\"事件监听\"></a>事件监听</h1><p>在vue中，可以使用指令<a href=\"http://vuejs.org.cn/api/#v-on\" target=\"_blank\" rel=\"noopener\">v-on</a>监控对应的事件，可以缩写为<code>@</code>，例如： </p>\n<pre><code>&lt;button v-on:click=&quot;dosomething&quot;&gt;Reverse Message&lt;/button&gt;\n</code></pre><p>缩写为：</p>\n<pre><code>&lt;button @:click=&quot;dosomething&quot;&gt;Reverse Message&lt;/button&gt;\n</code></pre><p>实例：  </p>\n<p>HTML： </p>\n<pre><code>&lt;div id=&quot;app&quot;&gt;\n    &lt;p&gt;{{ message }}&lt;/p&gt;\n    &lt;button @:click=&quot;reverseMessage&quot;&gt;Reverse Message&lt;/button&gt;\n&lt;/div&gt;\n</code></pre><p>JS： </p>\n<pre><code>new Vue({\n    el: &apos;#app&apos;,\n    data: {\n        message: &apos;Hello Vue.js!&apos;\n    },\n    methods: {\n            reverseMessage: function () {\n            this.message = this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)\n            }\n        }\n    });\n</code></pre><p>当点击按钮时，Hellow Vue.js!的字母会变成!sj.euV olleH，再点击就会变回来。  </p>\n<p><strong>注意</strong><code>methods</code>是用来放一些函数的，如果要想点击以后发生点什么，就把函数放到<code>methods</code>里。</p>\n<h1 id=\"综合\"><a href=\"#综合\" class=\"headerlink\" title=\"综合\"></a>综合</h1><p>下列代码实现了向框里写一些东西后按回车就将框里的东西在下面显示出来，并且点击X按钮会删除对应的信息：  </p>\n<p>HTML： </p>\n<pre><code>&lt;div id=&quot;app&quot;&gt;\n    &lt;input v-model=&quot;newTodo&quot; v-on:keyup.enter=&quot;addTodo&quot;&gt;\n    &lt;ul&gt;\n        &lt;li v-for=&quot;todo in todos&quot;&gt;\n            &lt;span&gt;{{ todo.text }}&lt;/span&gt;\n            &lt;button v-on:click=&quot;removeTodo($index)&quot;&gt;X&lt;/button&gt;\n        &lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre><p>JS： </p>\n<pre><code>new Vue({\nel: &apos;#app&apos;,\ndata: {\n    newTodo: &apos;&apos;,\n    todos: [\n        { text: &apos;Add some todos&apos; }\n        ]\n},\nmethods: {\n    addTodo: function () {\n    var text = this.newTodo.trim()\n    if (text) {\n        this.todos.push({ text: text })\n        this.newTodo = &apos;&apos;\n    }\n},\n  removeTodo: function (index) {\n  this.todos.splice(index, 1)\n}\n}\n});\n</code></pre><p>在HTML代码中用到了<code>v-on:keyup.enter</code>，这句代码意思是监听回车按钮抬起事件。如果，回车按键抬起则执行后面的方法。下面的<code>$index</code>是取得当前列项的索引。  </p>\n<p><code>addTodo</code>方法是讲输入框输入的内容两边去掉空格，然后判断是否为空。如果不为空将这个字符串放到<code>todos</code>数组里，并且清空输入框。  </p>\n<p><code>removeTodo</code>方法是将用户选中的字符串删除。  </p>\n<p>当然，在学习中还接触了一些<em>es6</em>语法例如：</p>\n<ul>\n<li><p>const 常量声明</p>\n</li>\n<li><p>import 变量 from “路径” 和var something=require(“路径”)方法相似  </p>\n</li>\n</ul>\n<p>以前没见过的的一些东西：</p>\n<ul>\n<li><p>window.localStorage.getItem(key)，获取本地存储的一些数据。可以这么用： <code>JSON.parse(window.localStorage.getItem(STORAGE_KEY) || &quot;[]&quot;)</code>意思是将获得的东西转化为JSON展示出来。</p>\n</li>\n<li><p>window.localStorage.setItem(key,data)，向本地存储一些数据，第一个参数是存储的键值，第二个是数据。可以这么用：<code>window.localStorage.setItem(key, JSON.stringify(data))</code>意思是讲数据变为JSON格式存储</p>\n</li>\n</ul>"},{"title":"angular学习笔记(3)","date":"2016-10-24T01:51:09.000Z","_content":"\n# angular表单验证\n\nangular自带有一套功能强大的表单验证功能，另外还拓展了一些验证功能(number，url，email，reset)，还能给我们自定义验证方法，用起来特别方便。\n\n首先，先得把bootstrap的样式引进来，这样就不用自己写样式了。\n\n<!-- more-->\n\n## 用户名的验证\n\n直接上代码：\n\n    <div class=\"form-group\" ng-class=\"{'has-error':form.name.$dirty&&form.name.$invalid}\">\n                <label class=\"control-label\">用户名</label>\n                <input autocomplete=\"off\" ng-pattern=\"/^[a-z]/i\" name=\"name\" type=\"name\" ng-model=\"name\" ng-required=\"true\" ng-minlength=\"5\" ng-maxlength=\"10\" class=\"form-control\" placeholder=\"邮箱\">\n                <div ng-show=\"form.name.$dirty&&form.name.$error.minlength\" class=\"alert alert-danger help-block\">\n                    至少5位\n                </div>\n                <div ng-show=\"form.name.$dirty&&form.name.$error.maxlength\" class=\"alert alert-danger help-block\">\n                    最多10位\n                </div>\n                <div ng-show=\"form.name.$dirty&&form.name.$error.pattern\" class=\"alert alert-danger help-block\">\n                    以字母开头\n                </div>\n            </div>\n            \n从上往下看，可以先看到`ng-class`里面有个逻辑表达式，如果`has-error`后面的表达式成立就会用这个class。第一个表达式是`name`值为`form`的表单里的`name`值为`name`的输入框有改动返回的值就为真。第二个是这个输入框有不合法的话返回的值为真。\n\n`ng-pattern`是指用正则验证，如果匹配则下面的`form.name.$error.pattern`就会返回`true`\n\n## 密码和密码确认\n\n    <div class=\"form-group\" ng-class=\"{'has-error':form.password.$dirty&&form.password.$invalid}\">\n                <label class=\"control-label\">密码</label>\n                <input autocomplete=\"off\" name=\"password\" type=\"password\" ng-model=\"password\" ng-required=\"true\" ng-minlength=\"5\" ng-maxlength=\"10\" class=\"form-control\" placeholder=\"密码\">\n                <div ng-show=\"form.password.$dirty&&form.password.$error.minlength\" class=\"alert alert-danger help-block\">\n                    至少5位\n                </div>\n                <div ng-show=\"form.password.$dirty&&form.password.$error.maxlength\" class=\"alert alert-danger help-block\">\n                    最多10位\n                </div>\n            </div>\n            <div class=\"form-group\" ng-class=\"{'has-error':form.passwordConfirm.$dirty&&form.passwordConfirm.$dirty&&form.passwordConfirm.$invalid}\">\n                <label class=\"control-label\">确认密码</label>\n                <input autocomplete=\"off\" name=\"passwordConfirm\" type=\"password\" ng-model=\"passwordConfirm\" ng-required=\"true\" class=\"form-control\" placeholder=\"密码\">\n                <div ng-show=\"form.password.$dirty&&form.passwordConfirm.$dirty&&passwordConfirm!==password\" class=\"alert alert-danger help-block\">\n                    两次不一样\n                </div>\n            </div>\n            \n密码的验证基本没什么特别的，最大长度和最小长度一眼能看出来什么意思。密码的确认那里，如果两个`ng-model`(指的是密码和确认密码的`ng-model`)不相等就返回`false`。\n\n## 邮箱验证\n\n    <div class=\"form-group\" ng-class=\"{'has-error':form.email.$dirty&&form.email.$invalid}\">\n                <label class=\"control-label\">邮箱</label>\n                <input autocomplete=\"off\" name=\"email\" type=\"email\" ng-model=\"email\" ng-required=\"true\" ng-minlength=\"5\" ng-maxlength=\"30\" class=\"form-control\" placeholder=\"邮箱\">\n                <div ng-show=\"form.email.$dirty&&form.email.$error.minlength\" class=\"alert alert-danger help-block\">\n                    至少5位\n                </div>\n                <div ng-show=\"form.email.$dirty&&form.email.$error.maxlength\" class=\"alert alert-danger help-block\">\n                    最多30位\n                </div>\n                <div ng-show=\"form.email.$dirty&&form.email.$error.email\" class=\"alert alert-danger help-block\">\n                    邮箱不对\n                </div>\n            </div>\n\nangular里内置了邮箱的验证，将`input`的`type`改为`email`就行了，错误的返回值用`formName.inputName.$error.email`查看即可，不过个人觉得angular自带的*email*验证还不够完善，如果需要的话可以加个正则验证(`ng-pattern`)，也可以用下面讲到的自定义验证。\n\n## 网址验证\n\n    <div class=\"form-group\" ng-class=\"{'has-error':form.blog.$dirty&&form.blog.$invalid}\">\n                <label class=\"control-label\">博客</label>\n                <input autocomplete=\"off\" name=\"blog\" type=\"url\" ng-model=\"blog\" ng-required=\"true\" ng-minlength=\"5\" ng-maxlength=\"30\" class=\"form-control\" placeholder=\"博客\">\n                <div ng-show=\"form.blog.$dirty&&form.blog.$error.minlength\" class=\"alert alert-danger help-block\">\n                    至少5位\n                </div>\n                <div ng-show=\"form.blog.$dirty&&form.blog.$error.maxlength\" class=\"alert alert-danger help-block\">\n                    最多30位\n                </div>\n                <div ng-show=\"form.blog.$dirty&&form.blog.$error.url\" class=\"alert alert-danger help-block\">\n                    网址不对\n                </div>\n            </div>\n            \nangular里也自带有网址的验证，只需把`input`的`type`改为`url`即可，错误的返回值用`formName.inputName.$error.url`查看。\n\n## 数字验证\n\n    <div class=\"form-group\" ng-class=\"{'has-error':form.age.$dirty&&form.age.$invalid}\">\n                <label class=\"control-label\">年龄</label>\n                <input autocomplete=\"off\" name=\"age\" min=\"0\" max=\"99\" type=\"number\" ng-model=\"age\" ng-required=\"true\" class=\"form-control\" placeholder=\"年龄\">\n                <div ng-show=\"form.age.$dirty&&form.age.$error.min\" class=\"alert alert-danger help-block\">\n                    最小0\n                </div>\n                <div ng-show=\"form.age.$dirty&&form.age.$error.max\" class=\"alert alert-danger help-block\">\n                    最大99\n                </div>\n                <div ng-show=\"form.age.$dirty&&form.age.$error.number\" class=\"alert alert-danger help-block\">\n                    年龄不对\n                </div>\n            </div>\n            \nangular里面也对数字验证进行了拓展，和上面一样，把`type`改为`number`，错误的返回值用`formName.inputName.$error.number`查看。可以在标签上设置属性`min`和`max`来设置最小值和最大值，返回值分别用`formName.inputName.$error.min`，和`formName.inputName.$error.max`查看。\n\n### checkbox\n\nHTML：\n\n    <div class=\"form-group\">\n            <label class=\"label-group\">爱好</label>\n            <label ng-repeat=\"hobby in hobbys\" class=\"checkbox-inline\">\n                <input type=\"checkbox\" ng-checked=\"checked===undefined ? false : checked.indexOf(hobby.id)!==-1\" name=\"hobby\" ng-click=\"toggleSelect(hobby.id)\">{{hobby.name}}\n            </label>\n    </div>\n    \nJS：\n\n    myApp.controller(\"myController\",[\"$scope\",function($scope){\n        $scope.hobbys = [\n        {\n            id: 1,\n            name: \"游戏\"\n        },\n        {\n            id: 2,\n            name: \"游戏2\"\n        },\n        {\n            id: 3,\n            name: \"游戏3\"\n        }\n    ];\n    $scope.checked = [1, 2];\n    $scope.toggleSelect = function (id) {\n        var index = -1;\n        if ($scope.checked === undefined) {\n            $scope.checked = [];\n        } else {\n            index = $scope.checked.indexOf(id);\n        }\n        if (index === -1) {\n            $scope.checked.push(id);\n        } else {\n            $scope.checked.splice(index, 1);\n        }\n    }\n    }]);\n    \n这里的复选框我用了假数据(其实数据应该放在服务里面，我这里为了方便就放控制器里了)，然后用`ng-repeat`循环出来。然后用一个`checked`装已经选上爱好的*id*。下面的`toggleSelect`函数是判断`checked`数组里面是否有传进来的*id*如果没有，就加一个进去否则，删除一个。\n\n## 城市三级关联\n\nHTML：\n\n    <div class=\"form-group\">\n                <label class=\"col-md-1 control-label\">出生地</label>\n                <div class=\"col-md-3\">\n                    <select class=\"form-control\" ng-change=\"area=false\" ng-model=\"city\" ng-options=\"x.id as x.name for x in cities | filterCity:0\"></select>\n                </div>\n                <div ng-show=\"city\" class=\"col-md-3\">\n                    <select class=\"form-control\" ng-model=\"area\" ng-options=\"x.id as x.name for x in cities | filterCity:city\"></select>\n                </div>\n                <div ng-show=\"area&&city\" class=\"col-md-3\">\n                    <select class=\"form-control\" ng-model=\"qu\" ng-options=\"x.id as x.name for x in cities | filterCity:area\"></select>\n                </div>\n    </div>\n\nJS：\n\n     myApp.controller(\"myController\",[\"$scope\",function($scope){\n         $scope.cities = [\n        {\n            name: '上海',\n            parent: 0,\n            id: 1\n            },\n        {\n            name: '上海市',\n            parent: 1,\n            id: 2\n            },\n        {\n            name: '徐汇区',\n            parent: 2,\n            id: 8\n            },\n        {\n            name: '长宁区',\n            parent: 2,\n            id: 3\n            },\n        {\n            name: '北京',\n            parent: 0,\n            id: 4\n            },\n        {\n            name: '北京市',\n            parent: 4,\n            id: 5\n            },\n        {\n            name: '东城区',\n            parent: 5,\n            id: 6\n            },\n        {\n            name: '丰台区',\n            parent: 5,\n            id: 7\n            },\n        {\n            name: '浙江',\n            parent: 0,\n            id: 9\n            },\n        {\n            name: '杭州',\n            parent: 9,\n            id: 100\n            },\n        {\n            name: '宁波',\n            parent: 9,\n            id: 11\n            },\n        {\n            name: '西湖区',\n            parent: 100,\n            id: 12\n            },\n        {\n            name: '北仑区',\n            parent: 11,\n            id: 13\n            }\n        ];\n     }]);\n     myApp.filter(\"filterCity\", function () {\n     return function (city, par) {\n         var filterData = [];\n         angular.forEach(city, function (obj) {\n             if (obj.parent === par) {\n                 filterData.push(obj);\n             }\n         });\n         return filterData;\n     }\n    });\n\n像这样，就做好了城市3级关联。\n\n在HTML中第一个下拉框有个`ng-change=\"area=false`，作用是：当这个下拉框的值改变时，第三个下拉框隐藏。\n\n`ng-options`的作用和`ng-repeat`的作用类似，前者是循环创建*option*选项。可以看到它的值`x.id as x.name for x in cities`。`as`前面的值是*option*的`value`的值，后面的是用户可见的选项，`for`后面的表达式和`ng-repeat`的差不多。\n\n下面的两个下拉框分别用上一个下拉框的`ng-model`值来过滤选项。\n\n有些情况下，这三个单选框需要默认选中某个城市的某个区，这就要根据区来将父级城市选中，这时上面的JS部分增加几行代码变为：\n\n    myApp.controller(\"myController\", [\"$scope\", function ($scope) {\n     $scope.cities = [\n         {\n             name: '上海',\n             parent: 0,\n             id: 1\n            },\n         {\n             name: '上海市',\n             parent: 1,\n             id: 2\n            },\n         {\n             name: '徐汇区',\n             parent: 2,\n             id: 8\n            },\n         {\n             name: '长宁区',\n             parent: 2,\n             id: 3\n            },\n         {\n             name: '北京',\n             parent: 0,\n             id: 4\n            },\n         {\n             name: '北京市',\n             parent: 4,\n             id: 5\n            },\n         {\n             name: '东城区',\n             parent: 5,\n             id: 6\n            },\n         {\n             name: '丰台区',\n             parent: 5,\n             id: 7\n            },\n         {\n             name: '浙江',\n             parent: 0,\n             id: 9\n            },\n         {\n             name: '杭州',\n             parent: 9,\n             id: 100\n            },\n         {\n             name: '宁波',\n             parent: 9,\n             id: 11\n            },\n         {\n             name: '西湖区',\n             parent: 100,\n             id: 12\n            },\n         {\n             name: '北仑区',\n             parent: 11,\n             id: 13\n            }\n        ];\n     $scope.qu = 3;\n     $scope.parentCity = function (id) {\n         var parId;\n         if ($scope.qu !== undefined) {\n             angular.forEach($scope.cities, function (city) {\n                 if (city.id === id) {\n                     parId = city.parent;\n                     return;\n                 }\n             });\n         }\n         return parId;\n     }\n         $scope.area = $scope.parentCity($scope.qu);\n         $scope.city = $scope.parentCity($scope.area);\n     }]);\n     myApp.filter(\"filterCity\", function () {\n         return function (city, par) {\n             var filterData = [];\n             angular.forEach(city, function (obj) {\n                 if (obj.parent === par) {\n                     filterData.push(obj);\n                 }\n             });\n             return filterData;\n         }\n     });\n     \n## 重置\n\nangular的重置和默认的重置又有些不同。angular的重置需要把`model`里的数据也要重置，而默认的重置还做不到这点。\n\n现在在原来的代码基础上将代码改为：\n\nHTML：\n\n            <div class=\"form-group\">\n                <button class=\"btn btn-info\" type=\"reset\" ng-click=\"reset()\">重置</button>\n            </div>\n\nJS：\n\n    myApp.controller(\"myController\", [\"$scope\", function ($scope) {\n     $scope.cities = [\n         {\n             name: '上海',\n             parent: 0,\n             id: 1\n            },\n         {\n             name: '上海市',\n             parent: 1,\n             id: 2\n            },\n         {\n             name: '徐汇区',\n             parent: 2,\n             id: 8\n            },\n         {\n             name: '长宁区',\n             parent: 2,\n             id: 3\n            },\n         {\n             name: '北京',\n             parent: 0,\n             id: 4\n            },\n         {\n             name: '北京市',\n             parent: 4,\n             id: 5\n            },\n         {\n             name: '东城区',\n             parent: 5,\n             id: 6\n            },\n         {\n             name: '丰台区',\n             parent: 5,\n             id: 7\n            },\n         {\n             name: '浙江',\n             parent: 0,\n             id: 9\n            },\n         {\n             name: '杭州',\n             parent: 9,\n             id: 100\n            },\n         {\n             name: '宁波',\n             parent: 9,\n             id: 11\n            },\n         {\n             name: '西湖区',\n             parent: 100,\n             id: 12\n            },\n         {\n             name: '北仑区',\n             parent: 11,\n             id: 13\n            }\n        ];\n     $scope.init = function () {\n         $scope.qu = 3;\n         $scope.parentCity = function (id) {\n             var parId;\n             if ($scope.qu !== undefined) {\n                 angular.forEach($scope.cities, function (city) {\n                     if (city.id === id) {\n                         parId = city.parent;\n                         return;\n                     }\n                 });\n             }\n             return parId;\n         }\n         $scope.area = $scope.parentCity($scope.qu);\n         $scope.city = $scope.parentCity($scope.area);\n         $scope.copyQu = angular.copy($scope.qu);\n     };\n     $scope.reset = function () {\n         $scope.qu = angular.copy($scope.copyQu);\n         $scope.area = $scope.parentCity($scope.qu);\n         $scope.city = $scope.parentCity($scope.area);\n     };\n     $scope.init();\n     }]);\n     myApp.filter(\"filterCity\", function () {\n         return function (city, par) {\n             var filterData = [];\n             angular.forEach(city, function (obj) {\n                 if (obj.parent === par) {\n                     filterData.push(obj);\n                 }\n             });\n             return filterData;\n         }\n     });\n     \n在JS中，我把城市三级关联的初始化放到了一个`init`函数中，并在下面将需要的数据备份，当重置按钮被点下时运行`reset`函数，将三个下拉框的数据重置回来(在重置的时候也用到了copy是为了防止原始值和copy值互相引用，保证了数据的安全)，但是当用户在上面的用户名输入有错误时点击重置会发现下面的错误提示并没有消失，这是因为`$error`没被重置，这个时候，需要在重置函数里加上`$scope.formName.$setPristine();`就可以吧表单恢复为原始的状态，这样重置就完成了。\n     \n## 自定义验证\n\n在前面说了，angular可以自定义验证规则。在用自定义验证规则之前得要知道有个`ngModel`，它可以更深层地处理数据的双向绑定，可以通过设置自定义指令的`require`为`ngModel`取到，并且将`link`函数的第四个参数设置为`ngModelController`\n\nHTML：\n\n    <div class=\"form-group\" ng-class=\"{'has-error':form.even.$dirty&&form.even.$invalid}\">\n                <label class=\"control-label\">偶数</label>\n                <input autocomplete=\"off\" name=\"even\" type=\"number\" ng-model=\"even\" ng-required=\"true\" class=\"form-control\" placeholder=\"偶数\" even>\n                <div ng-show=\"form.even.$dirty&&form.even.$error.even\" class=\"alert alert-danger help-block\">\n                    输入偶数\n                </div>\n    </div>\n\nJS：\n\n    myApp.directive('even', [function () {\n         return {\n             restrict: 'A',\n             require:\"ngModel\",\n             link: function (scope, element, attrs,ngModelController) {\n                 console.log(ngModelController);\n             }\n         };\n         }]);\n\n可以看到在控制台会输出很多属性比如：\n\n    1. $formatters 保存的是从modelValue向viewValue绑定过程中的处理函数\n    2. $setViewValue 当view发生了某件事情时，从view向model绑定调用$setViewValue把viewValue保存下来\n    3. $render 当模型发生变化时，应该怎么去更新视图，从model向view绑定，调用ctrl.$render方法，将viewValue渲染到页面上\n    4. $setValidity 设置验证结果，第一个参数是验证错误的名字，第二个是true or false\n    5. $viewValue 视图的值\n    6. $modelValue 模型里的值\n    7. $parsers保存从viewValue向modelValue绑定过程中的处理函数，它们将来会依次执行\n    \n这样就可以写自定义验证了，接下来，把JS代码改为：\n\n    myApp.directive('even', [function () {\n     return {\n         restrict: 'A',\n         require: \"ngModel\",\n         link: function (scope, element, attrs, ngModelController) {\n             console.log(ngModelController);\n             ngModelController.$parsers.push(function (viewValue) {\n                 if (viewValue % 2 === 0) {\n                     ngModelController.$setValidity(\"even\", true);\n                     return viewValue;\n                 } else {\n                     ngModelController.$setValidity(\"even\", false);\n                 }\n             });\n         }\n     };\n     }]);\n\n","source":"_posts/angular Study notes-3.md","raw":"---\ntitle: angular学习笔记(3)\ndate: 2016-10-24 09:51:09\ntags: [angular,基础]\n---\n\n# angular表单验证\n\nangular自带有一套功能强大的表单验证功能，另外还拓展了一些验证功能(number，url，email，reset)，还能给我们自定义验证方法，用起来特别方便。\n\n首先，先得把bootstrap的样式引进来，这样就不用自己写样式了。\n\n<!-- more-->\n\n## 用户名的验证\n\n直接上代码：\n\n    <div class=\"form-group\" ng-class=\"{'has-error':form.name.$dirty&&form.name.$invalid}\">\n                <label class=\"control-label\">用户名</label>\n                <input autocomplete=\"off\" ng-pattern=\"/^[a-z]/i\" name=\"name\" type=\"name\" ng-model=\"name\" ng-required=\"true\" ng-minlength=\"5\" ng-maxlength=\"10\" class=\"form-control\" placeholder=\"邮箱\">\n                <div ng-show=\"form.name.$dirty&&form.name.$error.minlength\" class=\"alert alert-danger help-block\">\n                    至少5位\n                </div>\n                <div ng-show=\"form.name.$dirty&&form.name.$error.maxlength\" class=\"alert alert-danger help-block\">\n                    最多10位\n                </div>\n                <div ng-show=\"form.name.$dirty&&form.name.$error.pattern\" class=\"alert alert-danger help-block\">\n                    以字母开头\n                </div>\n            </div>\n            \n从上往下看，可以先看到`ng-class`里面有个逻辑表达式，如果`has-error`后面的表达式成立就会用这个class。第一个表达式是`name`值为`form`的表单里的`name`值为`name`的输入框有改动返回的值就为真。第二个是这个输入框有不合法的话返回的值为真。\n\n`ng-pattern`是指用正则验证，如果匹配则下面的`form.name.$error.pattern`就会返回`true`\n\n## 密码和密码确认\n\n    <div class=\"form-group\" ng-class=\"{'has-error':form.password.$dirty&&form.password.$invalid}\">\n                <label class=\"control-label\">密码</label>\n                <input autocomplete=\"off\" name=\"password\" type=\"password\" ng-model=\"password\" ng-required=\"true\" ng-minlength=\"5\" ng-maxlength=\"10\" class=\"form-control\" placeholder=\"密码\">\n                <div ng-show=\"form.password.$dirty&&form.password.$error.minlength\" class=\"alert alert-danger help-block\">\n                    至少5位\n                </div>\n                <div ng-show=\"form.password.$dirty&&form.password.$error.maxlength\" class=\"alert alert-danger help-block\">\n                    最多10位\n                </div>\n            </div>\n            <div class=\"form-group\" ng-class=\"{'has-error':form.passwordConfirm.$dirty&&form.passwordConfirm.$dirty&&form.passwordConfirm.$invalid}\">\n                <label class=\"control-label\">确认密码</label>\n                <input autocomplete=\"off\" name=\"passwordConfirm\" type=\"password\" ng-model=\"passwordConfirm\" ng-required=\"true\" class=\"form-control\" placeholder=\"密码\">\n                <div ng-show=\"form.password.$dirty&&form.passwordConfirm.$dirty&&passwordConfirm!==password\" class=\"alert alert-danger help-block\">\n                    两次不一样\n                </div>\n            </div>\n            \n密码的验证基本没什么特别的，最大长度和最小长度一眼能看出来什么意思。密码的确认那里，如果两个`ng-model`(指的是密码和确认密码的`ng-model`)不相等就返回`false`。\n\n## 邮箱验证\n\n    <div class=\"form-group\" ng-class=\"{'has-error':form.email.$dirty&&form.email.$invalid}\">\n                <label class=\"control-label\">邮箱</label>\n                <input autocomplete=\"off\" name=\"email\" type=\"email\" ng-model=\"email\" ng-required=\"true\" ng-minlength=\"5\" ng-maxlength=\"30\" class=\"form-control\" placeholder=\"邮箱\">\n                <div ng-show=\"form.email.$dirty&&form.email.$error.minlength\" class=\"alert alert-danger help-block\">\n                    至少5位\n                </div>\n                <div ng-show=\"form.email.$dirty&&form.email.$error.maxlength\" class=\"alert alert-danger help-block\">\n                    最多30位\n                </div>\n                <div ng-show=\"form.email.$dirty&&form.email.$error.email\" class=\"alert alert-danger help-block\">\n                    邮箱不对\n                </div>\n            </div>\n\nangular里内置了邮箱的验证，将`input`的`type`改为`email`就行了，错误的返回值用`formName.inputName.$error.email`查看即可，不过个人觉得angular自带的*email*验证还不够完善，如果需要的话可以加个正则验证(`ng-pattern`)，也可以用下面讲到的自定义验证。\n\n## 网址验证\n\n    <div class=\"form-group\" ng-class=\"{'has-error':form.blog.$dirty&&form.blog.$invalid}\">\n                <label class=\"control-label\">博客</label>\n                <input autocomplete=\"off\" name=\"blog\" type=\"url\" ng-model=\"blog\" ng-required=\"true\" ng-minlength=\"5\" ng-maxlength=\"30\" class=\"form-control\" placeholder=\"博客\">\n                <div ng-show=\"form.blog.$dirty&&form.blog.$error.minlength\" class=\"alert alert-danger help-block\">\n                    至少5位\n                </div>\n                <div ng-show=\"form.blog.$dirty&&form.blog.$error.maxlength\" class=\"alert alert-danger help-block\">\n                    最多30位\n                </div>\n                <div ng-show=\"form.blog.$dirty&&form.blog.$error.url\" class=\"alert alert-danger help-block\">\n                    网址不对\n                </div>\n            </div>\n            \nangular里也自带有网址的验证，只需把`input`的`type`改为`url`即可，错误的返回值用`formName.inputName.$error.url`查看。\n\n## 数字验证\n\n    <div class=\"form-group\" ng-class=\"{'has-error':form.age.$dirty&&form.age.$invalid}\">\n                <label class=\"control-label\">年龄</label>\n                <input autocomplete=\"off\" name=\"age\" min=\"0\" max=\"99\" type=\"number\" ng-model=\"age\" ng-required=\"true\" class=\"form-control\" placeholder=\"年龄\">\n                <div ng-show=\"form.age.$dirty&&form.age.$error.min\" class=\"alert alert-danger help-block\">\n                    最小0\n                </div>\n                <div ng-show=\"form.age.$dirty&&form.age.$error.max\" class=\"alert alert-danger help-block\">\n                    最大99\n                </div>\n                <div ng-show=\"form.age.$dirty&&form.age.$error.number\" class=\"alert alert-danger help-block\">\n                    年龄不对\n                </div>\n            </div>\n            \nangular里面也对数字验证进行了拓展，和上面一样，把`type`改为`number`，错误的返回值用`formName.inputName.$error.number`查看。可以在标签上设置属性`min`和`max`来设置最小值和最大值，返回值分别用`formName.inputName.$error.min`，和`formName.inputName.$error.max`查看。\n\n### checkbox\n\nHTML：\n\n    <div class=\"form-group\">\n            <label class=\"label-group\">爱好</label>\n            <label ng-repeat=\"hobby in hobbys\" class=\"checkbox-inline\">\n                <input type=\"checkbox\" ng-checked=\"checked===undefined ? false : checked.indexOf(hobby.id)!==-1\" name=\"hobby\" ng-click=\"toggleSelect(hobby.id)\">{{hobby.name}}\n            </label>\n    </div>\n    \nJS：\n\n    myApp.controller(\"myController\",[\"$scope\",function($scope){\n        $scope.hobbys = [\n        {\n            id: 1,\n            name: \"游戏\"\n        },\n        {\n            id: 2,\n            name: \"游戏2\"\n        },\n        {\n            id: 3,\n            name: \"游戏3\"\n        }\n    ];\n    $scope.checked = [1, 2];\n    $scope.toggleSelect = function (id) {\n        var index = -1;\n        if ($scope.checked === undefined) {\n            $scope.checked = [];\n        } else {\n            index = $scope.checked.indexOf(id);\n        }\n        if (index === -1) {\n            $scope.checked.push(id);\n        } else {\n            $scope.checked.splice(index, 1);\n        }\n    }\n    }]);\n    \n这里的复选框我用了假数据(其实数据应该放在服务里面，我这里为了方便就放控制器里了)，然后用`ng-repeat`循环出来。然后用一个`checked`装已经选上爱好的*id*。下面的`toggleSelect`函数是判断`checked`数组里面是否有传进来的*id*如果没有，就加一个进去否则，删除一个。\n\n## 城市三级关联\n\nHTML：\n\n    <div class=\"form-group\">\n                <label class=\"col-md-1 control-label\">出生地</label>\n                <div class=\"col-md-3\">\n                    <select class=\"form-control\" ng-change=\"area=false\" ng-model=\"city\" ng-options=\"x.id as x.name for x in cities | filterCity:0\"></select>\n                </div>\n                <div ng-show=\"city\" class=\"col-md-3\">\n                    <select class=\"form-control\" ng-model=\"area\" ng-options=\"x.id as x.name for x in cities | filterCity:city\"></select>\n                </div>\n                <div ng-show=\"area&&city\" class=\"col-md-3\">\n                    <select class=\"form-control\" ng-model=\"qu\" ng-options=\"x.id as x.name for x in cities | filterCity:area\"></select>\n                </div>\n    </div>\n\nJS：\n\n     myApp.controller(\"myController\",[\"$scope\",function($scope){\n         $scope.cities = [\n        {\n            name: '上海',\n            parent: 0,\n            id: 1\n            },\n        {\n            name: '上海市',\n            parent: 1,\n            id: 2\n            },\n        {\n            name: '徐汇区',\n            parent: 2,\n            id: 8\n            },\n        {\n            name: '长宁区',\n            parent: 2,\n            id: 3\n            },\n        {\n            name: '北京',\n            parent: 0,\n            id: 4\n            },\n        {\n            name: '北京市',\n            parent: 4,\n            id: 5\n            },\n        {\n            name: '东城区',\n            parent: 5,\n            id: 6\n            },\n        {\n            name: '丰台区',\n            parent: 5,\n            id: 7\n            },\n        {\n            name: '浙江',\n            parent: 0,\n            id: 9\n            },\n        {\n            name: '杭州',\n            parent: 9,\n            id: 100\n            },\n        {\n            name: '宁波',\n            parent: 9,\n            id: 11\n            },\n        {\n            name: '西湖区',\n            parent: 100,\n            id: 12\n            },\n        {\n            name: '北仑区',\n            parent: 11,\n            id: 13\n            }\n        ];\n     }]);\n     myApp.filter(\"filterCity\", function () {\n     return function (city, par) {\n         var filterData = [];\n         angular.forEach(city, function (obj) {\n             if (obj.parent === par) {\n                 filterData.push(obj);\n             }\n         });\n         return filterData;\n     }\n    });\n\n像这样，就做好了城市3级关联。\n\n在HTML中第一个下拉框有个`ng-change=\"area=false`，作用是：当这个下拉框的值改变时，第三个下拉框隐藏。\n\n`ng-options`的作用和`ng-repeat`的作用类似，前者是循环创建*option*选项。可以看到它的值`x.id as x.name for x in cities`。`as`前面的值是*option*的`value`的值，后面的是用户可见的选项，`for`后面的表达式和`ng-repeat`的差不多。\n\n下面的两个下拉框分别用上一个下拉框的`ng-model`值来过滤选项。\n\n有些情况下，这三个单选框需要默认选中某个城市的某个区，这就要根据区来将父级城市选中，这时上面的JS部分增加几行代码变为：\n\n    myApp.controller(\"myController\", [\"$scope\", function ($scope) {\n     $scope.cities = [\n         {\n             name: '上海',\n             parent: 0,\n             id: 1\n            },\n         {\n             name: '上海市',\n             parent: 1,\n             id: 2\n            },\n         {\n             name: '徐汇区',\n             parent: 2,\n             id: 8\n            },\n         {\n             name: '长宁区',\n             parent: 2,\n             id: 3\n            },\n         {\n             name: '北京',\n             parent: 0,\n             id: 4\n            },\n         {\n             name: '北京市',\n             parent: 4,\n             id: 5\n            },\n         {\n             name: '东城区',\n             parent: 5,\n             id: 6\n            },\n         {\n             name: '丰台区',\n             parent: 5,\n             id: 7\n            },\n         {\n             name: '浙江',\n             parent: 0,\n             id: 9\n            },\n         {\n             name: '杭州',\n             parent: 9,\n             id: 100\n            },\n         {\n             name: '宁波',\n             parent: 9,\n             id: 11\n            },\n         {\n             name: '西湖区',\n             parent: 100,\n             id: 12\n            },\n         {\n             name: '北仑区',\n             parent: 11,\n             id: 13\n            }\n        ];\n     $scope.qu = 3;\n     $scope.parentCity = function (id) {\n         var parId;\n         if ($scope.qu !== undefined) {\n             angular.forEach($scope.cities, function (city) {\n                 if (city.id === id) {\n                     parId = city.parent;\n                     return;\n                 }\n             });\n         }\n         return parId;\n     }\n         $scope.area = $scope.parentCity($scope.qu);\n         $scope.city = $scope.parentCity($scope.area);\n     }]);\n     myApp.filter(\"filterCity\", function () {\n         return function (city, par) {\n             var filterData = [];\n             angular.forEach(city, function (obj) {\n                 if (obj.parent === par) {\n                     filterData.push(obj);\n                 }\n             });\n             return filterData;\n         }\n     });\n     \n## 重置\n\nangular的重置和默认的重置又有些不同。angular的重置需要把`model`里的数据也要重置，而默认的重置还做不到这点。\n\n现在在原来的代码基础上将代码改为：\n\nHTML：\n\n            <div class=\"form-group\">\n                <button class=\"btn btn-info\" type=\"reset\" ng-click=\"reset()\">重置</button>\n            </div>\n\nJS：\n\n    myApp.controller(\"myController\", [\"$scope\", function ($scope) {\n     $scope.cities = [\n         {\n             name: '上海',\n             parent: 0,\n             id: 1\n            },\n         {\n             name: '上海市',\n             parent: 1,\n             id: 2\n            },\n         {\n             name: '徐汇区',\n             parent: 2,\n             id: 8\n            },\n         {\n             name: '长宁区',\n             parent: 2,\n             id: 3\n            },\n         {\n             name: '北京',\n             parent: 0,\n             id: 4\n            },\n         {\n             name: '北京市',\n             parent: 4,\n             id: 5\n            },\n         {\n             name: '东城区',\n             parent: 5,\n             id: 6\n            },\n         {\n             name: '丰台区',\n             parent: 5,\n             id: 7\n            },\n         {\n             name: '浙江',\n             parent: 0,\n             id: 9\n            },\n         {\n             name: '杭州',\n             parent: 9,\n             id: 100\n            },\n         {\n             name: '宁波',\n             parent: 9,\n             id: 11\n            },\n         {\n             name: '西湖区',\n             parent: 100,\n             id: 12\n            },\n         {\n             name: '北仑区',\n             parent: 11,\n             id: 13\n            }\n        ];\n     $scope.init = function () {\n         $scope.qu = 3;\n         $scope.parentCity = function (id) {\n             var parId;\n             if ($scope.qu !== undefined) {\n                 angular.forEach($scope.cities, function (city) {\n                     if (city.id === id) {\n                         parId = city.parent;\n                         return;\n                     }\n                 });\n             }\n             return parId;\n         }\n         $scope.area = $scope.parentCity($scope.qu);\n         $scope.city = $scope.parentCity($scope.area);\n         $scope.copyQu = angular.copy($scope.qu);\n     };\n     $scope.reset = function () {\n         $scope.qu = angular.copy($scope.copyQu);\n         $scope.area = $scope.parentCity($scope.qu);\n         $scope.city = $scope.parentCity($scope.area);\n     };\n     $scope.init();\n     }]);\n     myApp.filter(\"filterCity\", function () {\n         return function (city, par) {\n             var filterData = [];\n             angular.forEach(city, function (obj) {\n                 if (obj.parent === par) {\n                     filterData.push(obj);\n                 }\n             });\n             return filterData;\n         }\n     });\n     \n在JS中，我把城市三级关联的初始化放到了一个`init`函数中，并在下面将需要的数据备份，当重置按钮被点下时运行`reset`函数，将三个下拉框的数据重置回来(在重置的时候也用到了copy是为了防止原始值和copy值互相引用，保证了数据的安全)，但是当用户在上面的用户名输入有错误时点击重置会发现下面的错误提示并没有消失，这是因为`$error`没被重置，这个时候，需要在重置函数里加上`$scope.formName.$setPristine();`就可以吧表单恢复为原始的状态，这样重置就完成了。\n     \n## 自定义验证\n\n在前面说了，angular可以自定义验证规则。在用自定义验证规则之前得要知道有个`ngModel`，它可以更深层地处理数据的双向绑定，可以通过设置自定义指令的`require`为`ngModel`取到，并且将`link`函数的第四个参数设置为`ngModelController`\n\nHTML：\n\n    <div class=\"form-group\" ng-class=\"{'has-error':form.even.$dirty&&form.even.$invalid}\">\n                <label class=\"control-label\">偶数</label>\n                <input autocomplete=\"off\" name=\"even\" type=\"number\" ng-model=\"even\" ng-required=\"true\" class=\"form-control\" placeholder=\"偶数\" even>\n                <div ng-show=\"form.even.$dirty&&form.even.$error.even\" class=\"alert alert-danger help-block\">\n                    输入偶数\n                </div>\n    </div>\n\nJS：\n\n    myApp.directive('even', [function () {\n         return {\n             restrict: 'A',\n             require:\"ngModel\",\n             link: function (scope, element, attrs,ngModelController) {\n                 console.log(ngModelController);\n             }\n         };\n         }]);\n\n可以看到在控制台会输出很多属性比如：\n\n    1. $formatters 保存的是从modelValue向viewValue绑定过程中的处理函数\n    2. $setViewValue 当view发生了某件事情时，从view向model绑定调用$setViewValue把viewValue保存下来\n    3. $render 当模型发生变化时，应该怎么去更新视图，从model向view绑定，调用ctrl.$render方法，将viewValue渲染到页面上\n    4. $setValidity 设置验证结果，第一个参数是验证错误的名字，第二个是true or false\n    5. $viewValue 视图的值\n    6. $modelValue 模型里的值\n    7. $parsers保存从viewValue向modelValue绑定过程中的处理函数，它们将来会依次执行\n    \n这样就可以写自定义验证了，接下来，把JS代码改为：\n\n    myApp.directive('even', [function () {\n     return {\n         restrict: 'A',\n         require: \"ngModel\",\n         link: function (scope, element, attrs, ngModelController) {\n             console.log(ngModelController);\n             ngModelController.$parsers.push(function (viewValue) {\n                 if (viewValue % 2 === 0) {\n                     ngModelController.$setValidity(\"even\", true);\n                     return viewValue;\n                 } else {\n                     ngModelController.$setValidity(\"even\", false);\n                 }\n             });\n         }\n     };\n     }]);\n\n","slug":"angular Study notes-3","published":1,"updated":"2020-04-07T03:29:17.933Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8qzc34e000b2cl6sp9zro3i","content":"<h1 id=\"angular表单验证\"><a href=\"#angular表单验证\" class=\"headerlink\" title=\"angular表单验证\"></a>angular表单验证</h1><p>angular自带有一套功能强大的表单验证功能，另外还拓展了一些验证功能(number，url，email，reset)，还能给我们自定义验证方法，用起来特别方便。</p>\n<p>首先，先得把bootstrap的样式引进来，这样就不用自己写样式了。</p>\n<a id=\"more\"></a>\n<h2 id=\"用户名的验证\"><a href=\"#用户名的验证\" class=\"headerlink\" title=\"用户名的验证\"></a>用户名的验证</h2><p>直接上代码：</p>\n<pre><code>&lt;div class=&quot;form-group&quot; ng-class=&quot;{&apos;has-error&apos;:form.name.$dirty&amp;&amp;form.name.$invalid}&quot;&gt;\n            &lt;label class=&quot;control-label&quot;&gt;用户名&lt;/label&gt;\n            &lt;input autocomplete=&quot;off&quot; ng-pattern=&quot;/^[a-z]/i&quot; name=&quot;name&quot; type=&quot;name&quot; ng-model=&quot;name&quot; ng-required=&quot;true&quot; ng-minlength=&quot;5&quot; ng-maxlength=&quot;10&quot; class=&quot;form-control&quot; placeholder=&quot;邮箱&quot;&gt;\n            &lt;div ng-show=&quot;form.name.$dirty&amp;&amp;form.name.$error.minlength&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                至少5位\n            &lt;/div&gt;\n            &lt;div ng-show=&quot;form.name.$dirty&amp;&amp;form.name.$error.maxlength&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                最多10位\n            &lt;/div&gt;\n            &lt;div ng-show=&quot;form.name.$dirty&amp;&amp;form.name.$error.pattern&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                以字母开头\n            &lt;/div&gt;\n        &lt;/div&gt;\n</code></pre><p>从上往下看，可以先看到<code>ng-class</code>里面有个逻辑表达式，如果<code>has-error</code>后面的表达式成立就会用这个class。第一个表达式是<code>name</code>值为<code>form</code>的表单里的<code>name</code>值为<code>name</code>的输入框有改动返回的值就为真。第二个是这个输入框有不合法的话返回的值为真。</p>\n<p><code>ng-pattern</code>是指用正则验证，如果匹配则下面的<code>form.name.$error.pattern</code>就会返回<code>true</code></p>\n<h2 id=\"密码和密码确认\"><a href=\"#密码和密码确认\" class=\"headerlink\" title=\"密码和密码确认\"></a>密码和密码确认</h2><pre><code>&lt;div class=&quot;form-group&quot; ng-class=&quot;{&apos;has-error&apos;:form.password.$dirty&amp;&amp;form.password.$invalid}&quot;&gt;\n            &lt;label class=&quot;control-label&quot;&gt;密码&lt;/label&gt;\n            &lt;input autocomplete=&quot;off&quot; name=&quot;password&quot; type=&quot;password&quot; ng-model=&quot;password&quot; ng-required=&quot;true&quot; ng-minlength=&quot;5&quot; ng-maxlength=&quot;10&quot; class=&quot;form-control&quot; placeholder=&quot;密码&quot;&gt;\n            &lt;div ng-show=&quot;form.password.$dirty&amp;&amp;form.password.$error.minlength&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                至少5位\n            &lt;/div&gt;\n            &lt;div ng-show=&quot;form.password.$dirty&amp;&amp;form.password.$error.maxlength&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                最多10位\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;form-group&quot; ng-class=&quot;{&apos;has-error&apos;:form.passwordConfirm.$dirty&amp;&amp;form.passwordConfirm.$dirty&amp;&amp;form.passwordConfirm.$invalid}&quot;&gt;\n            &lt;label class=&quot;control-label&quot;&gt;确认密码&lt;/label&gt;\n            &lt;input autocomplete=&quot;off&quot; name=&quot;passwordConfirm&quot; type=&quot;password&quot; ng-model=&quot;passwordConfirm&quot; ng-required=&quot;true&quot; class=&quot;form-control&quot; placeholder=&quot;密码&quot;&gt;\n            &lt;div ng-show=&quot;form.password.$dirty&amp;&amp;form.passwordConfirm.$dirty&amp;&amp;passwordConfirm!==password&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                两次不一样\n            &lt;/div&gt;\n        &lt;/div&gt;\n</code></pre><p>密码的验证基本没什么特别的，最大长度和最小长度一眼能看出来什么意思。密码的确认那里，如果两个<code>ng-model</code>(指的是密码和确认密码的<code>ng-model</code>)不相等就返回<code>false</code>。</p>\n<h2 id=\"邮箱验证\"><a href=\"#邮箱验证\" class=\"headerlink\" title=\"邮箱验证\"></a>邮箱验证</h2><pre><code>&lt;div class=&quot;form-group&quot; ng-class=&quot;{&apos;has-error&apos;:form.email.$dirty&amp;&amp;form.email.$invalid}&quot;&gt;\n            &lt;label class=&quot;control-label&quot;&gt;邮箱&lt;/label&gt;\n            &lt;input autocomplete=&quot;off&quot; name=&quot;email&quot; type=&quot;email&quot; ng-model=&quot;email&quot; ng-required=&quot;true&quot; ng-minlength=&quot;5&quot; ng-maxlength=&quot;30&quot; class=&quot;form-control&quot; placeholder=&quot;邮箱&quot;&gt;\n            &lt;div ng-show=&quot;form.email.$dirty&amp;&amp;form.email.$error.minlength&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                至少5位\n            &lt;/div&gt;\n            &lt;div ng-show=&quot;form.email.$dirty&amp;&amp;form.email.$error.maxlength&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                最多30位\n            &lt;/div&gt;\n            &lt;div ng-show=&quot;form.email.$dirty&amp;&amp;form.email.$error.email&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                邮箱不对\n            &lt;/div&gt;\n        &lt;/div&gt;\n</code></pre><p>angular里内置了邮箱的验证，将<code>input</code>的<code>type</code>改为<code>email</code>就行了，错误的返回值用<code>formName.inputName.$error.email</code>查看即可，不过个人觉得angular自带的<em>email</em>验证还不够完善，如果需要的话可以加个正则验证(<code>ng-pattern</code>)，也可以用下面讲到的自定义验证。</p>\n<h2 id=\"网址验证\"><a href=\"#网址验证\" class=\"headerlink\" title=\"网址验证\"></a>网址验证</h2><pre><code>&lt;div class=&quot;form-group&quot; ng-class=&quot;{&apos;has-error&apos;:form.blog.$dirty&amp;&amp;form.blog.$invalid}&quot;&gt;\n            &lt;label class=&quot;control-label&quot;&gt;博客&lt;/label&gt;\n            &lt;input autocomplete=&quot;off&quot; name=&quot;blog&quot; type=&quot;url&quot; ng-model=&quot;blog&quot; ng-required=&quot;true&quot; ng-minlength=&quot;5&quot; ng-maxlength=&quot;30&quot; class=&quot;form-control&quot; placeholder=&quot;博客&quot;&gt;\n            &lt;div ng-show=&quot;form.blog.$dirty&amp;&amp;form.blog.$error.minlength&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                至少5位\n            &lt;/div&gt;\n            &lt;div ng-show=&quot;form.blog.$dirty&amp;&amp;form.blog.$error.maxlength&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                最多30位\n            &lt;/div&gt;\n            &lt;div ng-show=&quot;form.blog.$dirty&amp;&amp;form.blog.$error.url&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                网址不对\n            &lt;/div&gt;\n        &lt;/div&gt;\n</code></pre><p>angular里也自带有网址的验证，只需把<code>input</code>的<code>type</code>改为<code>url</code>即可，错误的返回值用<code>formName.inputName.$error.url</code>查看。</p>\n<h2 id=\"数字验证\"><a href=\"#数字验证\" class=\"headerlink\" title=\"数字验证\"></a>数字验证</h2><pre><code>&lt;div class=&quot;form-group&quot; ng-class=&quot;{&apos;has-error&apos;:form.age.$dirty&amp;&amp;form.age.$invalid}&quot;&gt;\n            &lt;label class=&quot;control-label&quot;&gt;年龄&lt;/label&gt;\n            &lt;input autocomplete=&quot;off&quot; name=&quot;age&quot; min=&quot;0&quot; max=&quot;99&quot; type=&quot;number&quot; ng-model=&quot;age&quot; ng-required=&quot;true&quot; class=&quot;form-control&quot; placeholder=&quot;年龄&quot;&gt;\n            &lt;div ng-show=&quot;form.age.$dirty&amp;&amp;form.age.$error.min&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                最小0\n            &lt;/div&gt;\n            &lt;div ng-show=&quot;form.age.$dirty&amp;&amp;form.age.$error.max&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                最大99\n            &lt;/div&gt;\n            &lt;div ng-show=&quot;form.age.$dirty&amp;&amp;form.age.$error.number&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                年龄不对\n            &lt;/div&gt;\n        &lt;/div&gt;\n</code></pre><p>angular里面也对数字验证进行了拓展，和上面一样，把<code>type</code>改为<code>number</code>，错误的返回值用<code>formName.inputName.$error.number</code>查看。可以在标签上设置属性<code>min</code>和<code>max</code>来设置最小值和最大值，返回值分别用<code>formName.inputName.$error.min</code>，和<code>formName.inputName.$error.max</code>查看。</p>\n<h3 id=\"checkbox\"><a href=\"#checkbox\" class=\"headerlink\" title=\"checkbox\"></a>checkbox</h3><p>HTML：</p>\n<pre><code>&lt;div class=&quot;form-group&quot;&gt;\n        &lt;label class=&quot;label-group&quot;&gt;爱好&lt;/label&gt;\n        &lt;label ng-repeat=&quot;hobby in hobbys&quot; class=&quot;checkbox-inline&quot;&gt;\n            &lt;input type=&quot;checkbox&quot; ng-checked=&quot;checked===undefined ? false : checked.indexOf(hobby.id)!==-1&quot; name=&quot;hobby&quot; ng-click=&quot;toggleSelect(hobby.id)&quot;&gt;{{hobby.name}}\n        &lt;/label&gt;\n&lt;/div&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.controller(&quot;myController&quot;,[&quot;$scope&quot;,function($scope){\n    $scope.hobbys = [\n    {\n        id: 1,\n        name: &quot;游戏&quot;\n    },\n    {\n        id: 2,\n        name: &quot;游戏2&quot;\n    },\n    {\n        id: 3,\n        name: &quot;游戏3&quot;\n    }\n];\n$scope.checked = [1, 2];\n$scope.toggleSelect = function (id) {\n    var index = -1;\n    if ($scope.checked === undefined) {\n        $scope.checked = [];\n    } else {\n        index = $scope.checked.indexOf(id);\n    }\n    if (index === -1) {\n        $scope.checked.push(id);\n    } else {\n        $scope.checked.splice(index, 1);\n    }\n}\n}]);\n</code></pre><p>这里的复选框我用了假数据(其实数据应该放在服务里面，我这里为了方便就放控制器里了)，然后用<code>ng-repeat</code>循环出来。然后用一个<code>checked</code>装已经选上爱好的<em>id</em>。下面的<code>toggleSelect</code>函数是判断<code>checked</code>数组里面是否有传进来的<em>id</em>如果没有，就加一个进去否则，删除一个。</p>\n<h2 id=\"城市三级关联\"><a href=\"#城市三级关联\" class=\"headerlink\" title=\"城市三级关联\"></a>城市三级关联</h2><p>HTML：</p>\n<pre><code>&lt;div class=&quot;form-group&quot;&gt;\n            &lt;label class=&quot;col-md-1 control-label&quot;&gt;出生地&lt;/label&gt;\n            &lt;div class=&quot;col-md-3&quot;&gt;\n                &lt;select class=&quot;form-control&quot; ng-change=&quot;area=false&quot; ng-model=&quot;city&quot; ng-options=&quot;x.id as x.name for x in cities | filterCity:0&quot;&gt;&lt;/select&gt;\n            &lt;/div&gt;\n            &lt;div ng-show=&quot;city&quot; class=&quot;col-md-3&quot;&gt;\n                &lt;select class=&quot;form-control&quot; ng-model=&quot;area&quot; ng-options=&quot;x.id as x.name for x in cities | filterCity:city&quot;&gt;&lt;/select&gt;\n            &lt;/div&gt;\n            &lt;div ng-show=&quot;area&amp;&amp;city&quot; class=&quot;col-md-3&quot;&gt;\n                &lt;select class=&quot;form-control&quot; ng-model=&quot;qu&quot; ng-options=&quot;x.id as x.name for x in cities | filterCity:area&quot;&gt;&lt;/select&gt;\n            &lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>JS：</p>\n<pre><code> myApp.controller(&quot;myController&quot;,[&quot;$scope&quot;,function($scope){\n     $scope.cities = [\n    {\n        name: &apos;上海&apos;,\n        parent: 0,\n        id: 1\n        },\n    {\n        name: &apos;上海市&apos;,\n        parent: 1,\n        id: 2\n        },\n    {\n        name: &apos;徐汇区&apos;,\n        parent: 2,\n        id: 8\n        },\n    {\n        name: &apos;长宁区&apos;,\n        parent: 2,\n        id: 3\n        },\n    {\n        name: &apos;北京&apos;,\n        parent: 0,\n        id: 4\n        },\n    {\n        name: &apos;北京市&apos;,\n        parent: 4,\n        id: 5\n        },\n    {\n        name: &apos;东城区&apos;,\n        parent: 5,\n        id: 6\n        },\n    {\n        name: &apos;丰台区&apos;,\n        parent: 5,\n        id: 7\n        },\n    {\n        name: &apos;浙江&apos;,\n        parent: 0,\n        id: 9\n        },\n    {\n        name: &apos;杭州&apos;,\n        parent: 9,\n        id: 100\n        },\n    {\n        name: &apos;宁波&apos;,\n        parent: 9,\n        id: 11\n        },\n    {\n        name: &apos;西湖区&apos;,\n        parent: 100,\n        id: 12\n        },\n    {\n        name: &apos;北仑区&apos;,\n        parent: 11,\n        id: 13\n        }\n    ];\n }]);\n myApp.filter(&quot;filterCity&quot;, function () {\n return function (city, par) {\n     var filterData = [];\n     angular.forEach(city, function (obj) {\n         if (obj.parent === par) {\n             filterData.push(obj);\n         }\n     });\n     return filterData;\n }\n});\n</code></pre><p>像这样，就做好了城市3级关联。</p>\n<p>在HTML中第一个下拉框有个<code>ng-change=&quot;area=false</code>，作用是：当这个下拉框的值改变时，第三个下拉框隐藏。</p>\n<p><code>ng-options</code>的作用和<code>ng-repeat</code>的作用类似，前者是循环创建<em>option</em>选项。可以看到它的值<code>x.id as x.name for x in cities</code>。<code>as</code>前面的值是<em>option</em>的<code>value</code>的值，后面的是用户可见的选项，<code>for</code>后面的表达式和<code>ng-repeat</code>的差不多。</p>\n<p>下面的两个下拉框分别用上一个下拉框的<code>ng-model</code>值来过滤选项。</p>\n<p>有些情况下，这三个单选框需要默认选中某个城市的某个区，这就要根据区来将父级城市选中，这时上面的JS部分增加几行代码变为：</p>\n<pre><code>myApp.controller(&quot;myController&quot;, [&quot;$scope&quot;, function ($scope) {\n $scope.cities = [\n     {\n         name: &apos;上海&apos;,\n         parent: 0,\n         id: 1\n        },\n     {\n         name: &apos;上海市&apos;,\n         parent: 1,\n         id: 2\n        },\n     {\n         name: &apos;徐汇区&apos;,\n         parent: 2,\n         id: 8\n        },\n     {\n         name: &apos;长宁区&apos;,\n         parent: 2,\n         id: 3\n        },\n     {\n         name: &apos;北京&apos;,\n         parent: 0,\n         id: 4\n        },\n     {\n         name: &apos;北京市&apos;,\n         parent: 4,\n         id: 5\n        },\n     {\n         name: &apos;东城区&apos;,\n         parent: 5,\n         id: 6\n        },\n     {\n         name: &apos;丰台区&apos;,\n         parent: 5,\n         id: 7\n        },\n     {\n         name: &apos;浙江&apos;,\n         parent: 0,\n         id: 9\n        },\n     {\n         name: &apos;杭州&apos;,\n         parent: 9,\n         id: 100\n        },\n     {\n         name: &apos;宁波&apos;,\n         parent: 9,\n         id: 11\n        },\n     {\n         name: &apos;西湖区&apos;,\n         parent: 100,\n         id: 12\n        },\n     {\n         name: &apos;北仑区&apos;,\n         parent: 11,\n         id: 13\n        }\n    ];\n $scope.qu = 3;\n $scope.parentCity = function (id) {\n     var parId;\n     if ($scope.qu !== undefined) {\n         angular.forEach($scope.cities, function (city) {\n             if (city.id === id) {\n                 parId = city.parent;\n                 return;\n             }\n         });\n     }\n     return parId;\n }\n     $scope.area = $scope.parentCity($scope.qu);\n     $scope.city = $scope.parentCity($scope.area);\n }]);\n myApp.filter(&quot;filterCity&quot;, function () {\n     return function (city, par) {\n         var filterData = [];\n         angular.forEach(city, function (obj) {\n             if (obj.parent === par) {\n                 filterData.push(obj);\n             }\n         });\n         return filterData;\n     }\n });\n</code></pre><h2 id=\"重置\"><a href=\"#重置\" class=\"headerlink\" title=\"重置\"></a>重置</h2><p>angular的重置和默认的重置又有些不同。angular的重置需要把<code>model</code>里的数据也要重置，而默认的重置还做不到这点。</p>\n<p>现在在原来的代码基础上将代码改为：</p>\n<p>HTML：</p>\n<pre><code>&lt;div class=&quot;form-group&quot;&gt;\n    &lt;button class=&quot;btn btn-info&quot; type=&quot;reset&quot; ng-click=&quot;reset()&quot;&gt;重置&lt;/button&gt;\n&lt;/div&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.controller(&quot;myController&quot;, [&quot;$scope&quot;, function ($scope) {\n $scope.cities = [\n     {\n         name: &apos;上海&apos;,\n         parent: 0,\n         id: 1\n        },\n     {\n         name: &apos;上海市&apos;,\n         parent: 1,\n         id: 2\n        },\n     {\n         name: &apos;徐汇区&apos;,\n         parent: 2,\n         id: 8\n        },\n     {\n         name: &apos;长宁区&apos;,\n         parent: 2,\n         id: 3\n        },\n     {\n         name: &apos;北京&apos;,\n         parent: 0,\n         id: 4\n        },\n     {\n         name: &apos;北京市&apos;,\n         parent: 4,\n         id: 5\n        },\n     {\n         name: &apos;东城区&apos;,\n         parent: 5,\n         id: 6\n        },\n     {\n         name: &apos;丰台区&apos;,\n         parent: 5,\n         id: 7\n        },\n     {\n         name: &apos;浙江&apos;,\n         parent: 0,\n         id: 9\n        },\n     {\n         name: &apos;杭州&apos;,\n         parent: 9,\n         id: 100\n        },\n     {\n         name: &apos;宁波&apos;,\n         parent: 9,\n         id: 11\n        },\n     {\n         name: &apos;西湖区&apos;,\n         parent: 100,\n         id: 12\n        },\n     {\n         name: &apos;北仑区&apos;,\n         parent: 11,\n         id: 13\n        }\n    ];\n $scope.init = function () {\n     $scope.qu = 3;\n     $scope.parentCity = function (id) {\n         var parId;\n         if ($scope.qu !== undefined) {\n             angular.forEach($scope.cities, function (city) {\n                 if (city.id === id) {\n                     parId = city.parent;\n                     return;\n                 }\n             });\n         }\n         return parId;\n     }\n     $scope.area = $scope.parentCity($scope.qu);\n     $scope.city = $scope.parentCity($scope.area);\n     $scope.copyQu = angular.copy($scope.qu);\n };\n $scope.reset = function () {\n     $scope.qu = angular.copy($scope.copyQu);\n     $scope.area = $scope.parentCity($scope.qu);\n     $scope.city = $scope.parentCity($scope.area);\n };\n $scope.init();\n }]);\n myApp.filter(&quot;filterCity&quot;, function () {\n     return function (city, par) {\n         var filterData = [];\n         angular.forEach(city, function (obj) {\n             if (obj.parent === par) {\n                 filterData.push(obj);\n             }\n         });\n         return filterData;\n     }\n });\n</code></pre><p>在JS中，我把城市三级关联的初始化放到了一个<code>init</code>函数中，并在下面将需要的数据备份，当重置按钮被点下时运行<code>reset</code>函数，将三个下拉框的数据重置回来(在重置的时候也用到了copy是为了防止原始值和copy值互相引用，保证了数据的安全)，但是当用户在上面的用户名输入有错误时点击重置会发现下面的错误提示并没有消失，这是因为<code>$error</code>没被重置，这个时候，需要在重置函数里加上<code>$scope.formName.$setPristine();</code>就可以吧表单恢复为原始的状态，这样重置就完成了。</p>\n<h2 id=\"自定义验证\"><a href=\"#自定义验证\" class=\"headerlink\" title=\"自定义验证\"></a>自定义验证</h2><p>在前面说了，angular可以自定义验证规则。在用自定义验证规则之前得要知道有个<code>ngModel</code>，它可以更深层地处理数据的双向绑定，可以通过设置自定义指令的<code>require</code>为<code>ngModel</code>取到，并且将<code>link</code>函数的第四个参数设置为<code>ngModelController</code></p>\n<p>HTML：</p>\n<pre><code>&lt;div class=&quot;form-group&quot; ng-class=&quot;{&apos;has-error&apos;:form.even.$dirty&amp;&amp;form.even.$invalid}&quot;&gt;\n            &lt;label class=&quot;control-label&quot;&gt;偶数&lt;/label&gt;\n            &lt;input autocomplete=&quot;off&quot; name=&quot;even&quot; type=&quot;number&quot; ng-model=&quot;even&quot; ng-required=&quot;true&quot; class=&quot;form-control&quot; placeholder=&quot;偶数&quot; even&gt;\n            &lt;div ng-show=&quot;form.even.$dirty&amp;&amp;form.even.$error.even&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                输入偶数\n            &lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.directive(&apos;even&apos;, [function () {\n     return {\n         restrict: &apos;A&apos;,\n         require:&quot;ngModel&quot;,\n         link: function (scope, element, attrs,ngModelController) {\n             console.log(ngModelController);\n         }\n     };\n     }]);\n</code></pre><p>可以看到在控制台会输出很多属性比如：</p>\n<pre><code>1. $formatters 保存的是从modelValue向viewValue绑定过程中的处理函数\n2. $setViewValue 当view发生了某件事情时，从view向model绑定调用$setViewValue把viewValue保存下来\n3. $render 当模型发生变化时，应该怎么去更新视图，从model向view绑定，调用ctrl.$render方法，将viewValue渲染到页面上\n4. $setValidity 设置验证结果，第一个参数是验证错误的名字，第二个是true or false\n5. $viewValue 视图的值\n6. $modelValue 模型里的值\n7. $parsers保存从viewValue向modelValue绑定过程中的处理函数，它们将来会依次执行\n</code></pre><p>这样就可以写自定义验证了，接下来，把JS代码改为：</p>\n<pre><code>myApp.directive(&apos;even&apos;, [function () {\n return {\n     restrict: &apos;A&apos;,\n     require: &quot;ngModel&quot;,\n     link: function (scope, element, attrs, ngModelController) {\n         console.log(ngModelController);\n         ngModelController.$parsers.push(function (viewValue) {\n             if (viewValue % 2 === 0) {\n                 ngModelController.$setValidity(&quot;even&quot;, true);\n                 return viewValue;\n             } else {\n                 ngModelController.$setValidity(&quot;even&quot;, false);\n             }\n         });\n     }\n };\n }]);\n</code></pre>","site":{"data":{}},"excerpt":"<h1 id=\"angular表单验证\"><a href=\"#angular表单验证\" class=\"headerlink\" title=\"angular表单验证\"></a>angular表单验证</h1><p>angular自带有一套功能强大的表单验证功能，另外还拓展了一些验证功能(number，url，email，reset)，还能给我们自定义验证方法，用起来特别方便。</p>\n<p>首先，先得把bootstrap的样式引进来，这样就不用自己写样式了。</p>","more":"<h2 id=\"用户名的验证\"><a href=\"#用户名的验证\" class=\"headerlink\" title=\"用户名的验证\"></a>用户名的验证</h2><p>直接上代码：</p>\n<pre><code>&lt;div class=&quot;form-group&quot; ng-class=&quot;{&apos;has-error&apos;:form.name.$dirty&amp;&amp;form.name.$invalid}&quot;&gt;\n            &lt;label class=&quot;control-label&quot;&gt;用户名&lt;/label&gt;\n            &lt;input autocomplete=&quot;off&quot; ng-pattern=&quot;/^[a-z]/i&quot; name=&quot;name&quot; type=&quot;name&quot; ng-model=&quot;name&quot; ng-required=&quot;true&quot; ng-minlength=&quot;5&quot; ng-maxlength=&quot;10&quot; class=&quot;form-control&quot; placeholder=&quot;邮箱&quot;&gt;\n            &lt;div ng-show=&quot;form.name.$dirty&amp;&amp;form.name.$error.minlength&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                至少5位\n            &lt;/div&gt;\n            &lt;div ng-show=&quot;form.name.$dirty&amp;&amp;form.name.$error.maxlength&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                最多10位\n            &lt;/div&gt;\n            &lt;div ng-show=&quot;form.name.$dirty&amp;&amp;form.name.$error.pattern&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                以字母开头\n            &lt;/div&gt;\n        &lt;/div&gt;\n</code></pre><p>从上往下看，可以先看到<code>ng-class</code>里面有个逻辑表达式，如果<code>has-error</code>后面的表达式成立就会用这个class。第一个表达式是<code>name</code>值为<code>form</code>的表单里的<code>name</code>值为<code>name</code>的输入框有改动返回的值就为真。第二个是这个输入框有不合法的话返回的值为真。</p>\n<p><code>ng-pattern</code>是指用正则验证，如果匹配则下面的<code>form.name.$error.pattern</code>就会返回<code>true</code></p>\n<h2 id=\"密码和密码确认\"><a href=\"#密码和密码确认\" class=\"headerlink\" title=\"密码和密码确认\"></a>密码和密码确认</h2><pre><code>&lt;div class=&quot;form-group&quot; ng-class=&quot;{&apos;has-error&apos;:form.password.$dirty&amp;&amp;form.password.$invalid}&quot;&gt;\n            &lt;label class=&quot;control-label&quot;&gt;密码&lt;/label&gt;\n            &lt;input autocomplete=&quot;off&quot; name=&quot;password&quot; type=&quot;password&quot; ng-model=&quot;password&quot; ng-required=&quot;true&quot; ng-minlength=&quot;5&quot; ng-maxlength=&quot;10&quot; class=&quot;form-control&quot; placeholder=&quot;密码&quot;&gt;\n            &lt;div ng-show=&quot;form.password.$dirty&amp;&amp;form.password.$error.minlength&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                至少5位\n            &lt;/div&gt;\n            &lt;div ng-show=&quot;form.password.$dirty&amp;&amp;form.password.$error.maxlength&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                最多10位\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;form-group&quot; ng-class=&quot;{&apos;has-error&apos;:form.passwordConfirm.$dirty&amp;&amp;form.passwordConfirm.$dirty&amp;&amp;form.passwordConfirm.$invalid}&quot;&gt;\n            &lt;label class=&quot;control-label&quot;&gt;确认密码&lt;/label&gt;\n            &lt;input autocomplete=&quot;off&quot; name=&quot;passwordConfirm&quot; type=&quot;password&quot; ng-model=&quot;passwordConfirm&quot; ng-required=&quot;true&quot; class=&quot;form-control&quot; placeholder=&quot;密码&quot;&gt;\n            &lt;div ng-show=&quot;form.password.$dirty&amp;&amp;form.passwordConfirm.$dirty&amp;&amp;passwordConfirm!==password&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                两次不一样\n            &lt;/div&gt;\n        &lt;/div&gt;\n</code></pre><p>密码的验证基本没什么特别的，最大长度和最小长度一眼能看出来什么意思。密码的确认那里，如果两个<code>ng-model</code>(指的是密码和确认密码的<code>ng-model</code>)不相等就返回<code>false</code>。</p>\n<h2 id=\"邮箱验证\"><a href=\"#邮箱验证\" class=\"headerlink\" title=\"邮箱验证\"></a>邮箱验证</h2><pre><code>&lt;div class=&quot;form-group&quot; ng-class=&quot;{&apos;has-error&apos;:form.email.$dirty&amp;&amp;form.email.$invalid}&quot;&gt;\n            &lt;label class=&quot;control-label&quot;&gt;邮箱&lt;/label&gt;\n            &lt;input autocomplete=&quot;off&quot; name=&quot;email&quot; type=&quot;email&quot; ng-model=&quot;email&quot; ng-required=&quot;true&quot; ng-minlength=&quot;5&quot; ng-maxlength=&quot;30&quot; class=&quot;form-control&quot; placeholder=&quot;邮箱&quot;&gt;\n            &lt;div ng-show=&quot;form.email.$dirty&amp;&amp;form.email.$error.minlength&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                至少5位\n            &lt;/div&gt;\n            &lt;div ng-show=&quot;form.email.$dirty&amp;&amp;form.email.$error.maxlength&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                最多30位\n            &lt;/div&gt;\n            &lt;div ng-show=&quot;form.email.$dirty&amp;&amp;form.email.$error.email&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                邮箱不对\n            &lt;/div&gt;\n        &lt;/div&gt;\n</code></pre><p>angular里内置了邮箱的验证，将<code>input</code>的<code>type</code>改为<code>email</code>就行了，错误的返回值用<code>formName.inputName.$error.email</code>查看即可，不过个人觉得angular自带的<em>email</em>验证还不够完善，如果需要的话可以加个正则验证(<code>ng-pattern</code>)，也可以用下面讲到的自定义验证。</p>\n<h2 id=\"网址验证\"><a href=\"#网址验证\" class=\"headerlink\" title=\"网址验证\"></a>网址验证</h2><pre><code>&lt;div class=&quot;form-group&quot; ng-class=&quot;{&apos;has-error&apos;:form.blog.$dirty&amp;&amp;form.blog.$invalid}&quot;&gt;\n            &lt;label class=&quot;control-label&quot;&gt;博客&lt;/label&gt;\n            &lt;input autocomplete=&quot;off&quot; name=&quot;blog&quot; type=&quot;url&quot; ng-model=&quot;blog&quot; ng-required=&quot;true&quot; ng-minlength=&quot;5&quot; ng-maxlength=&quot;30&quot; class=&quot;form-control&quot; placeholder=&quot;博客&quot;&gt;\n            &lt;div ng-show=&quot;form.blog.$dirty&amp;&amp;form.blog.$error.minlength&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                至少5位\n            &lt;/div&gt;\n            &lt;div ng-show=&quot;form.blog.$dirty&amp;&amp;form.blog.$error.maxlength&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                最多30位\n            &lt;/div&gt;\n            &lt;div ng-show=&quot;form.blog.$dirty&amp;&amp;form.blog.$error.url&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                网址不对\n            &lt;/div&gt;\n        &lt;/div&gt;\n</code></pre><p>angular里也自带有网址的验证，只需把<code>input</code>的<code>type</code>改为<code>url</code>即可，错误的返回值用<code>formName.inputName.$error.url</code>查看。</p>\n<h2 id=\"数字验证\"><a href=\"#数字验证\" class=\"headerlink\" title=\"数字验证\"></a>数字验证</h2><pre><code>&lt;div class=&quot;form-group&quot; ng-class=&quot;{&apos;has-error&apos;:form.age.$dirty&amp;&amp;form.age.$invalid}&quot;&gt;\n            &lt;label class=&quot;control-label&quot;&gt;年龄&lt;/label&gt;\n            &lt;input autocomplete=&quot;off&quot; name=&quot;age&quot; min=&quot;0&quot; max=&quot;99&quot; type=&quot;number&quot; ng-model=&quot;age&quot; ng-required=&quot;true&quot; class=&quot;form-control&quot; placeholder=&quot;年龄&quot;&gt;\n            &lt;div ng-show=&quot;form.age.$dirty&amp;&amp;form.age.$error.min&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                最小0\n            &lt;/div&gt;\n            &lt;div ng-show=&quot;form.age.$dirty&amp;&amp;form.age.$error.max&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                最大99\n            &lt;/div&gt;\n            &lt;div ng-show=&quot;form.age.$dirty&amp;&amp;form.age.$error.number&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                年龄不对\n            &lt;/div&gt;\n        &lt;/div&gt;\n</code></pre><p>angular里面也对数字验证进行了拓展，和上面一样，把<code>type</code>改为<code>number</code>，错误的返回值用<code>formName.inputName.$error.number</code>查看。可以在标签上设置属性<code>min</code>和<code>max</code>来设置最小值和最大值，返回值分别用<code>formName.inputName.$error.min</code>，和<code>formName.inputName.$error.max</code>查看。</p>\n<h3 id=\"checkbox\"><a href=\"#checkbox\" class=\"headerlink\" title=\"checkbox\"></a>checkbox</h3><p>HTML：</p>\n<pre><code>&lt;div class=&quot;form-group&quot;&gt;\n        &lt;label class=&quot;label-group&quot;&gt;爱好&lt;/label&gt;\n        &lt;label ng-repeat=&quot;hobby in hobbys&quot; class=&quot;checkbox-inline&quot;&gt;\n            &lt;input type=&quot;checkbox&quot; ng-checked=&quot;checked===undefined ? false : checked.indexOf(hobby.id)!==-1&quot; name=&quot;hobby&quot; ng-click=&quot;toggleSelect(hobby.id)&quot;&gt;{{hobby.name}}\n        &lt;/label&gt;\n&lt;/div&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.controller(&quot;myController&quot;,[&quot;$scope&quot;,function($scope){\n    $scope.hobbys = [\n    {\n        id: 1,\n        name: &quot;游戏&quot;\n    },\n    {\n        id: 2,\n        name: &quot;游戏2&quot;\n    },\n    {\n        id: 3,\n        name: &quot;游戏3&quot;\n    }\n];\n$scope.checked = [1, 2];\n$scope.toggleSelect = function (id) {\n    var index = -1;\n    if ($scope.checked === undefined) {\n        $scope.checked = [];\n    } else {\n        index = $scope.checked.indexOf(id);\n    }\n    if (index === -1) {\n        $scope.checked.push(id);\n    } else {\n        $scope.checked.splice(index, 1);\n    }\n}\n}]);\n</code></pre><p>这里的复选框我用了假数据(其实数据应该放在服务里面，我这里为了方便就放控制器里了)，然后用<code>ng-repeat</code>循环出来。然后用一个<code>checked</code>装已经选上爱好的<em>id</em>。下面的<code>toggleSelect</code>函数是判断<code>checked</code>数组里面是否有传进来的<em>id</em>如果没有，就加一个进去否则，删除一个。</p>\n<h2 id=\"城市三级关联\"><a href=\"#城市三级关联\" class=\"headerlink\" title=\"城市三级关联\"></a>城市三级关联</h2><p>HTML：</p>\n<pre><code>&lt;div class=&quot;form-group&quot;&gt;\n            &lt;label class=&quot;col-md-1 control-label&quot;&gt;出生地&lt;/label&gt;\n            &lt;div class=&quot;col-md-3&quot;&gt;\n                &lt;select class=&quot;form-control&quot; ng-change=&quot;area=false&quot; ng-model=&quot;city&quot; ng-options=&quot;x.id as x.name for x in cities | filterCity:0&quot;&gt;&lt;/select&gt;\n            &lt;/div&gt;\n            &lt;div ng-show=&quot;city&quot; class=&quot;col-md-3&quot;&gt;\n                &lt;select class=&quot;form-control&quot; ng-model=&quot;area&quot; ng-options=&quot;x.id as x.name for x in cities | filterCity:city&quot;&gt;&lt;/select&gt;\n            &lt;/div&gt;\n            &lt;div ng-show=&quot;area&amp;&amp;city&quot; class=&quot;col-md-3&quot;&gt;\n                &lt;select class=&quot;form-control&quot; ng-model=&quot;qu&quot; ng-options=&quot;x.id as x.name for x in cities | filterCity:area&quot;&gt;&lt;/select&gt;\n            &lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>JS：</p>\n<pre><code> myApp.controller(&quot;myController&quot;,[&quot;$scope&quot;,function($scope){\n     $scope.cities = [\n    {\n        name: &apos;上海&apos;,\n        parent: 0,\n        id: 1\n        },\n    {\n        name: &apos;上海市&apos;,\n        parent: 1,\n        id: 2\n        },\n    {\n        name: &apos;徐汇区&apos;,\n        parent: 2,\n        id: 8\n        },\n    {\n        name: &apos;长宁区&apos;,\n        parent: 2,\n        id: 3\n        },\n    {\n        name: &apos;北京&apos;,\n        parent: 0,\n        id: 4\n        },\n    {\n        name: &apos;北京市&apos;,\n        parent: 4,\n        id: 5\n        },\n    {\n        name: &apos;东城区&apos;,\n        parent: 5,\n        id: 6\n        },\n    {\n        name: &apos;丰台区&apos;,\n        parent: 5,\n        id: 7\n        },\n    {\n        name: &apos;浙江&apos;,\n        parent: 0,\n        id: 9\n        },\n    {\n        name: &apos;杭州&apos;,\n        parent: 9,\n        id: 100\n        },\n    {\n        name: &apos;宁波&apos;,\n        parent: 9,\n        id: 11\n        },\n    {\n        name: &apos;西湖区&apos;,\n        parent: 100,\n        id: 12\n        },\n    {\n        name: &apos;北仑区&apos;,\n        parent: 11,\n        id: 13\n        }\n    ];\n }]);\n myApp.filter(&quot;filterCity&quot;, function () {\n return function (city, par) {\n     var filterData = [];\n     angular.forEach(city, function (obj) {\n         if (obj.parent === par) {\n             filterData.push(obj);\n         }\n     });\n     return filterData;\n }\n});\n</code></pre><p>像这样，就做好了城市3级关联。</p>\n<p>在HTML中第一个下拉框有个<code>ng-change=&quot;area=false</code>，作用是：当这个下拉框的值改变时，第三个下拉框隐藏。</p>\n<p><code>ng-options</code>的作用和<code>ng-repeat</code>的作用类似，前者是循环创建<em>option</em>选项。可以看到它的值<code>x.id as x.name for x in cities</code>。<code>as</code>前面的值是<em>option</em>的<code>value</code>的值，后面的是用户可见的选项，<code>for</code>后面的表达式和<code>ng-repeat</code>的差不多。</p>\n<p>下面的两个下拉框分别用上一个下拉框的<code>ng-model</code>值来过滤选项。</p>\n<p>有些情况下，这三个单选框需要默认选中某个城市的某个区，这就要根据区来将父级城市选中，这时上面的JS部分增加几行代码变为：</p>\n<pre><code>myApp.controller(&quot;myController&quot;, [&quot;$scope&quot;, function ($scope) {\n $scope.cities = [\n     {\n         name: &apos;上海&apos;,\n         parent: 0,\n         id: 1\n        },\n     {\n         name: &apos;上海市&apos;,\n         parent: 1,\n         id: 2\n        },\n     {\n         name: &apos;徐汇区&apos;,\n         parent: 2,\n         id: 8\n        },\n     {\n         name: &apos;长宁区&apos;,\n         parent: 2,\n         id: 3\n        },\n     {\n         name: &apos;北京&apos;,\n         parent: 0,\n         id: 4\n        },\n     {\n         name: &apos;北京市&apos;,\n         parent: 4,\n         id: 5\n        },\n     {\n         name: &apos;东城区&apos;,\n         parent: 5,\n         id: 6\n        },\n     {\n         name: &apos;丰台区&apos;,\n         parent: 5,\n         id: 7\n        },\n     {\n         name: &apos;浙江&apos;,\n         parent: 0,\n         id: 9\n        },\n     {\n         name: &apos;杭州&apos;,\n         parent: 9,\n         id: 100\n        },\n     {\n         name: &apos;宁波&apos;,\n         parent: 9,\n         id: 11\n        },\n     {\n         name: &apos;西湖区&apos;,\n         parent: 100,\n         id: 12\n        },\n     {\n         name: &apos;北仑区&apos;,\n         parent: 11,\n         id: 13\n        }\n    ];\n $scope.qu = 3;\n $scope.parentCity = function (id) {\n     var parId;\n     if ($scope.qu !== undefined) {\n         angular.forEach($scope.cities, function (city) {\n             if (city.id === id) {\n                 parId = city.parent;\n                 return;\n             }\n         });\n     }\n     return parId;\n }\n     $scope.area = $scope.parentCity($scope.qu);\n     $scope.city = $scope.parentCity($scope.area);\n }]);\n myApp.filter(&quot;filterCity&quot;, function () {\n     return function (city, par) {\n         var filterData = [];\n         angular.forEach(city, function (obj) {\n             if (obj.parent === par) {\n                 filterData.push(obj);\n             }\n         });\n         return filterData;\n     }\n });\n</code></pre><h2 id=\"重置\"><a href=\"#重置\" class=\"headerlink\" title=\"重置\"></a>重置</h2><p>angular的重置和默认的重置又有些不同。angular的重置需要把<code>model</code>里的数据也要重置，而默认的重置还做不到这点。</p>\n<p>现在在原来的代码基础上将代码改为：</p>\n<p>HTML：</p>\n<pre><code>&lt;div class=&quot;form-group&quot;&gt;\n    &lt;button class=&quot;btn btn-info&quot; type=&quot;reset&quot; ng-click=&quot;reset()&quot;&gt;重置&lt;/button&gt;\n&lt;/div&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.controller(&quot;myController&quot;, [&quot;$scope&quot;, function ($scope) {\n $scope.cities = [\n     {\n         name: &apos;上海&apos;,\n         parent: 0,\n         id: 1\n        },\n     {\n         name: &apos;上海市&apos;,\n         parent: 1,\n         id: 2\n        },\n     {\n         name: &apos;徐汇区&apos;,\n         parent: 2,\n         id: 8\n        },\n     {\n         name: &apos;长宁区&apos;,\n         parent: 2,\n         id: 3\n        },\n     {\n         name: &apos;北京&apos;,\n         parent: 0,\n         id: 4\n        },\n     {\n         name: &apos;北京市&apos;,\n         parent: 4,\n         id: 5\n        },\n     {\n         name: &apos;东城区&apos;,\n         parent: 5,\n         id: 6\n        },\n     {\n         name: &apos;丰台区&apos;,\n         parent: 5,\n         id: 7\n        },\n     {\n         name: &apos;浙江&apos;,\n         parent: 0,\n         id: 9\n        },\n     {\n         name: &apos;杭州&apos;,\n         parent: 9,\n         id: 100\n        },\n     {\n         name: &apos;宁波&apos;,\n         parent: 9,\n         id: 11\n        },\n     {\n         name: &apos;西湖区&apos;,\n         parent: 100,\n         id: 12\n        },\n     {\n         name: &apos;北仑区&apos;,\n         parent: 11,\n         id: 13\n        }\n    ];\n $scope.init = function () {\n     $scope.qu = 3;\n     $scope.parentCity = function (id) {\n         var parId;\n         if ($scope.qu !== undefined) {\n             angular.forEach($scope.cities, function (city) {\n                 if (city.id === id) {\n                     parId = city.parent;\n                     return;\n                 }\n             });\n         }\n         return parId;\n     }\n     $scope.area = $scope.parentCity($scope.qu);\n     $scope.city = $scope.parentCity($scope.area);\n     $scope.copyQu = angular.copy($scope.qu);\n };\n $scope.reset = function () {\n     $scope.qu = angular.copy($scope.copyQu);\n     $scope.area = $scope.parentCity($scope.qu);\n     $scope.city = $scope.parentCity($scope.area);\n };\n $scope.init();\n }]);\n myApp.filter(&quot;filterCity&quot;, function () {\n     return function (city, par) {\n         var filterData = [];\n         angular.forEach(city, function (obj) {\n             if (obj.parent === par) {\n                 filterData.push(obj);\n             }\n         });\n         return filterData;\n     }\n });\n</code></pre><p>在JS中，我把城市三级关联的初始化放到了一个<code>init</code>函数中，并在下面将需要的数据备份，当重置按钮被点下时运行<code>reset</code>函数，将三个下拉框的数据重置回来(在重置的时候也用到了copy是为了防止原始值和copy值互相引用，保证了数据的安全)，但是当用户在上面的用户名输入有错误时点击重置会发现下面的错误提示并没有消失，这是因为<code>$error</code>没被重置，这个时候，需要在重置函数里加上<code>$scope.formName.$setPristine();</code>就可以吧表单恢复为原始的状态，这样重置就完成了。</p>\n<h2 id=\"自定义验证\"><a href=\"#自定义验证\" class=\"headerlink\" title=\"自定义验证\"></a>自定义验证</h2><p>在前面说了，angular可以自定义验证规则。在用自定义验证规则之前得要知道有个<code>ngModel</code>，它可以更深层地处理数据的双向绑定，可以通过设置自定义指令的<code>require</code>为<code>ngModel</code>取到，并且将<code>link</code>函数的第四个参数设置为<code>ngModelController</code></p>\n<p>HTML：</p>\n<pre><code>&lt;div class=&quot;form-group&quot; ng-class=&quot;{&apos;has-error&apos;:form.even.$dirty&amp;&amp;form.even.$invalid}&quot;&gt;\n            &lt;label class=&quot;control-label&quot;&gt;偶数&lt;/label&gt;\n            &lt;input autocomplete=&quot;off&quot; name=&quot;even&quot; type=&quot;number&quot; ng-model=&quot;even&quot; ng-required=&quot;true&quot; class=&quot;form-control&quot; placeholder=&quot;偶数&quot; even&gt;\n            &lt;div ng-show=&quot;form.even.$dirty&amp;&amp;form.even.$error.even&quot; class=&quot;alert alert-danger help-block&quot;&gt;\n                输入偶数\n            &lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.directive(&apos;even&apos;, [function () {\n     return {\n         restrict: &apos;A&apos;,\n         require:&quot;ngModel&quot;,\n         link: function (scope, element, attrs,ngModelController) {\n             console.log(ngModelController);\n         }\n     };\n     }]);\n</code></pre><p>可以看到在控制台会输出很多属性比如：</p>\n<pre><code>1. $formatters 保存的是从modelValue向viewValue绑定过程中的处理函数\n2. $setViewValue 当view发生了某件事情时，从view向model绑定调用$setViewValue把viewValue保存下来\n3. $render 当模型发生变化时，应该怎么去更新视图，从model向view绑定，调用ctrl.$render方法，将viewValue渲染到页面上\n4. $setValidity 设置验证结果，第一个参数是验证错误的名字，第二个是true or false\n5. $viewValue 视图的值\n6. $modelValue 模型里的值\n7. $parsers保存从viewValue向modelValue绑定过程中的处理函数，它们将来会依次执行\n</code></pre><p>这样就可以写自定义验证了，接下来，把JS代码改为：</p>\n<pre><code>myApp.directive(&apos;even&apos;, [function () {\n return {\n     restrict: &apos;A&apos;,\n     require: &quot;ngModel&quot;,\n     link: function (scope, element, attrs, ngModelController) {\n         console.log(ngModelController);\n         ngModelController.$parsers.push(function (viewValue) {\n             if (viewValue % 2 === 0) {\n                 ngModelController.$setValidity(&quot;even&quot;, true);\n                 return viewValue;\n             } else {\n                 ngModelController.$setValidity(&quot;even&quot;, false);\n             }\n         });\n     }\n };\n }]);\n</code></pre>"},{"title":"分享个人前端学习路线及面试经验","date":"2018-05-01T09:05:47.000Z","_content":"\n## 前言\n\n[个人主页](http://www.jayzangwill.cn/)\n[原文链接](https://jayzangwill.github.io/blog/2018/05/01/fe-summary/#more)\n[掘金](https://juejin.im/post/5ae980c9f265da0b767d485f)\n[知乎](https://zhuanlan.zhihu.com/p/36336162)&[知乎专栏](https://zhuanlan.zhihu.com/jayzangwill)\n\n本人从大二上学期到现在学习前端已将近有3年时间了，最近利用毕业论文写完的一些空余时间写一下这篇文章，用于分享一些**个人**的前端学习经验，以及一些面试经验，不一定适合每个人，不喜勿喷，同时欢迎大家提出建议。\n\n<!-- more-->\n\n## 学习路线\n\n总体的来说前端无非就是html、css、js只要把这三样的基础打好，什么都不是问题。他们的难易程度也是html < css < js，所以学习路线也是从html->css->js或者html&css->js。而我的学习路线是后者。\n\n总的来说，在学完一个新东西的时候建议最好用新东西手撸个玩意出来。一定要动手实操！\n\n### html&css\n\n首先这部分的学习我是看了一本叫[Head First HTML&CSS](https://book.douban.com/subject/25752357/)的书，这本电子书可以到网上下载。这本书与平时看到的书有点不一样，这本书相当是**手把手教**你如何完成一个静态网站，虽然书有点老，但是拿来入门还是不错的。\n\n看完这本书以后你的html&css基本上算是入门了，可以自己撸个个人主页或者博客什么的。看完书之后不动手撸个什么小玩意出来是不行的，光说不练等于白看。\n\n这个时候如果感觉还需要加深html&css的话推荐[精通CSS（第2版）](https://book.douban.com/subject/4736167/)这本书，能力强的同学可以去学学[bootstrap](https://v3.bootcss.com/)，这是大名鼎鼎的前端html&css框架。会用了（其实也就是html标签上bootstrap事先加定义好的类名，没太大难度）以后就去看看bootstrap的源码。注意，这里所说的源码不是吧boosstrap.css从头看到尾，那会疯的。看的源码是你用到的那几个类名的源码。可以通过谷歌控制台去看，选中一个标签，然后在styles那看人家是怎么定义这个样式的。\n\n![styles](/blog/img/summary/styles.png)\n\n感觉差不多以后就得实际操作了，可以到[这里](http://ife.baidu.com/2016/task/all)的最下面的第一阶段任务去练练手。\n\n![task](/blog/img/summary/task.png)\n\n个人感觉这第一阶段任务还是挺适合新手去做的。先尽量不要使用任何框架，自己去手撸出来。最后不管撸没撸出来都要去看看人家是怎么完成这项任务的，学习一下人家怎么解决问题的。前提一定是自己得先去思考。\n\n当然今年(2018年)的百度前端技术学院也是更加给力了，也有从0基础开始手把手教你如何完成一个页面。[传送门](http://ife.baidu.com/college/detail/id/5)\n\n### git&github\n\n这里插播一条git的学习指南，有的同学可能想要让自己的作品能让大家看到但是又没有自己的服务器的话怎么办？\n\n那么这里就得借助[github](https://github.com/)和github pages了。首先你得明白怎么用git&github，[这里有份教程](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001373962845513aefd77a99f4145f0a2c7a7ca057e7570000)，个人觉得还不错。\n\n知道git&github怎么用以后，就利用github pages让别人看到我们的作品。\n\n首先，利用git在本地创建gh-pages分支（注意：一定要是gh-pages分支），然后将各种资源用git推送到github对应仓库的gh-pages分支上（至于怎么操作不在这里详细说明，教程里已经说得很清楚了）\n\n推送成功以后浏览器打开github用户名.github.io/仓库名/对应的html。举个例子，我在github上的用户名是[JayZangwillJayZangwill](https://github.com/JayZangwill)，然后我的仓库名是blog，然后这个仓库下的gh-pages分支有个index.html文件，这个时候访问的地址就是[https://jayzangwill.github.io/blog/index.html](https://jayzangwill.github.io/blog/index.html)。因为github pages默认以index.html文件作为入口，所以以上链接可简写为[https://jayzangwill.github.io/blog](https://jayzangwill.github.io/blog)。\n\ngit&github是现代公司团队合作的重要工具，不管你处于前端的哪个阶段，git&github都是必学的，是逃不掉的。\n\n### js\n\n如果百度前端技术学院的16年第一部分任务能够做差不多出来就可以学js了，如果感觉还是没有什么收获的话就得去面壁过了。\n\n如果说html&css是餐前甜点的话js就是正餐了，js比html&css的难度高出不止一个档次，可能有些小伙伴看到js的时候就打算放弃了。这个时候建议不要慌，慢慢来节奏稍微慢一点。当时我刚看js的时候看的是看的是[Head First JavaScript](https://book.douban.com/subject/2372267/)，结果一点都看不懂，看到一半就放弃了。于是百度搜了前端js入门书籍，结果搜到了[JavaScript DOM编程艺术](https://book.douban.com/subject/6038371/)。这也是我比较推荐的一本入门书籍，如果能坚持看完，你的js就算入门了。\n\n当然js的学习路径有很多，以上的路径不一定适合所有人，也可以去网上搜些视频，比如去[慕课网](https://www.imooc.com/course/list?c=javascript&)上去看看。\n\n当感觉自己js学得差不多的时候可以找些练手的网站来加深对知识点的理解。个人推荐的网站有[2016百度前端技术学院第二部分js基础部分](http://ife.baidu.com/2016/task/all)，[Free Code Camp](https://freecodecamp.cn/home)。当遇到不认识的api或知识点时可以到[MDN](https://developer.mozilla.org/zh-CN/)上去查。\n\n感觉自己js基本功差不多了以后，下一步就开始学习es6或者jQuery了。由于前端三大框架的出现，导致jQuery的地位受到动摇，如果没有万恶的ie的话，jQuery很快就要退出历史舞台了。不过就目前情况来看，jQuery在前端还是占有很大份额的，所以学习jQuery还是很有必要的。学习jQuery的话我只推荐一本[Head First jQuery](https://book.douban.com/subject/6688828/)，看完这本书即可。对于es6来说这是js在15年出的新规范、新语法，内容较多所以可以单独抽出一块来学习，这里我推荐阮一峰前辈的[es6入门](http://es6.ruanyifeng.com/)。\n\n当es6看完以后就可以去学习前端的三大框架了，分别是Angular、Vue、React。当然也不是三个都要学，只需学好其中一个或者多个即可。就目前国内的情况来看Vue和React用的最多，而Vue相对React来说相对好学一点（ps:最近博主在学习React），所以我推荐的话Vue是比较好的一个切入点。另外附上[Vue的官方教程](https://cn.vuejs.org/v2/guide/)，个人认为官方教程已经写得很全面了，所以学Vue的话官方教程即可。React的话最近我也是在学习阶段，我这里就直接粘个[官方教程](https://doc.react-china.org/)吧。**注意**：学习它们之前一定要把es6看了，因为教程中用了一些es6的语法，为了防止文档看不懂，所以建议先把es6过了。\n\njs是我在大学中花的时间比较多的地方，也是前端最重要的部分，想要学好它，光是按照我上面说的是不够的，更多的是需要你不断在实践中总结，发现问题和解决问题。有必要时可以去看别人是怎么写js代码的，或者看看框架的源码，这样学到的才更多。\n\n### gulp&webpack\n\n当你在前端的道路上走了一段距离的时候会发现想要一些东西来提高自己的开发效率，gulp&webpack就能够满足你。这些自动化工具能够自动编译代码、压缩静态资源、自动刷新浏览器等。\n\n首先是gulp，gulp想要上手很容易，百度上搜一搜就有很多入门教程，这里推荐一篇[gulp入门教程](http://www.ydcss.com/archives/18)（我不会说我是从百度随便搜来的），虽然是我从百度上随便扒下来的但是足够入门了，毕竟gulp上手还是很容易的。这里还推荐一下我的[gulp配置](https://github.com/JayZangwill/myTools/tree/master/gulp)，能够满足大部分人的需求了。把gulpfile.js和package.json复制到本地，然后按照说明操作即可。\n\n另外附上[gulp的插件搜索地址](https://gulpjs.com/plugins/)，搜出来的插件都会告诉你如何去配置，一般情况下只需把介绍上的配置复制上来即可。如图是[gulp-uglify](https://www.npmjs.com/package/gulp-uglify)的介绍。\n\n![uglify](/blog/img/summary/uglify.png)\n\n至于webpack，它上手可能会比较难，因为配置会比较繁琐（webpack4据说把一些东西内置了，可以不用配置文件就可以用）觉得比较难的同学可以先把webpack先放一放，前期的话gulp基本就可以满足需求。学习webpack的话感觉还是看[官方文档](https://doc.webpack-china.org/concepts/)比较好。同时，大家可以看看我的[vue-cli多页面模板](https://github.com/JayZangwill/vue-multipage)。\n\n不过最近新出了个叫[parcel](https://parceljs.org/)的东西，号称极速零配置Web应用打包工具，大家可以了解一下。\n\n这里有人可能会问为什么不学grunt？emm...这东西已经是过时的产物，有兴趣的同学可以去了解了解，不论如何gulp&webpack最终还是必须要掌握的。\n\n### sass&less\n\nsass和less都是css的预编译语言，它们不必两个都学，学了其中一个另外一个自然就会。我个人的话是学了sass，是在[慕课网](https://www.imooc.com/search/?words=sass)上学的，学习的话只需学习前两个即可。\n\n![sass](/blog/img/summary/sass.png)\n\n至于less的话，看[官方文档](https://less.bootcss.com/)吧，less或sass学完以后可以尝试把以前写过的css用sass或者less重写一遍用于加深对知识的理解吧。另外我的那个gulp配置默认是支持sass的编译的，如果用了我的那个gulp配置的同学且是学sass的就不用自己配置了，如果学less的同学得需要自己配置一下。\n\n### nodejs\n\n如果还有余力的同学可以去学学node，目前有些公司对会node的前端是加分项，这里推荐一本书[了不起的nodejs](https://book.douban.com/subject/25767596/)\n\n### 一些学习网站推荐\n\n至此，前端需要掌握的技能和学习路线已经说完了。这里推荐一些前端的进阶网站和一些论坛，让大家在前端路上走得更远。\n\n1. [掘金](https://juejin.im/timeline) 在这里会有很多高质量的文章，我也经常在这逛的。\n2. [知乎](https://www.zhihu.com/) 这里是大佬的世界\n3. [stack overflow](https://stackoverflow.com/) 国外的一个超高质量技术论坛，你可以在这里提问，与国外大佬交流\n4. [SegmentFault](https://segmentfault.com/) 国内版的stack overflow\n5. [w3cplus](https://www.w3cplus.com/) 大漠老师创办的技术论坛\n6. [Free Code Camp](https://freecodecamp.cn/home) 在线学习网站\n7. [百度前端技术学院](http://ife.baidu.com/) 百度从15年到现在每年都会创办的技术学院\n8. [前端月报](https://github.com/jsfront/month) 这里会有人每个月上传上一个月的一些高质量文章\n9. [更多](https://www.zhihu.com/question/39503897)\n\n### 一些书籍\n\n1. [JavaScript高级程序设计（第3版）](https://book.douban.com/subject/10546125/) 红宝书，不解释，据说今年7月要出第四版，很期待啊。\n2. [JavaScript权威指南](https://book.douban.com/subject/2228378/) 传说中的犀牛书\n3. [你不知道的JavaScript](https://book.douban.com/subject/26351021/) 有上、中、下三卷\n4. [JavaScript语言精粹](https://book.douban.com/subject/3590768/) 传说中的蝴蝶书\n5. [JavaScript设计模式](https://book.douban.com/subject/3329540/)\n6. [css揭秘](https://book.douban.com/subject/26745943/) 介绍了一些实用的css3新特性\n7. [CSS权威指南（第三版）](https://book.douban.com/subject/2308234/)\n8. [更多](https://www.zhihu.com/question/19809484)\n\n## 面试知识点\n\n接下来这些面试知识点，主要是针对实习生和应届生的，偏基础。有多年工作经验或者基础好的同学可以Ctrl+W了。\n\n一般面试的时候面试官都是针对你简历上所写的来问，所以你会什么就写什么，不会的就别写上去了，以免面试的时候问到不会就尴尬了。\n\n### 计算机基础\n\n这里把计算机基础放在第一位是因为有很多人忽略计算机基础，前端是属于计算机行业的，不论什么方向，只要这个方向和计算机相关，就必须把计算机基础打好。同时，计算机基础也是面试官在面试实习生和应届生比较注重的一方面。\n\n#### 数据结构和算法\n\n数据结构在我面试印象中是考察得最多的计算机基础。\n\n首先是各种排序算法，冒泡啊，选择啊，快速啊一些常用排序算法，我不建议大家去死记硬背这些算法，而是去记它的思想，这样代码自然就会出来。完之后有些面试官会问它们的时间复杂度，怎么得出的这个个时间复杂度。\n\n然后到树的遍历，广度优先，前、中、后序遍历。\n\n还有就是斐波那契数列，算法的时间复杂度为O(n)和O(n^2)的两种实现。\n\n#### 计算机网络\n\ntcp的三次握手和四次挥手过程，以及为什么要三次握手，四次挥手。\n\nget和post的区别，建议看一下[这篇](http://www.techweb.com.cn/network/system/2016-10-11/2407736.shtml)文章。\n\nhttp与https区别。\n\ntcp与udp区别。\n\n7层网络架构。\n\n常见http状态码，301与302区别。304与200(form cache区别)，建议联系强制缓存与协商缓存来解释。\n\n#### 操作系统\n\n什么是进程，什么是线程以及他们的区别。\n\n什么是死锁，怎么产生的，怎么解决。\n\n### 前端面试知识点\n\n#### html部分\n\n这部分问的会比较少，因为实在没什么可以问的我所总结的知识点如下：\n\n1. 什么是html语义化，为什么要语义化，有什么好处，怎么做。\n2. html5新加的标签。\n3. 有哪些行内元素，有哪些块元素。\n\n#### css部分\n\n1. `inline`与`block`与`inline-block`区别（即行内元素与块元素与行内块元素的区别），以及`inline`与`inline-block`元素间会有莫名的间距这个是怎么产生的，怎么解决。\n2. position取值，以及他们之间的区别，而且是相对于谁定位的。父辈元素设置transform导致fixed定位失效情况。\n3. 浮动造成的问题，以及如何清除浮动，清除浮动的原理，由此引出BFC的概念，什么是BFC，有什么特性。\n4. 盒模型的组成，有哪些盒模型，以及如何互相转换。对于盒模型和定位的概念可以看我的[这篇](https://jayzangwill.github.io/blog/2016/12/15/CSS%20box%20model%20and%20location/)文章。\n5. `animation`和`transition`区别。\n6. `padding`和`margin`的单位设置为%时，这个%是相对于谁。\n7. 水平垂直居中的多种实现方式。\n8. css选择器的权重\n\n#### js部分\n\n之前也说了，js是前端最重要的部分，同时也是面试问的最多的，这里推荐我之前写的三篇文章：[几个让我印象深刻的面试题(一)](https://jayzangwill.github.io/blog/2017/03/01/Some%20of%20the%20interview%20questions%20that%20impressed%20me-1/)、[几个让我印象深刻的面试题(二)](https://jayzangwill.github.io/blog/2017/03/19/Some%20of%20the%20interview%20questions%20that%20impressed%20me-2/)、[四月北京面试之旅](https://jayzangwill.github.io/blog/2017/04/25/Interview%20in%20Beijing%20in%20April/)，同时js部分的知识点总结如下：\n\n1. js的数据类型（一共7种）\n2. this指向（注意严格模式下的this指向和箭头函数的this指向）\n3. new的过程\n4. 作用域与作用域链\n5. 什么是闭包，闭包的作用及缺点（建议与作用域联系起来讲）\n6. 原型与原型链，以及如何实现继承（多种实现方式，建议翻看红宝书继承部分或者看[我博客关于继承的讲解](https://jayzangwill.github.io/blog/2018/02/27/inherit/)，把es6的继承加上效果更佳）。\n7. js的事件循环即Event Loop（macro task queue 和 micro task queue了解一下，宏任务包括哪些，微任务包括哪些，以及它们的执行顺序）\n8. 前端跨域，什么情况会跨域，怎么解决，以及它们的优缺点，手写一下jsonp。\n9. XSS攻击与CSRF攻击怎么攻击以及怎么防御。这里推荐一下[这篇文章](https://segmentfault.com/a/1190000006672214)。\n10. 深拷贝与浅拷贝的区别，以及怎么实现（有的面试官会在这里问递归有什么缺点）。\n11. ajax的过程，以及状态0~4分别发生了什么（有的面试官会让你手写ajax）。\n12. es6新加的新特性。\n13. Promise的三个状态，以及介绍一下async函数。\n14. js事件的冒泡、捕获，及它们的区别，事件的三个过程。\n15. 浏览器的缓存机制（强制缓存cache-control、协商缓存if-modified，if-modified-since，e-tag了解一下）。\n16. cooike与session与localStorage、sessionStorage区别，以及localStorage和sessionStorage区别。\n\n#### vue部分（因为我简历上写了会vue）\n\n1. 双向数据绑定原理，这里推荐一下[这篇文章](https://juejin.im/post/5abdd6f6f265da23793c4458)\n2. vue的生命周期，这里推荐一下大漠老师的[这篇文章](https://mp.weixin.qq.com/s/JsVx4DwhPwcP8jU0uYHr-g)还有掘金上的[这篇文章](https://juejin.im/post/5ad10800f265da23826e681e)\n3. vue组件的数据传递（包括父->子、子->父，兄弟间，非兄弟）\n4. 前端路由的实现，这里推荐[这篇文章](https://juejin.im/post/5ac61da66fb9a028c71eae1b)\n\n## 结语\n\n本文写了前端的学习方向，还有前端的面试的重点，仅针对实习和应届的同学。知识点有漏的话会在后期补上。大家有什么想法可以在底下留言。","source":"_posts/fe-summary.md","raw":"---\ntitle: 分享个人前端学习路线及面试经验\ndate: 2018-05-01 17:05:47\ntags: [基础, javascript, html, css, 面试]\n---\n\n## 前言\n\n[个人主页](http://www.jayzangwill.cn/)\n[原文链接](https://jayzangwill.github.io/blog/2018/05/01/fe-summary/#more)\n[掘金](https://juejin.im/post/5ae980c9f265da0b767d485f)\n[知乎](https://zhuanlan.zhihu.com/p/36336162)&[知乎专栏](https://zhuanlan.zhihu.com/jayzangwill)\n\n本人从大二上学期到现在学习前端已将近有3年时间了，最近利用毕业论文写完的一些空余时间写一下这篇文章，用于分享一些**个人**的前端学习经验，以及一些面试经验，不一定适合每个人，不喜勿喷，同时欢迎大家提出建议。\n\n<!-- more-->\n\n## 学习路线\n\n总体的来说前端无非就是html、css、js只要把这三样的基础打好，什么都不是问题。他们的难易程度也是html < css < js，所以学习路线也是从html->css->js或者html&css->js。而我的学习路线是后者。\n\n总的来说，在学完一个新东西的时候建议最好用新东西手撸个玩意出来。一定要动手实操！\n\n### html&css\n\n首先这部分的学习我是看了一本叫[Head First HTML&CSS](https://book.douban.com/subject/25752357/)的书，这本电子书可以到网上下载。这本书与平时看到的书有点不一样，这本书相当是**手把手教**你如何完成一个静态网站，虽然书有点老，但是拿来入门还是不错的。\n\n看完这本书以后你的html&css基本上算是入门了，可以自己撸个个人主页或者博客什么的。看完书之后不动手撸个什么小玩意出来是不行的，光说不练等于白看。\n\n这个时候如果感觉还需要加深html&css的话推荐[精通CSS（第2版）](https://book.douban.com/subject/4736167/)这本书，能力强的同学可以去学学[bootstrap](https://v3.bootcss.com/)，这是大名鼎鼎的前端html&css框架。会用了（其实也就是html标签上bootstrap事先加定义好的类名，没太大难度）以后就去看看bootstrap的源码。注意，这里所说的源码不是吧boosstrap.css从头看到尾，那会疯的。看的源码是你用到的那几个类名的源码。可以通过谷歌控制台去看，选中一个标签，然后在styles那看人家是怎么定义这个样式的。\n\n![styles](/blog/img/summary/styles.png)\n\n感觉差不多以后就得实际操作了，可以到[这里](http://ife.baidu.com/2016/task/all)的最下面的第一阶段任务去练练手。\n\n![task](/blog/img/summary/task.png)\n\n个人感觉这第一阶段任务还是挺适合新手去做的。先尽量不要使用任何框架，自己去手撸出来。最后不管撸没撸出来都要去看看人家是怎么完成这项任务的，学习一下人家怎么解决问题的。前提一定是自己得先去思考。\n\n当然今年(2018年)的百度前端技术学院也是更加给力了，也有从0基础开始手把手教你如何完成一个页面。[传送门](http://ife.baidu.com/college/detail/id/5)\n\n### git&github\n\n这里插播一条git的学习指南，有的同学可能想要让自己的作品能让大家看到但是又没有自己的服务器的话怎么办？\n\n那么这里就得借助[github](https://github.com/)和github pages了。首先你得明白怎么用git&github，[这里有份教程](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001373962845513aefd77a99f4145f0a2c7a7ca057e7570000)，个人觉得还不错。\n\n知道git&github怎么用以后，就利用github pages让别人看到我们的作品。\n\n首先，利用git在本地创建gh-pages分支（注意：一定要是gh-pages分支），然后将各种资源用git推送到github对应仓库的gh-pages分支上（至于怎么操作不在这里详细说明，教程里已经说得很清楚了）\n\n推送成功以后浏览器打开github用户名.github.io/仓库名/对应的html。举个例子，我在github上的用户名是[JayZangwillJayZangwill](https://github.com/JayZangwill)，然后我的仓库名是blog，然后这个仓库下的gh-pages分支有个index.html文件，这个时候访问的地址就是[https://jayzangwill.github.io/blog/index.html](https://jayzangwill.github.io/blog/index.html)。因为github pages默认以index.html文件作为入口，所以以上链接可简写为[https://jayzangwill.github.io/blog](https://jayzangwill.github.io/blog)。\n\ngit&github是现代公司团队合作的重要工具，不管你处于前端的哪个阶段，git&github都是必学的，是逃不掉的。\n\n### js\n\n如果百度前端技术学院的16年第一部分任务能够做差不多出来就可以学js了，如果感觉还是没有什么收获的话就得去面壁过了。\n\n如果说html&css是餐前甜点的话js就是正餐了，js比html&css的难度高出不止一个档次，可能有些小伙伴看到js的时候就打算放弃了。这个时候建议不要慌，慢慢来节奏稍微慢一点。当时我刚看js的时候看的是看的是[Head First JavaScript](https://book.douban.com/subject/2372267/)，结果一点都看不懂，看到一半就放弃了。于是百度搜了前端js入门书籍，结果搜到了[JavaScript DOM编程艺术](https://book.douban.com/subject/6038371/)。这也是我比较推荐的一本入门书籍，如果能坚持看完，你的js就算入门了。\n\n当然js的学习路径有很多，以上的路径不一定适合所有人，也可以去网上搜些视频，比如去[慕课网](https://www.imooc.com/course/list?c=javascript&)上去看看。\n\n当感觉自己js学得差不多的时候可以找些练手的网站来加深对知识点的理解。个人推荐的网站有[2016百度前端技术学院第二部分js基础部分](http://ife.baidu.com/2016/task/all)，[Free Code Camp](https://freecodecamp.cn/home)。当遇到不认识的api或知识点时可以到[MDN](https://developer.mozilla.org/zh-CN/)上去查。\n\n感觉自己js基本功差不多了以后，下一步就开始学习es6或者jQuery了。由于前端三大框架的出现，导致jQuery的地位受到动摇，如果没有万恶的ie的话，jQuery很快就要退出历史舞台了。不过就目前情况来看，jQuery在前端还是占有很大份额的，所以学习jQuery还是很有必要的。学习jQuery的话我只推荐一本[Head First jQuery](https://book.douban.com/subject/6688828/)，看完这本书即可。对于es6来说这是js在15年出的新规范、新语法，内容较多所以可以单独抽出一块来学习，这里我推荐阮一峰前辈的[es6入门](http://es6.ruanyifeng.com/)。\n\n当es6看完以后就可以去学习前端的三大框架了，分别是Angular、Vue、React。当然也不是三个都要学，只需学好其中一个或者多个即可。就目前国内的情况来看Vue和React用的最多，而Vue相对React来说相对好学一点（ps:最近博主在学习React），所以我推荐的话Vue是比较好的一个切入点。另外附上[Vue的官方教程](https://cn.vuejs.org/v2/guide/)，个人认为官方教程已经写得很全面了，所以学Vue的话官方教程即可。React的话最近我也是在学习阶段，我这里就直接粘个[官方教程](https://doc.react-china.org/)吧。**注意**：学习它们之前一定要把es6看了，因为教程中用了一些es6的语法，为了防止文档看不懂，所以建议先把es6过了。\n\njs是我在大学中花的时间比较多的地方，也是前端最重要的部分，想要学好它，光是按照我上面说的是不够的，更多的是需要你不断在实践中总结，发现问题和解决问题。有必要时可以去看别人是怎么写js代码的，或者看看框架的源码，这样学到的才更多。\n\n### gulp&webpack\n\n当你在前端的道路上走了一段距离的时候会发现想要一些东西来提高自己的开发效率，gulp&webpack就能够满足你。这些自动化工具能够自动编译代码、压缩静态资源、自动刷新浏览器等。\n\n首先是gulp，gulp想要上手很容易，百度上搜一搜就有很多入门教程，这里推荐一篇[gulp入门教程](http://www.ydcss.com/archives/18)（我不会说我是从百度随便搜来的），虽然是我从百度上随便扒下来的但是足够入门了，毕竟gulp上手还是很容易的。这里还推荐一下我的[gulp配置](https://github.com/JayZangwill/myTools/tree/master/gulp)，能够满足大部分人的需求了。把gulpfile.js和package.json复制到本地，然后按照说明操作即可。\n\n另外附上[gulp的插件搜索地址](https://gulpjs.com/plugins/)，搜出来的插件都会告诉你如何去配置，一般情况下只需把介绍上的配置复制上来即可。如图是[gulp-uglify](https://www.npmjs.com/package/gulp-uglify)的介绍。\n\n![uglify](/blog/img/summary/uglify.png)\n\n至于webpack，它上手可能会比较难，因为配置会比较繁琐（webpack4据说把一些东西内置了，可以不用配置文件就可以用）觉得比较难的同学可以先把webpack先放一放，前期的话gulp基本就可以满足需求。学习webpack的话感觉还是看[官方文档](https://doc.webpack-china.org/concepts/)比较好。同时，大家可以看看我的[vue-cli多页面模板](https://github.com/JayZangwill/vue-multipage)。\n\n不过最近新出了个叫[parcel](https://parceljs.org/)的东西，号称极速零配置Web应用打包工具，大家可以了解一下。\n\n这里有人可能会问为什么不学grunt？emm...这东西已经是过时的产物，有兴趣的同学可以去了解了解，不论如何gulp&webpack最终还是必须要掌握的。\n\n### sass&less\n\nsass和less都是css的预编译语言，它们不必两个都学，学了其中一个另外一个自然就会。我个人的话是学了sass，是在[慕课网](https://www.imooc.com/search/?words=sass)上学的，学习的话只需学习前两个即可。\n\n![sass](/blog/img/summary/sass.png)\n\n至于less的话，看[官方文档](https://less.bootcss.com/)吧，less或sass学完以后可以尝试把以前写过的css用sass或者less重写一遍用于加深对知识的理解吧。另外我的那个gulp配置默认是支持sass的编译的，如果用了我的那个gulp配置的同学且是学sass的就不用自己配置了，如果学less的同学得需要自己配置一下。\n\n### nodejs\n\n如果还有余力的同学可以去学学node，目前有些公司对会node的前端是加分项，这里推荐一本书[了不起的nodejs](https://book.douban.com/subject/25767596/)\n\n### 一些学习网站推荐\n\n至此，前端需要掌握的技能和学习路线已经说完了。这里推荐一些前端的进阶网站和一些论坛，让大家在前端路上走得更远。\n\n1. [掘金](https://juejin.im/timeline) 在这里会有很多高质量的文章，我也经常在这逛的。\n2. [知乎](https://www.zhihu.com/) 这里是大佬的世界\n3. [stack overflow](https://stackoverflow.com/) 国外的一个超高质量技术论坛，你可以在这里提问，与国外大佬交流\n4. [SegmentFault](https://segmentfault.com/) 国内版的stack overflow\n5. [w3cplus](https://www.w3cplus.com/) 大漠老师创办的技术论坛\n6. [Free Code Camp](https://freecodecamp.cn/home) 在线学习网站\n7. [百度前端技术学院](http://ife.baidu.com/) 百度从15年到现在每年都会创办的技术学院\n8. [前端月报](https://github.com/jsfront/month) 这里会有人每个月上传上一个月的一些高质量文章\n9. [更多](https://www.zhihu.com/question/39503897)\n\n### 一些书籍\n\n1. [JavaScript高级程序设计（第3版）](https://book.douban.com/subject/10546125/) 红宝书，不解释，据说今年7月要出第四版，很期待啊。\n2. [JavaScript权威指南](https://book.douban.com/subject/2228378/) 传说中的犀牛书\n3. [你不知道的JavaScript](https://book.douban.com/subject/26351021/) 有上、中、下三卷\n4. [JavaScript语言精粹](https://book.douban.com/subject/3590768/) 传说中的蝴蝶书\n5. [JavaScript设计模式](https://book.douban.com/subject/3329540/)\n6. [css揭秘](https://book.douban.com/subject/26745943/) 介绍了一些实用的css3新特性\n7. [CSS权威指南（第三版）](https://book.douban.com/subject/2308234/)\n8. [更多](https://www.zhihu.com/question/19809484)\n\n## 面试知识点\n\n接下来这些面试知识点，主要是针对实习生和应届生的，偏基础。有多年工作经验或者基础好的同学可以Ctrl+W了。\n\n一般面试的时候面试官都是针对你简历上所写的来问，所以你会什么就写什么，不会的就别写上去了，以免面试的时候问到不会就尴尬了。\n\n### 计算机基础\n\n这里把计算机基础放在第一位是因为有很多人忽略计算机基础，前端是属于计算机行业的，不论什么方向，只要这个方向和计算机相关，就必须把计算机基础打好。同时，计算机基础也是面试官在面试实习生和应届生比较注重的一方面。\n\n#### 数据结构和算法\n\n数据结构在我面试印象中是考察得最多的计算机基础。\n\n首先是各种排序算法，冒泡啊，选择啊，快速啊一些常用排序算法，我不建议大家去死记硬背这些算法，而是去记它的思想，这样代码自然就会出来。完之后有些面试官会问它们的时间复杂度，怎么得出的这个个时间复杂度。\n\n然后到树的遍历，广度优先，前、中、后序遍历。\n\n还有就是斐波那契数列，算法的时间复杂度为O(n)和O(n^2)的两种实现。\n\n#### 计算机网络\n\ntcp的三次握手和四次挥手过程，以及为什么要三次握手，四次挥手。\n\nget和post的区别，建议看一下[这篇](http://www.techweb.com.cn/network/system/2016-10-11/2407736.shtml)文章。\n\nhttp与https区别。\n\ntcp与udp区别。\n\n7层网络架构。\n\n常见http状态码，301与302区别。304与200(form cache区别)，建议联系强制缓存与协商缓存来解释。\n\n#### 操作系统\n\n什么是进程，什么是线程以及他们的区别。\n\n什么是死锁，怎么产生的，怎么解决。\n\n### 前端面试知识点\n\n#### html部分\n\n这部分问的会比较少，因为实在没什么可以问的我所总结的知识点如下：\n\n1. 什么是html语义化，为什么要语义化，有什么好处，怎么做。\n2. html5新加的标签。\n3. 有哪些行内元素，有哪些块元素。\n\n#### css部分\n\n1. `inline`与`block`与`inline-block`区别（即行内元素与块元素与行内块元素的区别），以及`inline`与`inline-block`元素间会有莫名的间距这个是怎么产生的，怎么解决。\n2. position取值，以及他们之间的区别，而且是相对于谁定位的。父辈元素设置transform导致fixed定位失效情况。\n3. 浮动造成的问题，以及如何清除浮动，清除浮动的原理，由此引出BFC的概念，什么是BFC，有什么特性。\n4. 盒模型的组成，有哪些盒模型，以及如何互相转换。对于盒模型和定位的概念可以看我的[这篇](https://jayzangwill.github.io/blog/2016/12/15/CSS%20box%20model%20and%20location/)文章。\n5. `animation`和`transition`区别。\n6. `padding`和`margin`的单位设置为%时，这个%是相对于谁。\n7. 水平垂直居中的多种实现方式。\n8. css选择器的权重\n\n#### js部分\n\n之前也说了，js是前端最重要的部分，同时也是面试问的最多的，这里推荐我之前写的三篇文章：[几个让我印象深刻的面试题(一)](https://jayzangwill.github.io/blog/2017/03/01/Some%20of%20the%20interview%20questions%20that%20impressed%20me-1/)、[几个让我印象深刻的面试题(二)](https://jayzangwill.github.io/blog/2017/03/19/Some%20of%20the%20interview%20questions%20that%20impressed%20me-2/)、[四月北京面试之旅](https://jayzangwill.github.io/blog/2017/04/25/Interview%20in%20Beijing%20in%20April/)，同时js部分的知识点总结如下：\n\n1. js的数据类型（一共7种）\n2. this指向（注意严格模式下的this指向和箭头函数的this指向）\n3. new的过程\n4. 作用域与作用域链\n5. 什么是闭包，闭包的作用及缺点（建议与作用域联系起来讲）\n6. 原型与原型链，以及如何实现继承（多种实现方式，建议翻看红宝书继承部分或者看[我博客关于继承的讲解](https://jayzangwill.github.io/blog/2018/02/27/inherit/)，把es6的继承加上效果更佳）。\n7. js的事件循环即Event Loop（macro task queue 和 micro task queue了解一下，宏任务包括哪些，微任务包括哪些，以及它们的执行顺序）\n8. 前端跨域，什么情况会跨域，怎么解决，以及它们的优缺点，手写一下jsonp。\n9. XSS攻击与CSRF攻击怎么攻击以及怎么防御。这里推荐一下[这篇文章](https://segmentfault.com/a/1190000006672214)。\n10. 深拷贝与浅拷贝的区别，以及怎么实现（有的面试官会在这里问递归有什么缺点）。\n11. ajax的过程，以及状态0~4分别发生了什么（有的面试官会让你手写ajax）。\n12. es6新加的新特性。\n13. Promise的三个状态，以及介绍一下async函数。\n14. js事件的冒泡、捕获，及它们的区别，事件的三个过程。\n15. 浏览器的缓存机制（强制缓存cache-control、协商缓存if-modified，if-modified-since，e-tag了解一下）。\n16. cooike与session与localStorage、sessionStorage区别，以及localStorage和sessionStorage区别。\n\n#### vue部分（因为我简历上写了会vue）\n\n1. 双向数据绑定原理，这里推荐一下[这篇文章](https://juejin.im/post/5abdd6f6f265da23793c4458)\n2. vue的生命周期，这里推荐一下大漠老师的[这篇文章](https://mp.weixin.qq.com/s/JsVx4DwhPwcP8jU0uYHr-g)还有掘金上的[这篇文章](https://juejin.im/post/5ad10800f265da23826e681e)\n3. vue组件的数据传递（包括父->子、子->父，兄弟间，非兄弟）\n4. 前端路由的实现，这里推荐[这篇文章](https://juejin.im/post/5ac61da66fb9a028c71eae1b)\n\n## 结语\n\n本文写了前端的学习方向，还有前端的面试的重点，仅针对实习和应届的同学。知识点有漏的话会在后期补上。大家有什么想法可以在底下留言。","slug":"fe-summary","published":1,"updated":"2020-04-07T03:29:17.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8qzc34h000d2cl6w7q7o5f2","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><a href=\"http://www.jayzangwill.cn/\" target=\"_blank\" rel=\"noopener\">个人主页</a><br><a href=\"https://jayzangwill.github.io/blog/2018/05/01/fe-summary/#more\">原文链接</a><br><a href=\"https://juejin.im/post/5ae980c9f265da0b767d485f\" target=\"_blank\" rel=\"noopener\">掘金</a><br><a href=\"https://zhuanlan.zhihu.com/p/36336162\" target=\"_blank\" rel=\"noopener\">知乎</a>&amp;<a href=\"https://zhuanlan.zhihu.com/jayzangwill\" target=\"_blank\" rel=\"noopener\">知乎专栏</a></p>\n<p>本人从大二上学期到现在学习前端已将近有3年时间了，最近利用毕业论文写完的一些空余时间写一下这篇文章，用于分享一些<strong>个人</strong>的前端学习经验，以及一些面试经验，不一定适合每个人，不喜勿喷，同时欢迎大家提出建议。</p>\n<a id=\"more\"></a>\n<h2 id=\"学习路线\"><a href=\"#学习路线\" class=\"headerlink\" title=\"学习路线\"></a>学习路线</h2><p>总体的来说前端无非就是html、css、js只要把这三样的基础打好，什么都不是问题。他们的难易程度也是html &lt; css &lt; js，所以学习路线也是从html-&gt;css-&gt;js或者html&amp;css-&gt;js。而我的学习路线是后者。</p>\n<p>总的来说，在学完一个新东西的时候建议最好用新东西手撸个玩意出来。一定要动手实操！</p>\n<h3 id=\"html-amp-css\"><a href=\"#html-amp-css\" class=\"headerlink\" title=\"html&amp;css\"></a>html&amp;css</h3><p>首先这部分的学习我是看了一本叫<a href=\"https://book.douban.com/subject/25752357/\" target=\"_blank\" rel=\"noopener\">Head First HTML&amp;CSS</a>的书，这本电子书可以到网上下载。这本书与平时看到的书有点不一样，这本书相当是<strong>手把手教</strong>你如何完成一个静态网站，虽然书有点老，但是拿来入门还是不错的。</p>\n<p>看完这本书以后你的html&amp;css基本上算是入门了，可以自己撸个个人主页或者博客什么的。看完书之后不动手撸个什么小玩意出来是不行的，光说不练等于白看。</p>\n<p>这个时候如果感觉还需要加深html&amp;css的话推荐<a href=\"https://book.douban.com/subject/4736167/\" target=\"_blank\" rel=\"noopener\">精通CSS（第2版）</a>这本书，能力强的同学可以去学学<a href=\"https://v3.bootcss.com/\" target=\"_blank\" rel=\"noopener\">bootstrap</a>，这是大名鼎鼎的前端html&amp;css框架。会用了（其实也就是html标签上bootstrap事先加定义好的类名，没太大难度）以后就去看看bootstrap的源码。注意，这里所说的源码不是吧boosstrap.css从头看到尾，那会疯的。看的源码是你用到的那几个类名的源码。可以通过谷歌控制台去看，选中一个标签，然后在styles那看人家是怎么定义这个样式的。</p>\n<p><img src=\"/blog/img/summary/styles.png\" alt=\"styles\"></p>\n<p>感觉差不多以后就得实际操作了，可以到<a href=\"http://ife.baidu.com/2016/task/all\" target=\"_blank\" rel=\"noopener\">这里</a>的最下面的第一阶段任务去练练手。</p>\n<p><img src=\"/blog/img/summary/task.png\" alt=\"task\"></p>\n<p>个人感觉这第一阶段任务还是挺适合新手去做的。先尽量不要使用任何框架，自己去手撸出来。最后不管撸没撸出来都要去看看人家是怎么完成这项任务的，学习一下人家怎么解决问题的。前提一定是自己得先去思考。</p>\n<p>当然今年(2018年)的百度前端技术学院也是更加给力了，也有从0基础开始手把手教你如何完成一个页面。<a href=\"http://ife.baidu.com/college/detail/id/5\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n<h3 id=\"git-amp-github\"><a href=\"#git-amp-github\" class=\"headerlink\" title=\"git&amp;github\"></a>git&amp;github</h3><p>这里插播一条git的学习指南，有的同学可能想要让自己的作品能让大家看到但是又没有自己的服务器的话怎么办？</p>\n<p>那么这里就得借助<a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">github</a>和github pages了。首先你得明白怎么用git&amp;github，<a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001373962845513aefd77a99f4145f0a2c7a7ca057e7570000\" target=\"_blank\" rel=\"noopener\">这里有份教程</a>，个人觉得还不错。</p>\n<p>知道git&amp;github怎么用以后，就利用github pages让别人看到我们的作品。</p>\n<p>首先，利用git在本地创建gh-pages分支（注意：一定要是gh-pages分支），然后将各种资源用git推送到github对应仓库的gh-pages分支上（至于怎么操作不在这里详细说明，教程里已经说得很清楚了）</p>\n<p>推送成功以后浏览器打开github用户名.github.io/仓库名/对应的html。举个例子，我在github上的用户名是<a href=\"https://github.com/JayZangwill\" target=\"_blank\" rel=\"noopener\">JayZangwillJayZangwill</a>，然后我的仓库名是blog，然后这个仓库下的gh-pages分支有个index.html文件，这个时候访问的地址就是<a href=\"https://jayzangwill.github.io/blog/index.html\">https://jayzangwill.github.io/blog/index.html</a>。因为github pages默认以index.html文件作为入口，所以以上链接可简写为<a href=\"https://jayzangwill.github.io/blog\">https://jayzangwill.github.io/blog</a>。</p>\n<p>git&amp;github是现代公司团队合作的重要工具，不管你处于前端的哪个阶段，git&amp;github都是必学的，是逃不掉的。</p>\n<h3 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h3><p>如果百度前端技术学院的16年第一部分任务能够做差不多出来就可以学js了，如果感觉还是没有什么收获的话就得去面壁过了。</p>\n<p>如果说html&amp;css是餐前甜点的话js就是正餐了，js比html&amp;css的难度高出不止一个档次，可能有些小伙伴看到js的时候就打算放弃了。这个时候建议不要慌，慢慢来节奏稍微慢一点。当时我刚看js的时候看的是看的是<a href=\"https://book.douban.com/subject/2372267/\" target=\"_blank\" rel=\"noopener\">Head First JavaScript</a>，结果一点都看不懂，看到一半就放弃了。于是百度搜了前端js入门书籍，结果搜到了<a href=\"https://book.douban.com/subject/6038371/\" target=\"_blank\" rel=\"noopener\">JavaScript DOM编程艺术</a>。这也是我比较推荐的一本入门书籍，如果能坚持看完，你的js就算入门了。</p>\n<p>当然js的学习路径有很多，以上的路径不一定适合所有人，也可以去网上搜些视频，比如去<a href=\"https://www.imooc.com/course/list?c=javascript&amp;\" target=\"_blank\" rel=\"noopener\">慕课网</a>上去看看。</p>\n<p>当感觉自己js学得差不多的时候可以找些练手的网站来加深对知识点的理解。个人推荐的网站有<a href=\"http://ife.baidu.com/2016/task/all\" target=\"_blank\" rel=\"noopener\">2016百度前端技术学院第二部分js基础部分</a>，<a href=\"https://freecodecamp.cn/home\" target=\"_blank\" rel=\"noopener\">Free Code Camp</a>。当遇到不认识的api或知识点时可以到<a href=\"https://developer.mozilla.org/zh-CN/\" target=\"_blank\" rel=\"noopener\">MDN</a>上去查。</p>\n<p>感觉自己js基本功差不多了以后，下一步就开始学习es6或者jQuery了。由于前端三大框架的出现，导致jQuery的地位受到动摇，如果没有万恶的ie的话，jQuery很快就要退出历史舞台了。不过就目前情况来看，jQuery在前端还是占有很大份额的，所以学习jQuery还是很有必要的。学习jQuery的话我只推荐一本<a href=\"https://book.douban.com/subject/6688828/\" target=\"_blank\" rel=\"noopener\">Head First jQuery</a>，看完这本书即可。对于es6来说这是js在15年出的新规范、新语法，内容较多所以可以单独抽出一块来学习，这里我推荐阮一峰前辈的<a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">es6入门</a>。</p>\n<p>当es6看完以后就可以去学习前端的三大框架了，分别是Angular、Vue、React。当然也不是三个都要学，只需学好其中一个或者多个即可。就目前国内的情况来看Vue和React用的最多，而Vue相对React来说相对好学一点（ps:最近博主在学习React），所以我推荐的话Vue是比较好的一个切入点。另外附上<a href=\"https://cn.vuejs.org/v2/guide/\" target=\"_blank\" rel=\"noopener\">Vue的官方教程</a>，个人认为官方教程已经写得很全面了，所以学Vue的话官方教程即可。React的话最近我也是在学习阶段，我这里就直接粘个<a href=\"https://doc.react-china.org/\" target=\"_blank\" rel=\"noopener\">官方教程</a>吧。<strong>注意</strong>：学习它们之前一定要把es6看了，因为教程中用了一些es6的语法，为了防止文档看不懂，所以建议先把es6过了。</p>\n<p>js是我在大学中花的时间比较多的地方，也是前端最重要的部分，想要学好它，光是按照我上面说的是不够的，更多的是需要你不断在实践中总结，发现问题和解决问题。有必要时可以去看别人是怎么写js代码的，或者看看框架的源码，这样学到的才更多。</p>\n<h3 id=\"gulp-amp-webpack\"><a href=\"#gulp-amp-webpack\" class=\"headerlink\" title=\"gulp&amp;webpack\"></a>gulp&amp;webpack</h3><p>当你在前端的道路上走了一段距离的时候会发现想要一些东西来提高自己的开发效率，gulp&amp;webpack就能够满足你。这些自动化工具能够自动编译代码、压缩静态资源、自动刷新浏览器等。</p>\n<p>首先是gulp，gulp想要上手很容易，百度上搜一搜就有很多入门教程，这里推荐一篇<a href=\"http://www.ydcss.com/archives/18\" target=\"_blank\" rel=\"noopener\">gulp入门教程</a>（我不会说我是从百度随便搜来的），虽然是我从百度上随便扒下来的但是足够入门了，毕竟gulp上手还是很容易的。这里还推荐一下我的<a href=\"https://github.com/JayZangwill/myTools/tree/master/gulp\" target=\"_blank\" rel=\"noopener\">gulp配置</a>，能够满足大部分人的需求了。把gulpfile.js和package.json复制到本地，然后按照说明操作即可。</p>\n<p>另外附上<a href=\"https://gulpjs.com/plugins/\" target=\"_blank\" rel=\"noopener\">gulp的插件搜索地址</a>，搜出来的插件都会告诉你如何去配置，一般情况下只需把介绍上的配置复制上来即可。如图是<a href=\"https://www.npmjs.com/package/gulp-uglify\" target=\"_blank\" rel=\"noopener\">gulp-uglify</a>的介绍。</p>\n<p><img src=\"/blog/img/summary/uglify.png\" alt=\"uglify\"></p>\n<p>至于webpack，它上手可能会比较难，因为配置会比较繁琐（webpack4据说把一些东西内置了，可以不用配置文件就可以用）觉得比较难的同学可以先把webpack先放一放，前期的话gulp基本就可以满足需求。学习webpack的话感觉还是看<a href=\"https://doc.webpack-china.org/concepts/\" target=\"_blank\" rel=\"noopener\">官方文档</a>比较好。同时，大家可以看看我的<a href=\"https://github.com/JayZangwill/vue-multipage\" target=\"_blank\" rel=\"noopener\">vue-cli多页面模板</a>。</p>\n<p>不过最近新出了个叫<a href=\"https://parceljs.org/\" target=\"_blank\" rel=\"noopener\">parcel</a>的东西，号称极速零配置Web应用打包工具，大家可以了解一下。</p>\n<p>这里有人可能会问为什么不学grunt？emm…这东西已经是过时的产物，有兴趣的同学可以去了解了解，不论如何gulp&amp;webpack最终还是必须要掌握的。</p>\n<h3 id=\"sass-amp-less\"><a href=\"#sass-amp-less\" class=\"headerlink\" title=\"sass&amp;less\"></a>sass&amp;less</h3><p>sass和less都是css的预编译语言，它们不必两个都学，学了其中一个另外一个自然就会。我个人的话是学了sass，是在<a href=\"https://www.imooc.com/search/?words=sass\" target=\"_blank\" rel=\"noopener\">慕课网</a>上学的，学习的话只需学习前两个即可。</p>\n<p><img src=\"/blog/img/summary/sass.png\" alt=\"sass\"></p>\n<p>至于less的话，看<a href=\"https://less.bootcss.com/\" target=\"_blank\" rel=\"noopener\">官方文档</a>吧，less或sass学完以后可以尝试把以前写过的css用sass或者less重写一遍用于加深对知识的理解吧。另外我的那个gulp配置默认是支持sass的编译的，如果用了我的那个gulp配置的同学且是学sass的就不用自己配置了，如果学less的同学得需要自己配置一下。</p>\n<h3 id=\"nodejs\"><a href=\"#nodejs\" class=\"headerlink\" title=\"nodejs\"></a>nodejs</h3><p>如果还有余力的同学可以去学学node，目前有些公司对会node的前端是加分项，这里推荐一本书<a href=\"https://book.douban.com/subject/25767596/\" target=\"_blank\" rel=\"noopener\">了不起的nodejs</a></p>\n<h3 id=\"一些学习网站推荐\"><a href=\"#一些学习网站推荐\" class=\"headerlink\" title=\"一些学习网站推荐\"></a>一些学习网站推荐</h3><p>至此，前端需要掌握的技能和学习路线已经说完了。这里推荐一些前端的进阶网站和一些论坛，让大家在前端路上走得更远。</p>\n<ol>\n<li><a href=\"https://juejin.im/timeline\" target=\"_blank\" rel=\"noopener\">掘金</a> 在这里会有很多高质量的文章，我也经常在这逛的。</li>\n<li><a href=\"https://www.zhihu.com/\" target=\"_blank\" rel=\"noopener\">知乎</a> 这里是大佬的世界</li>\n<li><a href=\"https://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">stack overflow</a> 国外的一个超高质量技术论坛，你可以在这里提问，与国外大佬交流</li>\n<li><a href=\"https://segmentfault.com/\" target=\"_blank\" rel=\"noopener\">SegmentFault</a> 国内版的stack overflow</li>\n<li><a href=\"https://www.w3cplus.com/\" target=\"_blank\" rel=\"noopener\">w3cplus</a> 大漠老师创办的技术论坛</li>\n<li><a href=\"https://freecodecamp.cn/home\" target=\"_blank\" rel=\"noopener\">Free Code Camp</a> 在线学习网站</li>\n<li><a href=\"http://ife.baidu.com/\" target=\"_blank\" rel=\"noopener\">百度前端技术学院</a> 百度从15年到现在每年都会创办的技术学院</li>\n<li><a href=\"https://github.com/jsfront/month\" target=\"_blank\" rel=\"noopener\">前端月报</a> 这里会有人每个月上传上一个月的一些高质量文章</li>\n<li><a href=\"https://www.zhihu.com/question/39503897\" target=\"_blank\" rel=\"noopener\">更多</a></li>\n</ol>\n<h3 id=\"一些书籍\"><a href=\"#一些书籍\" class=\"headerlink\" title=\"一些书籍\"></a>一些书籍</h3><ol>\n<li><a href=\"https://book.douban.com/subject/10546125/\" target=\"_blank\" rel=\"noopener\">JavaScript高级程序设计（第3版）</a> 红宝书，不解释，据说今年7月要出第四版，很期待啊。</li>\n<li><a href=\"https://book.douban.com/subject/2228378/\" target=\"_blank\" rel=\"noopener\">JavaScript权威指南</a> 传说中的犀牛书</li>\n<li><a href=\"https://book.douban.com/subject/26351021/\" target=\"_blank\" rel=\"noopener\">你不知道的JavaScript</a> 有上、中、下三卷</li>\n<li><a href=\"https://book.douban.com/subject/3590768/\" target=\"_blank\" rel=\"noopener\">JavaScript语言精粹</a> 传说中的蝴蝶书</li>\n<li><a href=\"https://book.douban.com/subject/3329540/\" target=\"_blank\" rel=\"noopener\">JavaScript设计模式</a></li>\n<li><a href=\"https://book.douban.com/subject/26745943/\" target=\"_blank\" rel=\"noopener\">css揭秘</a> 介绍了一些实用的css3新特性</li>\n<li><a href=\"https://book.douban.com/subject/2308234/\" target=\"_blank\" rel=\"noopener\">CSS权威指南（第三版）</a></li>\n<li><a href=\"https://www.zhihu.com/question/19809484\" target=\"_blank\" rel=\"noopener\">更多</a></li>\n</ol>\n<h2 id=\"面试知识点\"><a href=\"#面试知识点\" class=\"headerlink\" title=\"面试知识点\"></a>面试知识点</h2><p>接下来这些面试知识点，主要是针对实习生和应届生的，偏基础。有多年工作经验或者基础好的同学可以Ctrl+W了。</p>\n<p>一般面试的时候面试官都是针对你简历上所写的来问，所以你会什么就写什么，不会的就别写上去了，以免面试的时候问到不会就尴尬了。</p>\n<h3 id=\"计算机基础\"><a href=\"#计算机基础\" class=\"headerlink\" title=\"计算机基础\"></a>计算机基础</h3><p>这里把计算机基础放在第一位是因为有很多人忽略计算机基础，前端是属于计算机行业的，不论什么方向，只要这个方向和计算机相关，就必须把计算机基础打好。同时，计算机基础也是面试官在面试实习生和应届生比较注重的一方面。</p>\n<h4 id=\"数据结构和算法\"><a href=\"#数据结构和算法\" class=\"headerlink\" title=\"数据结构和算法\"></a>数据结构和算法</h4><p>数据结构在我面试印象中是考察得最多的计算机基础。</p>\n<p>首先是各种排序算法，冒泡啊，选择啊，快速啊一些常用排序算法，我不建议大家去死记硬背这些算法，而是去记它的思想，这样代码自然就会出来。完之后有些面试官会问它们的时间复杂度，怎么得出的这个个时间复杂度。</p>\n<p>然后到树的遍历，广度优先，前、中、后序遍历。</p>\n<p>还有就是斐波那契数列，算法的时间复杂度为O(n)和O(n^2)的两种实现。</p>\n<h4 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h4><p>tcp的三次握手和四次挥手过程，以及为什么要三次握手，四次挥手。</p>\n<p>get和post的区别，建议看一下<a href=\"http://www.techweb.com.cn/network/system/2016-10-11/2407736.shtml\" target=\"_blank\" rel=\"noopener\">这篇</a>文章。</p>\n<p>http与https区别。</p>\n<p>tcp与udp区别。</p>\n<p>7层网络架构。</p>\n<p>常见http状态码，301与302区别。304与200(form cache区别)，建议联系强制缓存与协商缓存来解释。</p>\n<h4 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h4><p>什么是进程，什么是线程以及他们的区别。</p>\n<p>什么是死锁，怎么产生的，怎么解决。</p>\n<h3 id=\"前端面试知识点\"><a href=\"#前端面试知识点\" class=\"headerlink\" title=\"前端面试知识点\"></a>前端面试知识点</h3><h4 id=\"html部分\"><a href=\"#html部分\" class=\"headerlink\" title=\"html部分\"></a>html部分</h4><p>这部分问的会比较少，因为实在没什么可以问的我所总结的知识点如下：</p>\n<ol>\n<li>什么是html语义化，为什么要语义化，有什么好处，怎么做。</li>\n<li>html5新加的标签。</li>\n<li>有哪些行内元素，有哪些块元素。</li>\n</ol>\n<h4 id=\"css部分\"><a href=\"#css部分\" class=\"headerlink\" title=\"css部分\"></a>css部分</h4><ol>\n<li><code>inline</code>与<code>block</code>与<code>inline-block</code>区别（即行内元素与块元素与行内块元素的区别），以及<code>inline</code>与<code>inline-block</code>元素间会有莫名的间距这个是怎么产生的，怎么解决。</li>\n<li>position取值，以及他们之间的区别，而且是相对于谁定位的。父辈元素设置transform导致fixed定位失效情况。</li>\n<li>浮动造成的问题，以及如何清除浮动，清除浮动的原理，由此引出BFC的概念，什么是BFC，有什么特性。</li>\n<li>盒模型的组成，有哪些盒模型，以及如何互相转换。对于盒模型和定位的概念可以看我的<a href=\"https://jayzangwill.github.io/blog/2016/12/15/CSS%20box%20model%20and%20location/\">这篇</a>文章。</li>\n<li><code>animation</code>和<code>transition</code>区别。</li>\n<li><code>padding</code>和<code>margin</code>的单位设置为%时，这个%是相对于谁。</li>\n<li>水平垂直居中的多种实现方式。</li>\n<li>css选择器的权重</li>\n</ol>\n<h4 id=\"js部分\"><a href=\"#js部分\" class=\"headerlink\" title=\"js部分\"></a>js部分</h4><p>之前也说了，js是前端最重要的部分，同时也是面试问的最多的，这里推荐我之前写的三篇文章：<a href=\"https://jayzangwill.github.io/blog/2017/03/01/Some%20of%20the%20interview%20questions%20that%20impressed%20me-1/\">几个让我印象深刻的面试题(一)</a>、<a href=\"https://jayzangwill.github.io/blog/2017/03/19/Some%20of%20the%20interview%20questions%20that%20impressed%20me-2/\">几个让我印象深刻的面试题(二)</a>、<a href=\"https://jayzangwill.github.io/blog/2017/04/25/Interview%20in%20Beijing%20in%20April/\">四月北京面试之旅</a>，同时js部分的知识点总结如下：</p>\n<ol>\n<li>js的数据类型（一共7种）</li>\n<li>this指向（注意严格模式下的this指向和箭头函数的this指向）</li>\n<li>new的过程</li>\n<li>作用域与作用域链</li>\n<li>什么是闭包，闭包的作用及缺点（建议与作用域联系起来讲）</li>\n<li>原型与原型链，以及如何实现继承（多种实现方式，建议翻看红宝书继承部分或者看<a href=\"https://jayzangwill.github.io/blog/2018/02/27/inherit/\">我博客关于继承的讲解</a>，把es6的继承加上效果更佳）。</li>\n<li>js的事件循环即Event Loop（macro task queue 和 micro task queue了解一下，宏任务包括哪些，微任务包括哪些，以及它们的执行顺序）</li>\n<li>前端跨域，什么情况会跨域，怎么解决，以及它们的优缺点，手写一下jsonp。</li>\n<li>XSS攻击与CSRF攻击怎么攻击以及怎么防御。这里推荐一下<a href=\"https://segmentfault.com/a/1190000006672214\" target=\"_blank\" rel=\"noopener\">这篇文章</a>。</li>\n<li>深拷贝与浅拷贝的区别，以及怎么实现（有的面试官会在这里问递归有什么缺点）。</li>\n<li>ajax的过程，以及状态0~4分别发生了什么（有的面试官会让你手写ajax）。</li>\n<li>es6新加的新特性。</li>\n<li>Promise的三个状态，以及介绍一下async函数。</li>\n<li>js事件的冒泡、捕获，及它们的区别，事件的三个过程。</li>\n<li>浏览器的缓存机制（强制缓存cache-control、协商缓存if-modified，if-modified-since，e-tag了解一下）。</li>\n<li>cooike与session与localStorage、sessionStorage区别，以及localStorage和sessionStorage区别。</li>\n</ol>\n<h4 id=\"vue部分（因为我简历上写了会vue）\"><a href=\"#vue部分（因为我简历上写了会vue）\" class=\"headerlink\" title=\"vue部分（因为我简历上写了会vue）\"></a>vue部分（因为我简历上写了会vue）</h4><ol>\n<li>双向数据绑定原理，这里推荐一下<a href=\"https://juejin.im/post/5abdd6f6f265da23793c4458\" target=\"_blank\" rel=\"noopener\">这篇文章</a></li>\n<li>vue的生命周期，这里推荐一下大漠老师的<a href=\"https://mp.weixin.qq.com/s/JsVx4DwhPwcP8jU0uYHr-g\" target=\"_blank\" rel=\"noopener\">这篇文章</a>还有掘金上的<a href=\"https://juejin.im/post/5ad10800f265da23826e681e\" target=\"_blank\" rel=\"noopener\">这篇文章</a></li>\n<li>vue组件的数据传递（包括父-&gt;子、子-&gt;父，兄弟间，非兄弟）</li>\n<li>前端路由的实现，这里推荐<a href=\"https://juejin.im/post/5ac61da66fb9a028c71eae1b\" target=\"_blank\" rel=\"noopener\">这篇文章</a></li>\n</ol>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>本文写了前端的学习方向，还有前端的面试的重点，仅针对实习和应届的同学。知识点有漏的话会在后期补上。大家有什么想法可以在底下留言。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><a href=\"http://www.jayzangwill.cn/\" target=\"_blank\" rel=\"noopener\">个人主页</a><br><a href=\"https://jayzangwill.github.io/blog/2018/05/01/fe-summary/#more\">原文链接</a><br><a href=\"https://juejin.im/post/5ae980c9f265da0b767d485f\" target=\"_blank\" rel=\"noopener\">掘金</a><br><a href=\"https://zhuanlan.zhihu.com/p/36336162\" target=\"_blank\" rel=\"noopener\">知乎</a>&amp;<a href=\"https://zhuanlan.zhihu.com/jayzangwill\" target=\"_blank\" rel=\"noopener\">知乎专栏</a></p>\n<p>本人从大二上学期到现在学习前端已将近有3年时间了，最近利用毕业论文写完的一些空余时间写一下这篇文章，用于分享一些<strong>个人</strong>的前端学习经验，以及一些面试经验，不一定适合每个人，不喜勿喷，同时欢迎大家提出建议。</p>","more":"<h2 id=\"学习路线\"><a href=\"#学习路线\" class=\"headerlink\" title=\"学习路线\"></a>学习路线</h2><p>总体的来说前端无非就是html、css、js只要把这三样的基础打好，什么都不是问题。他们的难易程度也是html &lt; css &lt; js，所以学习路线也是从html-&gt;css-&gt;js或者html&amp;css-&gt;js。而我的学习路线是后者。</p>\n<p>总的来说，在学完一个新东西的时候建议最好用新东西手撸个玩意出来。一定要动手实操！</p>\n<h3 id=\"html-amp-css\"><a href=\"#html-amp-css\" class=\"headerlink\" title=\"html&amp;css\"></a>html&amp;css</h3><p>首先这部分的学习我是看了一本叫<a href=\"https://book.douban.com/subject/25752357/\" target=\"_blank\" rel=\"noopener\">Head First HTML&amp;CSS</a>的书，这本电子书可以到网上下载。这本书与平时看到的书有点不一样，这本书相当是<strong>手把手教</strong>你如何完成一个静态网站，虽然书有点老，但是拿来入门还是不错的。</p>\n<p>看完这本书以后你的html&amp;css基本上算是入门了，可以自己撸个个人主页或者博客什么的。看完书之后不动手撸个什么小玩意出来是不行的，光说不练等于白看。</p>\n<p>这个时候如果感觉还需要加深html&amp;css的话推荐<a href=\"https://book.douban.com/subject/4736167/\" target=\"_blank\" rel=\"noopener\">精通CSS（第2版）</a>这本书，能力强的同学可以去学学<a href=\"https://v3.bootcss.com/\" target=\"_blank\" rel=\"noopener\">bootstrap</a>，这是大名鼎鼎的前端html&amp;css框架。会用了（其实也就是html标签上bootstrap事先加定义好的类名，没太大难度）以后就去看看bootstrap的源码。注意，这里所说的源码不是吧boosstrap.css从头看到尾，那会疯的。看的源码是你用到的那几个类名的源码。可以通过谷歌控制台去看，选中一个标签，然后在styles那看人家是怎么定义这个样式的。</p>\n<p><img src=\"/blog/img/summary/styles.png\" alt=\"styles\"></p>\n<p>感觉差不多以后就得实际操作了，可以到<a href=\"http://ife.baidu.com/2016/task/all\" target=\"_blank\" rel=\"noopener\">这里</a>的最下面的第一阶段任务去练练手。</p>\n<p><img src=\"/blog/img/summary/task.png\" alt=\"task\"></p>\n<p>个人感觉这第一阶段任务还是挺适合新手去做的。先尽量不要使用任何框架，自己去手撸出来。最后不管撸没撸出来都要去看看人家是怎么完成这项任务的，学习一下人家怎么解决问题的。前提一定是自己得先去思考。</p>\n<p>当然今年(2018年)的百度前端技术学院也是更加给力了，也有从0基础开始手把手教你如何完成一个页面。<a href=\"http://ife.baidu.com/college/detail/id/5\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n<h3 id=\"git-amp-github\"><a href=\"#git-amp-github\" class=\"headerlink\" title=\"git&amp;github\"></a>git&amp;github</h3><p>这里插播一条git的学习指南，有的同学可能想要让自己的作品能让大家看到但是又没有自己的服务器的话怎么办？</p>\n<p>那么这里就得借助<a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">github</a>和github pages了。首先你得明白怎么用git&amp;github，<a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001373962845513aefd77a99f4145f0a2c7a7ca057e7570000\" target=\"_blank\" rel=\"noopener\">这里有份教程</a>，个人觉得还不错。</p>\n<p>知道git&amp;github怎么用以后，就利用github pages让别人看到我们的作品。</p>\n<p>首先，利用git在本地创建gh-pages分支（注意：一定要是gh-pages分支），然后将各种资源用git推送到github对应仓库的gh-pages分支上（至于怎么操作不在这里详细说明，教程里已经说得很清楚了）</p>\n<p>推送成功以后浏览器打开github用户名.github.io/仓库名/对应的html。举个例子，我在github上的用户名是<a href=\"https://github.com/JayZangwill\" target=\"_blank\" rel=\"noopener\">JayZangwillJayZangwill</a>，然后我的仓库名是blog，然后这个仓库下的gh-pages分支有个index.html文件，这个时候访问的地址就是<a href=\"https://jayzangwill.github.io/blog/index.html\">https://jayzangwill.github.io/blog/index.html</a>。因为github pages默认以index.html文件作为入口，所以以上链接可简写为<a href=\"https://jayzangwill.github.io/blog\">https://jayzangwill.github.io/blog</a>。</p>\n<p>git&amp;github是现代公司团队合作的重要工具，不管你处于前端的哪个阶段，git&amp;github都是必学的，是逃不掉的。</p>\n<h3 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h3><p>如果百度前端技术学院的16年第一部分任务能够做差不多出来就可以学js了，如果感觉还是没有什么收获的话就得去面壁过了。</p>\n<p>如果说html&amp;css是餐前甜点的话js就是正餐了，js比html&amp;css的难度高出不止一个档次，可能有些小伙伴看到js的时候就打算放弃了。这个时候建议不要慌，慢慢来节奏稍微慢一点。当时我刚看js的时候看的是看的是<a href=\"https://book.douban.com/subject/2372267/\" target=\"_blank\" rel=\"noopener\">Head First JavaScript</a>，结果一点都看不懂，看到一半就放弃了。于是百度搜了前端js入门书籍，结果搜到了<a href=\"https://book.douban.com/subject/6038371/\" target=\"_blank\" rel=\"noopener\">JavaScript DOM编程艺术</a>。这也是我比较推荐的一本入门书籍，如果能坚持看完，你的js就算入门了。</p>\n<p>当然js的学习路径有很多，以上的路径不一定适合所有人，也可以去网上搜些视频，比如去<a href=\"https://www.imooc.com/course/list?c=javascript&amp;\" target=\"_blank\" rel=\"noopener\">慕课网</a>上去看看。</p>\n<p>当感觉自己js学得差不多的时候可以找些练手的网站来加深对知识点的理解。个人推荐的网站有<a href=\"http://ife.baidu.com/2016/task/all\" target=\"_blank\" rel=\"noopener\">2016百度前端技术学院第二部分js基础部分</a>，<a href=\"https://freecodecamp.cn/home\" target=\"_blank\" rel=\"noopener\">Free Code Camp</a>。当遇到不认识的api或知识点时可以到<a href=\"https://developer.mozilla.org/zh-CN/\" target=\"_blank\" rel=\"noopener\">MDN</a>上去查。</p>\n<p>感觉自己js基本功差不多了以后，下一步就开始学习es6或者jQuery了。由于前端三大框架的出现，导致jQuery的地位受到动摇，如果没有万恶的ie的话，jQuery很快就要退出历史舞台了。不过就目前情况来看，jQuery在前端还是占有很大份额的，所以学习jQuery还是很有必要的。学习jQuery的话我只推荐一本<a href=\"https://book.douban.com/subject/6688828/\" target=\"_blank\" rel=\"noopener\">Head First jQuery</a>，看完这本书即可。对于es6来说这是js在15年出的新规范、新语法，内容较多所以可以单独抽出一块来学习，这里我推荐阮一峰前辈的<a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">es6入门</a>。</p>\n<p>当es6看完以后就可以去学习前端的三大框架了，分别是Angular、Vue、React。当然也不是三个都要学，只需学好其中一个或者多个即可。就目前国内的情况来看Vue和React用的最多，而Vue相对React来说相对好学一点（ps:最近博主在学习React），所以我推荐的话Vue是比较好的一个切入点。另外附上<a href=\"https://cn.vuejs.org/v2/guide/\" target=\"_blank\" rel=\"noopener\">Vue的官方教程</a>，个人认为官方教程已经写得很全面了，所以学Vue的话官方教程即可。React的话最近我也是在学习阶段，我这里就直接粘个<a href=\"https://doc.react-china.org/\" target=\"_blank\" rel=\"noopener\">官方教程</a>吧。<strong>注意</strong>：学习它们之前一定要把es6看了，因为教程中用了一些es6的语法，为了防止文档看不懂，所以建议先把es6过了。</p>\n<p>js是我在大学中花的时间比较多的地方，也是前端最重要的部分，想要学好它，光是按照我上面说的是不够的，更多的是需要你不断在实践中总结，发现问题和解决问题。有必要时可以去看别人是怎么写js代码的，或者看看框架的源码，这样学到的才更多。</p>\n<h3 id=\"gulp-amp-webpack\"><a href=\"#gulp-amp-webpack\" class=\"headerlink\" title=\"gulp&amp;webpack\"></a>gulp&amp;webpack</h3><p>当你在前端的道路上走了一段距离的时候会发现想要一些东西来提高自己的开发效率，gulp&amp;webpack就能够满足你。这些自动化工具能够自动编译代码、压缩静态资源、自动刷新浏览器等。</p>\n<p>首先是gulp，gulp想要上手很容易，百度上搜一搜就有很多入门教程，这里推荐一篇<a href=\"http://www.ydcss.com/archives/18\" target=\"_blank\" rel=\"noopener\">gulp入门教程</a>（我不会说我是从百度随便搜来的），虽然是我从百度上随便扒下来的但是足够入门了，毕竟gulp上手还是很容易的。这里还推荐一下我的<a href=\"https://github.com/JayZangwill/myTools/tree/master/gulp\" target=\"_blank\" rel=\"noopener\">gulp配置</a>，能够满足大部分人的需求了。把gulpfile.js和package.json复制到本地，然后按照说明操作即可。</p>\n<p>另外附上<a href=\"https://gulpjs.com/plugins/\" target=\"_blank\" rel=\"noopener\">gulp的插件搜索地址</a>，搜出来的插件都会告诉你如何去配置，一般情况下只需把介绍上的配置复制上来即可。如图是<a href=\"https://www.npmjs.com/package/gulp-uglify\" target=\"_blank\" rel=\"noopener\">gulp-uglify</a>的介绍。</p>\n<p><img src=\"/blog/img/summary/uglify.png\" alt=\"uglify\"></p>\n<p>至于webpack，它上手可能会比较难，因为配置会比较繁琐（webpack4据说把一些东西内置了，可以不用配置文件就可以用）觉得比较难的同学可以先把webpack先放一放，前期的话gulp基本就可以满足需求。学习webpack的话感觉还是看<a href=\"https://doc.webpack-china.org/concepts/\" target=\"_blank\" rel=\"noopener\">官方文档</a>比较好。同时，大家可以看看我的<a href=\"https://github.com/JayZangwill/vue-multipage\" target=\"_blank\" rel=\"noopener\">vue-cli多页面模板</a>。</p>\n<p>不过最近新出了个叫<a href=\"https://parceljs.org/\" target=\"_blank\" rel=\"noopener\">parcel</a>的东西，号称极速零配置Web应用打包工具，大家可以了解一下。</p>\n<p>这里有人可能会问为什么不学grunt？emm…这东西已经是过时的产物，有兴趣的同学可以去了解了解，不论如何gulp&amp;webpack最终还是必须要掌握的。</p>\n<h3 id=\"sass-amp-less\"><a href=\"#sass-amp-less\" class=\"headerlink\" title=\"sass&amp;less\"></a>sass&amp;less</h3><p>sass和less都是css的预编译语言，它们不必两个都学，学了其中一个另外一个自然就会。我个人的话是学了sass，是在<a href=\"https://www.imooc.com/search/?words=sass\" target=\"_blank\" rel=\"noopener\">慕课网</a>上学的，学习的话只需学习前两个即可。</p>\n<p><img src=\"/blog/img/summary/sass.png\" alt=\"sass\"></p>\n<p>至于less的话，看<a href=\"https://less.bootcss.com/\" target=\"_blank\" rel=\"noopener\">官方文档</a>吧，less或sass学完以后可以尝试把以前写过的css用sass或者less重写一遍用于加深对知识的理解吧。另外我的那个gulp配置默认是支持sass的编译的，如果用了我的那个gulp配置的同学且是学sass的就不用自己配置了，如果学less的同学得需要自己配置一下。</p>\n<h3 id=\"nodejs\"><a href=\"#nodejs\" class=\"headerlink\" title=\"nodejs\"></a>nodejs</h3><p>如果还有余力的同学可以去学学node，目前有些公司对会node的前端是加分项，这里推荐一本书<a href=\"https://book.douban.com/subject/25767596/\" target=\"_blank\" rel=\"noopener\">了不起的nodejs</a></p>\n<h3 id=\"一些学习网站推荐\"><a href=\"#一些学习网站推荐\" class=\"headerlink\" title=\"一些学习网站推荐\"></a>一些学习网站推荐</h3><p>至此，前端需要掌握的技能和学习路线已经说完了。这里推荐一些前端的进阶网站和一些论坛，让大家在前端路上走得更远。</p>\n<ol>\n<li><a href=\"https://juejin.im/timeline\" target=\"_blank\" rel=\"noopener\">掘金</a> 在这里会有很多高质量的文章，我也经常在这逛的。</li>\n<li><a href=\"https://www.zhihu.com/\" target=\"_blank\" rel=\"noopener\">知乎</a> 这里是大佬的世界</li>\n<li><a href=\"https://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">stack overflow</a> 国外的一个超高质量技术论坛，你可以在这里提问，与国外大佬交流</li>\n<li><a href=\"https://segmentfault.com/\" target=\"_blank\" rel=\"noopener\">SegmentFault</a> 国内版的stack overflow</li>\n<li><a href=\"https://www.w3cplus.com/\" target=\"_blank\" rel=\"noopener\">w3cplus</a> 大漠老师创办的技术论坛</li>\n<li><a href=\"https://freecodecamp.cn/home\" target=\"_blank\" rel=\"noopener\">Free Code Camp</a> 在线学习网站</li>\n<li><a href=\"http://ife.baidu.com/\" target=\"_blank\" rel=\"noopener\">百度前端技术学院</a> 百度从15年到现在每年都会创办的技术学院</li>\n<li><a href=\"https://github.com/jsfront/month\" target=\"_blank\" rel=\"noopener\">前端月报</a> 这里会有人每个月上传上一个月的一些高质量文章</li>\n<li><a href=\"https://www.zhihu.com/question/39503897\" target=\"_blank\" rel=\"noopener\">更多</a></li>\n</ol>\n<h3 id=\"一些书籍\"><a href=\"#一些书籍\" class=\"headerlink\" title=\"一些书籍\"></a>一些书籍</h3><ol>\n<li><a href=\"https://book.douban.com/subject/10546125/\" target=\"_blank\" rel=\"noopener\">JavaScript高级程序设计（第3版）</a> 红宝书，不解释，据说今年7月要出第四版，很期待啊。</li>\n<li><a href=\"https://book.douban.com/subject/2228378/\" target=\"_blank\" rel=\"noopener\">JavaScript权威指南</a> 传说中的犀牛书</li>\n<li><a href=\"https://book.douban.com/subject/26351021/\" target=\"_blank\" rel=\"noopener\">你不知道的JavaScript</a> 有上、中、下三卷</li>\n<li><a href=\"https://book.douban.com/subject/3590768/\" target=\"_blank\" rel=\"noopener\">JavaScript语言精粹</a> 传说中的蝴蝶书</li>\n<li><a href=\"https://book.douban.com/subject/3329540/\" target=\"_blank\" rel=\"noopener\">JavaScript设计模式</a></li>\n<li><a href=\"https://book.douban.com/subject/26745943/\" target=\"_blank\" rel=\"noopener\">css揭秘</a> 介绍了一些实用的css3新特性</li>\n<li><a href=\"https://book.douban.com/subject/2308234/\" target=\"_blank\" rel=\"noopener\">CSS权威指南（第三版）</a></li>\n<li><a href=\"https://www.zhihu.com/question/19809484\" target=\"_blank\" rel=\"noopener\">更多</a></li>\n</ol>\n<h2 id=\"面试知识点\"><a href=\"#面试知识点\" class=\"headerlink\" title=\"面试知识点\"></a>面试知识点</h2><p>接下来这些面试知识点，主要是针对实习生和应届生的，偏基础。有多年工作经验或者基础好的同学可以Ctrl+W了。</p>\n<p>一般面试的时候面试官都是针对你简历上所写的来问，所以你会什么就写什么，不会的就别写上去了，以免面试的时候问到不会就尴尬了。</p>\n<h3 id=\"计算机基础\"><a href=\"#计算机基础\" class=\"headerlink\" title=\"计算机基础\"></a>计算机基础</h3><p>这里把计算机基础放在第一位是因为有很多人忽略计算机基础，前端是属于计算机行业的，不论什么方向，只要这个方向和计算机相关，就必须把计算机基础打好。同时，计算机基础也是面试官在面试实习生和应届生比较注重的一方面。</p>\n<h4 id=\"数据结构和算法\"><a href=\"#数据结构和算法\" class=\"headerlink\" title=\"数据结构和算法\"></a>数据结构和算法</h4><p>数据结构在我面试印象中是考察得最多的计算机基础。</p>\n<p>首先是各种排序算法，冒泡啊，选择啊，快速啊一些常用排序算法，我不建议大家去死记硬背这些算法，而是去记它的思想，这样代码自然就会出来。完之后有些面试官会问它们的时间复杂度，怎么得出的这个个时间复杂度。</p>\n<p>然后到树的遍历，广度优先，前、中、后序遍历。</p>\n<p>还有就是斐波那契数列，算法的时间复杂度为O(n)和O(n^2)的两种实现。</p>\n<h4 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h4><p>tcp的三次握手和四次挥手过程，以及为什么要三次握手，四次挥手。</p>\n<p>get和post的区别，建议看一下<a href=\"http://www.techweb.com.cn/network/system/2016-10-11/2407736.shtml\" target=\"_blank\" rel=\"noopener\">这篇</a>文章。</p>\n<p>http与https区别。</p>\n<p>tcp与udp区别。</p>\n<p>7层网络架构。</p>\n<p>常见http状态码，301与302区别。304与200(form cache区别)，建议联系强制缓存与协商缓存来解释。</p>\n<h4 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h4><p>什么是进程，什么是线程以及他们的区别。</p>\n<p>什么是死锁，怎么产生的，怎么解决。</p>\n<h3 id=\"前端面试知识点\"><a href=\"#前端面试知识点\" class=\"headerlink\" title=\"前端面试知识点\"></a>前端面试知识点</h3><h4 id=\"html部分\"><a href=\"#html部分\" class=\"headerlink\" title=\"html部分\"></a>html部分</h4><p>这部分问的会比较少，因为实在没什么可以问的我所总结的知识点如下：</p>\n<ol>\n<li>什么是html语义化，为什么要语义化，有什么好处，怎么做。</li>\n<li>html5新加的标签。</li>\n<li>有哪些行内元素，有哪些块元素。</li>\n</ol>\n<h4 id=\"css部分\"><a href=\"#css部分\" class=\"headerlink\" title=\"css部分\"></a>css部分</h4><ol>\n<li><code>inline</code>与<code>block</code>与<code>inline-block</code>区别（即行内元素与块元素与行内块元素的区别），以及<code>inline</code>与<code>inline-block</code>元素间会有莫名的间距这个是怎么产生的，怎么解决。</li>\n<li>position取值，以及他们之间的区别，而且是相对于谁定位的。父辈元素设置transform导致fixed定位失效情况。</li>\n<li>浮动造成的问题，以及如何清除浮动，清除浮动的原理，由此引出BFC的概念，什么是BFC，有什么特性。</li>\n<li>盒模型的组成，有哪些盒模型，以及如何互相转换。对于盒模型和定位的概念可以看我的<a href=\"https://jayzangwill.github.io/blog/2016/12/15/CSS%20box%20model%20and%20location/\">这篇</a>文章。</li>\n<li><code>animation</code>和<code>transition</code>区别。</li>\n<li><code>padding</code>和<code>margin</code>的单位设置为%时，这个%是相对于谁。</li>\n<li>水平垂直居中的多种实现方式。</li>\n<li>css选择器的权重</li>\n</ol>\n<h4 id=\"js部分\"><a href=\"#js部分\" class=\"headerlink\" title=\"js部分\"></a>js部分</h4><p>之前也说了，js是前端最重要的部分，同时也是面试问的最多的，这里推荐我之前写的三篇文章：<a href=\"https://jayzangwill.github.io/blog/2017/03/01/Some%20of%20the%20interview%20questions%20that%20impressed%20me-1/\">几个让我印象深刻的面试题(一)</a>、<a href=\"https://jayzangwill.github.io/blog/2017/03/19/Some%20of%20the%20interview%20questions%20that%20impressed%20me-2/\">几个让我印象深刻的面试题(二)</a>、<a href=\"https://jayzangwill.github.io/blog/2017/04/25/Interview%20in%20Beijing%20in%20April/\">四月北京面试之旅</a>，同时js部分的知识点总结如下：</p>\n<ol>\n<li>js的数据类型（一共7种）</li>\n<li>this指向（注意严格模式下的this指向和箭头函数的this指向）</li>\n<li>new的过程</li>\n<li>作用域与作用域链</li>\n<li>什么是闭包，闭包的作用及缺点（建议与作用域联系起来讲）</li>\n<li>原型与原型链，以及如何实现继承（多种实现方式，建议翻看红宝书继承部分或者看<a href=\"https://jayzangwill.github.io/blog/2018/02/27/inherit/\">我博客关于继承的讲解</a>，把es6的继承加上效果更佳）。</li>\n<li>js的事件循环即Event Loop（macro task queue 和 micro task queue了解一下，宏任务包括哪些，微任务包括哪些，以及它们的执行顺序）</li>\n<li>前端跨域，什么情况会跨域，怎么解决，以及它们的优缺点，手写一下jsonp。</li>\n<li>XSS攻击与CSRF攻击怎么攻击以及怎么防御。这里推荐一下<a href=\"https://segmentfault.com/a/1190000006672214\" target=\"_blank\" rel=\"noopener\">这篇文章</a>。</li>\n<li>深拷贝与浅拷贝的区别，以及怎么实现（有的面试官会在这里问递归有什么缺点）。</li>\n<li>ajax的过程，以及状态0~4分别发生了什么（有的面试官会让你手写ajax）。</li>\n<li>es6新加的新特性。</li>\n<li>Promise的三个状态，以及介绍一下async函数。</li>\n<li>js事件的冒泡、捕获，及它们的区别，事件的三个过程。</li>\n<li>浏览器的缓存机制（强制缓存cache-control、协商缓存if-modified，if-modified-since，e-tag了解一下）。</li>\n<li>cooike与session与localStorage、sessionStorage区别，以及localStorage和sessionStorage区别。</li>\n</ol>\n<h4 id=\"vue部分（因为我简历上写了会vue）\"><a href=\"#vue部分（因为我简历上写了会vue）\" class=\"headerlink\" title=\"vue部分（因为我简历上写了会vue）\"></a>vue部分（因为我简历上写了会vue）</h4><ol>\n<li>双向数据绑定原理，这里推荐一下<a href=\"https://juejin.im/post/5abdd6f6f265da23793c4458\" target=\"_blank\" rel=\"noopener\">这篇文章</a></li>\n<li>vue的生命周期，这里推荐一下大漠老师的<a href=\"https://mp.weixin.qq.com/s/JsVx4DwhPwcP8jU0uYHr-g\" target=\"_blank\" rel=\"noopener\">这篇文章</a>还有掘金上的<a href=\"https://juejin.im/post/5ad10800f265da23826e681e\" target=\"_blank\" rel=\"noopener\">这篇文章</a></li>\n<li>vue组件的数据传递（包括父-&gt;子、子-&gt;父，兄弟间，非兄弟）</li>\n<li>前端路由的实现，这里推荐<a href=\"https://juejin.im/post/5ac61da66fb9a028c71eae1b\" target=\"_blank\" rel=\"noopener\">这篇文章</a></li>\n</ol>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>本文写了前端的学习方向，还有前端的面试的重点，仅针对实习和应届的同学。知识点有漏的话会在后期补上。大家有什么想法可以在底下留言。</p>"},{"title":"angular学习笔记(1)","date":"2016-10-11T00:26:23.000Z","_content":"# angular学习笔记(1)\n\n由于之前学习了vue，所以学习angular感觉还蛮顺的，因为这两个框架有很多相似之处，例如：\n\n    1. 输出都可以用双括号{{}}\n    2. 都有双向数据绑定\n    3. 指令也有很多相似的地方，这里就不一一列举了\n    \n<!-- more-->\n    \n下面准备开始，在开始之前先说明：下面代码的html文件的文档声明，还有头标签、文件的引入都省略了，直接从`ng-app`的内部开始写代码，js文件的模块声明如果没有特殊情况会默认使用`var myApp=angular.module(\"myApp\",[]);`\n    \n# angular的模块化\n\n在学习angular听到最多的就是模块化，任何一个功能都是模块。 \n\n首先，要想用angular就得先引入angular.js文件，然后在*.html*文件中标签加入`ng-app`属性，(一般加在`html`标签或者`body`后面加，作为根部作用域)，告诉angular下面这块内容由angular管，同时自动启动angular，例如以下代码： \n\n    <html ng-app=\"myApp\">\n        <!--这里是angular的作用范围-->\n    </html>\n    \n然后在自己的*.js*文件中声明一个变量，用于储存angular返回的模块： \n\n    var myApp=angular.module(\"myApp\",[]);\n    \n括号中的`myApp`是标签中`ng-app`的属性值`\"myApp\"`，后面的中括号是模块的依赖项，第三个参数是一个回调函数，用来定义angular的一些服务。\n\n如果在*html*文件里面如果没有写`ng-app`，这个时候就得在*js*文件里手动启动angular： \n\n    angular.element(document).ready(function(){\n        angular.bootstrap(document,\"myApp\");\n    });\n    \n同一个`ng-app`不能启动两次，如果启动两次会报错！\n\n**注意：**一般一个应用中只能有一个`ng-app`，当然有少数情况也会有多个`ng-app`，但是`ng-app`不能嵌套在`ng-app`中，这个时候第二个以后的`ng-app`需要手动启动，不过一般不建议有多个`ng-app`。\n\n# 控制器\n\n一个应用中可以有多个控制器，一般一个控制器用于管理应用中的一个功能，例如：\n\nHTML：\n\n    <div ng-controller=\"controller1\">\n        <!--这里是一些指令-->\n    </div>\n    <div ng-controller=\"controller2\">\n        <!--这里是一些指令-->\n    </div>\n\nJS：\n\n    myApp.controller(\"controller1\",[\"$scope\",function($scope){\n        //这里是一些逻辑\n    }]);\n    myApp.controller(\"controller2\",[\"$scope\",function($scope){\n        //这里是一些逻辑\n    }]);\n\njs中的`myApp`就是上面`angular.module(\"myApp\",[])`返回的模块，调用`controller`方法创建一个控制器，第一个参数是HTML中`ng-controller`的属性值，第二个参数是一个数组，里面包含了控制器的一些依赖还有回调函数，`$scope`是angular的作用域，一般用于存储各种变量。\n\n在angular中还有一个`$rootScope`，它是angular的根作用域链，类似于js中的全局作用域，定义在`$rootScrop`上的变量所有控制器都可以访问。\n\n**注意：**\n\n    1. 不要去复用controller，一个控制器一般只负责一块视图\n    2. 不要再controller中操作DOM，这不是控制器的职责\n    3. 不要再controller里面做数据格式化\n    4. 不要再controller里面做数据操作\n    5. 一般来说，controller不会互相调用，控制器之间的交互只会通过事件来进行\n\n# 双向数据绑定\n\n当年angular火有一部分原因是因为它实现了数据的双向绑定，这是其他框架都没有实现的。\n所谓的双向数据绑定就是：数据模型里面的值变了，视图也会跟着变，反过来也是，像下面：\n\nHTML：\n\n    <div ng-controller=\"controller\">\n       <input type=\"text\" ng-model=\"name\">\n       <div>{{name}}<div>\n    </div>\n\nJS：\n\n    myApp.controller(\"controller\",[\"$scope\",function($scope){\n        $scope.name=\"张三\";\n    }]);\n    \n运行以上代码在页面中就会看见有一个输入框里面的值是张三，下面有一段字也是张三。当我们改变输入框中的值会发现下面的那段字也会变，这就实现了数据的双向绑定。\n\n# 指令\n\nangular还有一个吸引人的地方就是指令系统。angular内置了很多的指令，同时，还可以让我们自定义指令。前面说到的`ng-app`和`ng-controller`就是指令。\n\n## ng-bind\n\nHTML：\n\n    <div ng-bind=\"name\"></div>\n    \nJS：\n\n    myApp.controller(\"controller\",[\"$scope\",function($scope){\n        $scope.name=\"张三\";\n    }]);\n\n在页面中也会输出张三，和*双花括号*的作用一样，但是使用`ng-bind`的好处就是，当页面加载速度慢的时候页面中不会出现*双花括号*，保证了页面的美观性。\n\n## ng-class\n\nHTML：\n\n    <div ng-class=\"my-style:true\"></div>\n\n`ng-class`一般用于控制class是否使用，如果`:`后面的表达式为`true`，就使用`:`前面的类名。\n\n## ng-show和ng-hide\n\nHTML：\n\n    <div ng-show=\"true\">我是显示的</div>\n    <div ng-hide=\"true\">我是隐藏的</div>\n    \n当`ng-show`后面的变量为`true`时，这个html元素就会显示，为`false`时就回隐藏，`ng-hide`刚好相反。\n\n## ng-repeat\n\nHTML：\n\n    <div ng-controller=\"myController\">\n        <ul>\n            <li ng-repeat=\"data in datas\">{{data}}</li>\n        </ul>\n    </div>\n    \nJS：\n\n    myApp.controller(\"myController\",[\"$scope\",function($scope){\n        $scope.datas=[\"张三\"，\"李四\",\"王五\"];\n    }]);\n\n这个时候页面就会输出：\n\n    1. 张三\n    2. 李四\n    3. 王五\n\n`ng-repeat`就是用来遍历数据，并且把数据在页面中全部渲染出来，非常方便。\n\n## ng-style\n\nHTML：\n\n    <div ng-style=\"{'color':'red','background-color':'green'}\">字的颜色石红的，背景是绿的</div>\n\n## ng-class-even和ng-class-odd\n\nHTML：\n\n    <div ng-controller=\"myController\">\n        <ul>\n            <li ng-class-even=\"'even-style'\" ng-class-odd=\"'odd-style'\" ng-repeat=\"data in datas\">{{data}}</li>\n        </ul>\n    </div>\n    \nJS：\n\n    myApp.controller(\"myController\",[\"$scope\",function($scope){\n        $scope.datas=[\"张三\"，\"李四\",\"王五\"];\n    }]);\n\n这样当`li`为奇数时，就会用`even-style`的class类，当`li`为偶数时就会用`odd-style`的class类。\n    \n## ng-click\n\nHTML：\n\n    <div ng-controller=\"myController\">\n        <button ng-click=\"changeStatus()\">点我</button>\n    </div>\n    <p>{{status}}</p>\nJS：\n\n    myApp.controller(\"myController\",[\"$scope\",function($scope){\n        $scope.status=false;\n        $scope.changeStatus=function(){\n            $scope.status=!$scope.status;\n        }\n    }]);\n\n每点一次按钮，`changeStatus`函数就会执行一次，`stauts`的值就会改变一次\n\n## ng-switch\n\nHTML：\n\n    <div ng-controller=\"myController\">\n        <button ng-click=\"changeStatus()\">点我</button>\n            <ol switch=\"status\">\n                <li ng-switch-when=\"true\">\n                    当值为true才会显示\n                </li>\n                <li ng-switch-when=\"false\">\n                    当值为false才会显示\n                </li>\n            </ol>\n    </div>\n    <p>{{status}}</p>\n    \nJS：\n\n    myApp.controller(\"myController\",[\"$scope\",function($scope){\n        $scope.status=false;\n        $scope.changeStatus=function(){\n            $scope.status=!$scope.status;\n        }\n    }]);\n    \n## ng-init\n\nHTML：\n\n    <div ng-init=\"[firstName='张',lastName='三']\">\n        {{firstName+lastName}}\n    </div>\n    \n这是页面就会输出`\"张三\"`。`ng-init`用于初始化变量，不过初始化变量一般不这么做。\n\n## ng-src\n\nHTML：\n\n    <img ng-src={{imgUrl}} alt=\"图片\">\n\n`ng-src`是用于解决 `src`属性用ng表达式bug的一个指令，如果地址中包含ng表达式，用`ng-src`比较好。\n\n## 自定义指令\n\n在angular内置的这些指令中肯定是不够用的，所以，angualr可以给我们自定义指令：\n\nHTML：\n\n    <hello-world>oldValue</hello-world>\n    <div class=\"hello-world\">oldValue</div>\n    <!-- directive:hello-world -->\n    <div>oldValue</div>\n    <div hello-world>oldValue</div>\n\nJS：\n\n    myApp.directive(\"helloWorld\",[function(){\n        return{\n            restrict: 'ECMA',\n            template:\"<div>newValue<span ng-transclude></span></div>\",\n            replace:true,\n            transclude:true,\n            link:function(){\n                //在这里可以操作DOM、给元素绑定事件\n            }\n        }\n    }]);\n\njs部分有个`restrict`这个是匹配模式，用于匹配不同的属指令创建方式。\n\nE代表匹配元素模式，也就是我们说的html标签`<hello-world>oldValue</hello-world>`，当需要创建带有自己的模板的指令时，使用这种方法。\n\nC匹配class模式，就是上面的`<div class=\"hello-world\">oldValue</div>`\n\nM代表匹配注释模式，就是上面的`<!-- directive:hello-world --> <div>oldValue</div>`，这里需要注意的就是注释的开头和结尾要有个空格，不然angular是识别不出的。\n\nA代表属性模式，即`<div hello-world>oldValue</div>`，当要为已有的HTML标签增加功能时，使用这种方法创建指令，这也是angular默认的匹配方式。\n\n`template`是填充到标签里的内容\n\n`template`里可以看到有个`ng-transclude`指令，这个指令是在下面的`replace`和`transclude`值为`true`时才有用。当`replace`为真时原来的*oldValue*会被替换成`template`里的内容，但是我们有时候希望保留*oldValue*，所以把`transclude`设为`true`，这个时候angular就知道要把*oldValue*保存下来。但是保留下来得有地方放，这个时候在`template`里面加个`ng-transclude`指令，就可以把*oldValue*放进去。\n\n`template`可以换成`templateUrl`，后面接的是其他的html文件的地址。\n\n`link`函数可以操作DOM、绑定事件、绑定作用域。\n\n最终代码执行完后会得到(以`<hello-world>oldValue</hello-world>`的结果为例)：\n\n    <div>\n        newValue\n        <span ng-transclude=\"\"></span>\n        <div>oldValue</div>\n    </div>\n    \n### 自定义指令的controller和controllAs\n\n还是上面的代码，将JS部分改为：\n\n     var myApp = angular.module(\"myApp\", []);\n     myApp.directive(\"helloWorld\", [function () {\n         return {\n             restrict: 'ECMA',\n             template: \"<div>newValue<span ng-transclude></span></div>\",\n             replace: true,\n             transclude: true,\n             controller:function($scope){\n                 console.log($scope);\n             },\n             link: function () {\n                 //在这里可以操作DOM、给元素绑定事件\n             }\n         }\n    }]);\n    myApp.controller('myController', ['$scope', function ($scope) {\n        console.log($scope);\n    }]);\n\n这样在控制台输出的两个`$scope`实际上是同一个`$scope`。上面那个`controller`写在那里，其他指令可以通过`require`属性获得这个`controller`里面的东西，实现多个指令通过依赖注入进行通信。\n\n### require\n\n`require`可以将其他指令传递给自己，有三个用法：\n\n    1. 通过驼峰法(directiveName)的命名指定了控制器应该带有哪一条指令，默认从同一个元素上的指令找\n    2. ^directiveName，在父级查找\n    3. ?directiveName，指令可选，找不到不要抛出异常\n    \n现在，上面的代码改成了：\n\n     myApp.directive(\"helloWorld\", [function () {\n     return {\n         restrict: 'ECMA',\n         template: \"<div>newValue<span ng-transclude></span><btn></btn></div>\",\n         replace: true,\n         transclude: true,\n         controller:function($scope){\n             this.fun=function(){\n                 alert(\"s\");\n             }\n         },\n         controllerAs:\"test\",\n         link: function (scope,element,attr,test) {\n             element.on(\"click\",test.fun);\n         }\n     }\n    }]);\n    myApp.directive('btn', [function () {\n        return {\n            restrict: 'E',\n            require:\"^helloWorld\",\n            replace:true,\n            template:\"<button>点我</button>\",\n            link: function (scope, element, attrs,test) {\n                element.on(\"click\",test.fun);\n            }\n        };\n    }]);\n\n点击按钮会发现弹出两次a。那是因为在`helloWorld`指令里的`link`函数调用了一次`this.fun`下面的`btn`也调用了一次。如果点击文字就只会弹出一次。\n\n这里的`require`用了`^`是因为`helloWorld`是`btn`的父级。\n\n### scope\n\n#### scope:true\n\n在上面说了自定义指令里的`controller`和下面的`myController`是同一个控制器。但是当我在自定义指令里(`helloWorld`指令)加一句`scope:true`时，这两个控制器就有不同的作用域了：\n\n    myApp.directive(\"helloWorld\", [function () {\n         return {\n             restrict: 'ECMA',\n             template: \"<div>newValue<span ng-transclude></span><btn></btn></div>\",\n             replace: true,\n             scope:true,\n             transclude: true,\n             controller:function($scope){\n                 console.log($scope);\n                 this.fun=function(){\n                     alert(\"s\");\n                 }\n             },\n             controllerAs:\"test\"\n         }\n    }]);\n    \n这时，控制台输出的两个`scope`，展开来看会发现它们的*id*不一样，*id*小的那个是*id*大的父作用域，子作用域可以继承父作用域里的属性，父作用域读不到子作用域里的属性。\n\n#### scope:{}\n\n当`scope:{}`会创建一个独立作用域，有父元素，但是继承不到父元素的属性。\n\n这个对象有三个参数：\n\n    1 .&:把父作用域包装成一个函数，从而以函数的方式读写父作用域的属性\n    2 .=:作用域的属性与父作用域的属性双向绑定\n    3 .@：只能读取父作用域里的值\n    \nHTML：\n\n    <div ng-controller=\"myController\">\n        <div hello-world a-data=\"data\" b-data=\"data\" data=\"{{data}}\">oldValue</div>\n        {{data}}\n    </div>\n\nJS：\n\n     myApp.directive(\"helloWorld\", [function () {\n         return {\n             restrict: 'ECMA',\n             template: \"<div>newValue<span ng-transclude></span><btn></btn></div>\",\n             replace: true,\n             scope:{\n                 a:\"&aData\",\n                 b:\"=bData\",\n                 data:\"@\"\n             },\n             transclude: true,\n             controller:function($scope){\n                 console.log($scope.a());\n                 console.log($scope.b);\n                 console.log($scope.data);\n                 this.fun=function(){\n                     $scope.$apply(function(){\n                        $scope.b=\"aaaa\"; \n                     });\n                 }\n             },\n             controllerAs:\"test\"\n         }\n    }]);\n\n在html中我加了三个属性分别为：`a-data`，`b-data`，`data`分别对应着JS中的`a`，`b`，`data`。第三个是简写形式，如果名字和属性名相同，则后面的名字可以不用写。\n\n当按下按钮会发现页面上的*data*变为*aaaa*这就说明`b`是双向绑定的\n\n**tips:**`@`不能读到对象；使用`@`时html标签里的属性值需要用双花括号括起来。\n\n**小补充：**`priority`是用来设置指令的权值，也就是指令执行的顺序。`terminal`设置是否以当前设置的`priority`为界限，如果小于设置的`priority`就不执行。\n\n就到这里，打完收工！","source":"_posts/angular Study notes.md","raw":"---\ntitle: angular学习笔记(1)\ndate: 2016-10-11 08:26:23\ntags: [angular,基础]\n---\n# angular学习笔记(1)\n\n由于之前学习了vue，所以学习angular感觉还蛮顺的，因为这两个框架有很多相似之处，例如：\n\n    1. 输出都可以用双括号{{}}\n    2. 都有双向数据绑定\n    3. 指令也有很多相似的地方，这里就不一一列举了\n    \n<!-- more-->\n    \n下面准备开始，在开始之前先说明：下面代码的html文件的文档声明，还有头标签、文件的引入都省略了，直接从`ng-app`的内部开始写代码，js文件的模块声明如果没有特殊情况会默认使用`var myApp=angular.module(\"myApp\",[]);`\n    \n# angular的模块化\n\n在学习angular听到最多的就是模块化，任何一个功能都是模块。 \n\n首先，要想用angular就得先引入angular.js文件，然后在*.html*文件中标签加入`ng-app`属性，(一般加在`html`标签或者`body`后面加，作为根部作用域)，告诉angular下面这块内容由angular管，同时自动启动angular，例如以下代码： \n\n    <html ng-app=\"myApp\">\n        <!--这里是angular的作用范围-->\n    </html>\n    \n然后在自己的*.js*文件中声明一个变量，用于储存angular返回的模块： \n\n    var myApp=angular.module(\"myApp\",[]);\n    \n括号中的`myApp`是标签中`ng-app`的属性值`\"myApp\"`，后面的中括号是模块的依赖项，第三个参数是一个回调函数，用来定义angular的一些服务。\n\n如果在*html*文件里面如果没有写`ng-app`，这个时候就得在*js*文件里手动启动angular： \n\n    angular.element(document).ready(function(){\n        angular.bootstrap(document,\"myApp\");\n    });\n    \n同一个`ng-app`不能启动两次，如果启动两次会报错！\n\n**注意：**一般一个应用中只能有一个`ng-app`，当然有少数情况也会有多个`ng-app`，但是`ng-app`不能嵌套在`ng-app`中，这个时候第二个以后的`ng-app`需要手动启动，不过一般不建议有多个`ng-app`。\n\n# 控制器\n\n一个应用中可以有多个控制器，一般一个控制器用于管理应用中的一个功能，例如：\n\nHTML：\n\n    <div ng-controller=\"controller1\">\n        <!--这里是一些指令-->\n    </div>\n    <div ng-controller=\"controller2\">\n        <!--这里是一些指令-->\n    </div>\n\nJS：\n\n    myApp.controller(\"controller1\",[\"$scope\",function($scope){\n        //这里是一些逻辑\n    }]);\n    myApp.controller(\"controller2\",[\"$scope\",function($scope){\n        //这里是一些逻辑\n    }]);\n\njs中的`myApp`就是上面`angular.module(\"myApp\",[])`返回的模块，调用`controller`方法创建一个控制器，第一个参数是HTML中`ng-controller`的属性值，第二个参数是一个数组，里面包含了控制器的一些依赖还有回调函数，`$scope`是angular的作用域，一般用于存储各种变量。\n\n在angular中还有一个`$rootScope`，它是angular的根作用域链，类似于js中的全局作用域，定义在`$rootScrop`上的变量所有控制器都可以访问。\n\n**注意：**\n\n    1. 不要去复用controller，一个控制器一般只负责一块视图\n    2. 不要再controller中操作DOM，这不是控制器的职责\n    3. 不要再controller里面做数据格式化\n    4. 不要再controller里面做数据操作\n    5. 一般来说，controller不会互相调用，控制器之间的交互只会通过事件来进行\n\n# 双向数据绑定\n\n当年angular火有一部分原因是因为它实现了数据的双向绑定，这是其他框架都没有实现的。\n所谓的双向数据绑定就是：数据模型里面的值变了，视图也会跟着变，反过来也是，像下面：\n\nHTML：\n\n    <div ng-controller=\"controller\">\n       <input type=\"text\" ng-model=\"name\">\n       <div>{{name}}<div>\n    </div>\n\nJS：\n\n    myApp.controller(\"controller\",[\"$scope\",function($scope){\n        $scope.name=\"张三\";\n    }]);\n    \n运行以上代码在页面中就会看见有一个输入框里面的值是张三，下面有一段字也是张三。当我们改变输入框中的值会发现下面的那段字也会变，这就实现了数据的双向绑定。\n\n# 指令\n\nangular还有一个吸引人的地方就是指令系统。angular内置了很多的指令，同时，还可以让我们自定义指令。前面说到的`ng-app`和`ng-controller`就是指令。\n\n## ng-bind\n\nHTML：\n\n    <div ng-bind=\"name\"></div>\n    \nJS：\n\n    myApp.controller(\"controller\",[\"$scope\",function($scope){\n        $scope.name=\"张三\";\n    }]);\n\n在页面中也会输出张三，和*双花括号*的作用一样，但是使用`ng-bind`的好处就是，当页面加载速度慢的时候页面中不会出现*双花括号*，保证了页面的美观性。\n\n## ng-class\n\nHTML：\n\n    <div ng-class=\"my-style:true\"></div>\n\n`ng-class`一般用于控制class是否使用，如果`:`后面的表达式为`true`，就使用`:`前面的类名。\n\n## ng-show和ng-hide\n\nHTML：\n\n    <div ng-show=\"true\">我是显示的</div>\n    <div ng-hide=\"true\">我是隐藏的</div>\n    \n当`ng-show`后面的变量为`true`时，这个html元素就会显示，为`false`时就回隐藏，`ng-hide`刚好相反。\n\n## ng-repeat\n\nHTML：\n\n    <div ng-controller=\"myController\">\n        <ul>\n            <li ng-repeat=\"data in datas\">{{data}}</li>\n        </ul>\n    </div>\n    \nJS：\n\n    myApp.controller(\"myController\",[\"$scope\",function($scope){\n        $scope.datas=[\"张三\"，\"李四\",\"王五\"];\n    }]);\n\n这个时候页面就会输出：\n\n    1. 张三\n    2. 李四\n    3. 王五\n\n`ng-repeat`就是用来遍历数据，并且把数据在页面中全部渲染出来，非常方便。\n\n## ng-style\n\nHTML：\n\n    <div ng-style=\"{'color':'red','background-color':'green'}\">字的颜色石红的，背景是绿的</div>\n\n## ng-class-even和ng-class-odd\n\nHTML：\n\n    <div ng-controller=\"myController\">\n        <ul>\n            <li ng-class-even=\"'even-style'\" ng-class-odd=\"'odd-style'\" ng-repeat=\"data in datas\">{{data}}</li>\n        </ul>\n    </div>\n    \nJS：\n\n    myApp.controller(\"myController\",[\"$scope\",function($scope){\n        $scope.datas=[\"张三\"，\"李四\",\"王五\"];\n    }]);\n\n这样当`li`为奇数时，就会用`even-style`的class类，当`li`为偶数时就会用`odd-style`的class类。\n    \n## ng-click\n\nHTML：\n\n    <div ng-controller=\"myController\">\n        <button ng-click=\"changeStatus()\">点我</button>\n    </div>\n    <p>{{status}}</p>\nJS：\n\n    myApp.controller(\"myController\",[\"$scope\",function($scope){\n        $scope.status=false;\n        $scope.changeStatus=function(){\n            $scope.status=!$scope.status;\n        }\n    }]);\n\n每点一次按钮，`changeStatus`函数就会执行一次，`stauts`的值就会改变一次\n\n## ng-switch\n\nHTML：\n\n    <div ng-controller=\"myController\">\n        <button ng-click=\"changeStatus()\">点我</button>\n            <ol switch=\"status\">\n                <li ng-switch-when=\"true\">\n                    当值为true才会显示\n                </li>\n                <li ng-switch-when=\"false\">\n                    当值为false才会显示\n                </li>\n            </ol>\n    </div>\n    <p>{{status}}</p>\n    \nJS：\n\n    myApp.controller(\"myController\",[\"$scope\",function($scope){\n        $scope.status=false;\n        $scope.changeStatus=function(){\n            $scope.status=!$scope.status;\n        }\n    }]);\n    \n## ng-init\n\nHTML：\n\n    <div ng-init=\"[firstName='张',lastName='三']\">\n        {{firstName+lastName}}\n    </div>\n    \n这是页面就会输出`\"张三\"`。`ng-init`用于初始化变量，不过初始化变量一般不这么做。\n\n## ng-src\n\nHTML：\n\n    <img ng-src={{imgUrl}} alt=\"图片\">\n\n`ng-src`是用于解决 `src`属性用ng表达式bug的一个指令，如果地址中包含ng表达式，用`ng-src`比较好。\n\n## 自定义指令\n\n在angular内置的这些指令中肯定是不够用的，所以，angualr可以给我们自定义指令：\n\nHTML：\n\n    <hello-world>oldValue</hello-world>\n    <div class=\"hello-world\">oldValue</div>\n    <!-- directive:hello-world -->\n    <div>oldValue</div>\n    <div hello-world>oldValue</div>\n\nJS：\n\n    myApp.directive(\"helloWorld\",[function(){\n        return{\n            restrict: 'ECMA',\n            template:\"<div>newValue<span ng-transclude></span></div>\",\n            replace:true,\n            transclude:true,\n            link:function(){\n                //在这里可以操作DOM、给元素绑定事件\n            }\n        }\n    }]);\n\njs部分有个`restrict`这个是匹配模式，用于匹配不同的属指令创建方式。\n\nE代表匹配元素模式，也就是我们说的html标签`<hello-world>oldValue</hello-world>`，当需要创建带有自己的模板的指令时，使用这种方法。\n\nC匹配class模式，就是上面的`<div class=\"hello-world\">oldValue</div>`\n\nM代表匹配注释模式，就是上面的`<!-- directive:hello-world --> <div>oldValue</div>`，这里需要注意的就是注释的开头和结尾要有个空格，不然angular是识别不出的。\n\nA代表属性模式，即`<div hello-world>oldValue</div>`，当要为已有的HTML标签增加功能时，使用这种方法创建指令，这也是angular默认的匹配方式。\n\n`template`是填充到标签里的内容\n\n`template`里可以看到有个`ng-transclude`指令，这个指令是在下面的`replace`和`transclude`值为`true`时才有用。当`replace`为真时原来的*oldValue*会被替换成`template`里的内容，但是我们有时候希望保留*oldValue*，所以把`transclude`设为`true`，这个时候angular就知道要把*oldValue*保存下来。但是保留下来得有地方放，这个时候在`template`里面加个`ng-transclude`指令，就可以把*oldValue*放进去。\n\n`template`可以换成`templateUrl`，后面接的是其他的html文件的地址。\n\n`link`函数可以操作DOM、绑定事件、绑定作用域。\n\n最终代码执行完后会得到(以`<hello-world>oldValue</hello-world>`的结果为例)：\n\n    <div>\n        newValue\n        <span ng-transclude=\"\"></span>\n        <div>oldValue</div>\n    </div>\n    \n### 自定义指令的controller和controllAs\n\n还是上面的代码，将JS部分改为：\n\n     var myApp = angular.module(\"myApp\", []);\n     myApp.directive(\"helloWorld\", [function () {\n         return {\n             restrict: 'ECMA',\n             template: \"<div>newValue<span ng-transclude></span></div>\",\n             replace: true,\n             transclude: true,\n             controller:function($scope){\n                 console.log($scope);\n             },\n             link: function () {\n                 //在这里可以操作DOM、给元素绑定事件\n             }\n         }\n    }]);\n    myApp.controller('myController', ['$scope', function ($scope) {\n        console.log($scope);\n    }]);\n\n这样在控制台输出的两个`$scope`实际上是同一个`$scope`。上面那个`controller`写在那里，其他指令可以通过`require`属性获得这个`controller`里面的东西，实现多个指令通过依赖注入进行通信。\n\n### require\n\n`require`可以将其他指令传递给自己，有三个用法：\n\n    1. 通过驼峰法(directiveName)的命名指定了控制器应该带有哪一条指令，默认从同一个元素上的指令找\n    2. ^directiveName，在父级查找\n    3. ?directiveName，指令可选，找不到不要抛出异常\n    \n现在，上面的代码改成了：\n\n     myApp.directive(\"helloWorld\", [function () {\n     return {\n         restrict: 'ECMA',\n         template: \"<div>newValue<span ng-transclude></span><btn></btn></div>\",\n         replace: true,\n         transclude: true,\n         controller:function($scope){\n             this.fun=function(){\n                 alert(\"s\");\n             }\n         },\n         controllerAs:\"test\",\n         link: function (scope,element,attr,test) {\n             element.on(\"click\",test.fun);\n         }\n     }\n    }]);\n    myApp.directive('btn', [function () {\n        return {\n            restrict: 'E',\n            require:\"^helloWorld\",\n            replace:true,\n            template:\"<button>点我</button>\",\n            link: function (scope, element, attrs,test) {\n                element.on(\"click\",test.fun);\n            }\n        };\n    }]);\n\n点击按钮会发现弹出两次a。那是因为在`helloWorld`指令里的`link`函数调用了一次`this.fun`下面的`btn`也调用了一次。如果点击文字就只会弹出一次。\n\n这里的`require`用了`^`是因为`helloWorld`是`btn`的父级。\n\n### scope\n\n#### scope:true\n\n在上面说了自定义指令里的`controller`和下面的`myController`是同一个控制器。但是当我在自定义指令里(`helloWorld`指令)加一句`scope:true`时，这两个控制器就有不同的作用域了：\n\n    myApp.directive(\"helloWorld\", [function () {\n         return {\n             restrict: 'ECMA',\n             template: \"<div>newValue<span ng-transclude></span><btn></btn></div>\",\n             replace: true,\n             scope:true,\n             transclude: true,\n             controller:function($scope){\n                 console.log($scope);\n                 this.fun=function(){\n                     alert(\"s\");\n                 }\n             },\n             controllerAs:\"test\"\n         }\n    }]);\n    \n这时，控制台输出的两个`scope`，展开来看会发现它们的*id*不一样，*id*小的那个是*id*大的父作用域，子作用域可以继承父作用域里的属性，父作用域读不到子作用域里的属性。\n\n#### scope:{}\n\n当`scope:{}`会创建一个独立作用域，有父元素，但是继承不到父元素的属性。\n\n这个对象有三个参数：\n\n    1 .&:把父作用域包装成一个函数，从而以函数的方式读写父作用域的属性\n    2 .=:作用域的属性与父作用域的属性双向绑定\n    3 .@：只能读取父作用域里的值\n    \nHTML：\n\n    <div ng-controller=\"myController\">\n        <div hello-world a-data=\"data\" b-data=\"data\" data=\"{{data}}\">oldValue</div>\n        {{data}}\n    </div>\n\nJS：\n\n     myApp.directive(\"helloWorld\", [function () {\n         return {\n             restrict: 'ECMA',\n             template: \"<div>newValue<span ng-transclude></span><btn></btn></div>\",\n             replace: true,\n             scope:{\n                 a:\"&aData\",\n                 b:\"=bData\",\n                 data:\"@\"\n             },\n             transclude: true,\n             controller:function($scope){\n                 console.log($scope.a());\n                 console.log($scope.b);\n                 console.log($scope.data);\n                 this.fun=function(){\n                     $scope.$apply(function(){\n                        $scope.b=\"aaaa\"; \n                     });\n                 }\n             },\n             controllerAs:\"test\"\n         }\n    }]);\n\n在html中我加了三个属性分别为：`a-data`，`b-data`，`data`分别对应着JS中的`a`，`b`，`data`。第三个是简写形式，如果名字和属性名相同，则后面的名字可以不用写。\n\n当按下按钮会发现页面上的*data*变为*aaaa*这就说明`b`是双向绑定的\n\n**tips:**`@`不能读到对象；使用`@`时html标签里的属性值需要用双花括号括起来。\n\n**小补充：**`priority`是用来设置指令的权值，也就是指令执行的顺序。`terminal`设置是否以当前设置的`priority`为界限，如果小于设置的`priority`就不执行。\n\n就到这里，打完收工！","slug":"angular Study notes","published":1,"updated":"2020-04-07T03:29:17.933Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8qzc34k000e2cl6a5y7ipuu","content":"<h1 id=\"angular学习笔记-1\"><a href=\"#angular学习笔记-1\" class=\"headerlink\" title=\"angular学习笔记(1)\"></a>angular学习笔记(1)</h1><p>由于之前学习了vue，所以学习angular感觉还蛮顺的，因为这两个框架有很多相似之处，例如：</p>\n<pre><code>1. 输出都可以用双括号{{}}\n2. 都有双向数据绑定\n3. 指令也有很多相似的地方，这里就不一一列举了\n</code></pre><a id=\"more\"></a>\n<p>下面准备开始，在开始之前先说明：下面代码的html文件的文档声明，还有头标签、文件的引入都省略了，直接从<code>ng-app</code>的内部开始写代码，js文件的模块声明如果没有特殊情况会默认使用<code>var myApp=angular.module(&quot;myApp&quot;,[]);</code></p>\n<h1 id=\"angular的模块化\"><a href=\"#angular的模块化\" class=\"headerlink\" title=\"angular的模块化\"></a>angular的模块化</h1><p>在学习angular听到最多的就是模块化，任何一个功能都是模块。 </p>\n<p>首先，要想用angular就得先引入angular.js文件，然后在<em>.html</em>文件中标签加入<code>ng-app</code>属性，(一般加在<code>html</code>标签或者<code>body</code>后面加，作为根部作用域)，告诉angular下面这块内容由angular管，同时自动启动angular，例如以下代码： </p>\n<pre><code>&lt;html ng-app=&quot;myApp&quot;&gt;\n    &lt;!--这里是angular的作用范围--&gt;\n&lt;/html&gt;\n</code></pre><p>然后在自己的<em>.js</em>文件中声明一个变量，用于储存angular返回的模块： </p>\n<pre><code>var myApp=angular.module(&quot;myApp&quot;,[]);\n</code></pre><p>括号中的<code>myApp</code>是标签中<code>ng-app</code>的属性值<code>&quot;myApp&quot;</code>，后面的中括号是模块的依赖项，第三个参数是一个回调函数，用来定义angular的一些服务。</p>\n<p>如果在<em>html</em>文件里面如果没有写<code>ng-app</code>，这个时候就得在<em>js</em>文件里手动启动angular： </p>\n<pre><code>angular.element(document).ready(function(){\n    angular.bootstrap(document,&quot;myApp&quot;);\n});\n</code></pre><p>同一个<code>ng-app</code>不能启动两次，如果启动两次会报错！</p>\n<p><strong>注意：</strong>一般一个应用中只能有一个<code>ng-app</code>，当然有少数情况也会有多个<code>ng-app</code>，但是<code>ng-app</code>不能嵌套在<code>ng-app</code>中，这个时候第二个以后的<code>ng-app</code>需要手动启动，不过一般不建议有多个<code>ng-app</code>。</p>\n<h1 id=\"控制器\"><a href=\"#控制器\" class=\"headerlink\" title=\"控制器\"></a>控制器</h1><p>一个应用中可以有多个控制器，一般一个控制器用于管理应用中的一个功能，例如：</p>\n<p>HTML：</p>\n<pre><code>&lt;div ng-controller=&quot;controller1&quot;&gt;\n    &lt;!--这里是一些指令--&gt;\n&lt;/div&gt;\n&lt;div ng-controller=&quot;controller2&quot;&gt;\n    &lt;!--这里是一些指令--&gt;\n&lt;/div&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.controller(&quot;controller1&quot;,[&quot;$scope&quot;,function($scope){\n    //这里是一些逻辑\n}]);\nmyApp.controller(&quot;controller2&quot;,[&quot;$scope&quot;,function($scope){\n    //这里是一些逻辑\n}]);\n</code></pre><p>js中的<code>myApp</code>就是上面<code>angular.module(&quot;myApp&quot;,[])</code>返回的模块，调用<code>controller</code>方法创建一个控制器，第一个参数是HTML中<code>ng-controller</code>的属性值，第二个参数是一个数组，里面包含了控制器的一些依赖还有回调函数，<code>$scope</code>是angular的作用域，一般用于存储各种变量。</p>\n<p>在angular中还有一个<code>$rootScope</code>，它是angular的根作用域链，类似于js中的全局作用域，定义在<code>$rootScrop</code>上的变量所有控制器都可以访问。</p>\n<p><strong>注意：</strong></p>\n<pre><code>1. 不要去复用controller，一个控制器一般只负责一块视图\n2. 不要再controller中操作DOM，这不是控制器的职责\n3. 不要再controller里面做数据格式化\n4. 不要再controller里面做数据操作\n5. 一般来说，controller不会互相调用，控制器之间的交互只会通过事件来进行\n</code></pre><h1 id=\"双向数据绑定\"><a href=\"#双向数据绑定\" class=\"headerlink\" title=\"双向数据绑定\"></a>双向数据绑定</h1><p>当年angular火有一部分原因是因为它实现了数据的双向绑定，这是其他框架都没有实现的。<br>所谓的双向数据绑定就是：数据模型里面的值变了，视图也会跟着变，反过来也是，像下面：</p>\n<p>HTML：</p>\n<pre><code>&lt;div ng-controller=&quot;controller&quot;&gt;\n   &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;\n   &lt;div&gt;{{name}}&lt;div&gt;\n&lt;/div&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.controller(&quot;controller&quot;,[&quot;$scope&quot;,function($scope){\n    $scope.name=&quot;张三&quot;;\n}]);\n</code></pre><p>运行以上代码在页面中就会看见有一个输入框里面的值是张三，下面有一段字也是张三。当我们改变输入框中的值会发现下面的那段字也会变，这就实现了数据的双向绑定。</p>\n<h1 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h1><p>angular还有一个吸引人的地方就是指令系统。angular内置了很多的指令，同时，还可以让我们自定义指令。前面说到的<code>ng-app</code>和<code>ng-controller</code>就是指令。</p>\n<h2 id=\"ng-bind\"><a href=\"#ng-bind\" class=\"headerlink\" title=\"ng-bind\"></a>ng-bind</h2><p>HTML：</p>\n<pre><code>&lt;div ng-bind=&quot;name&quot;&gt;&lt;/div&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.controller(&quot;controller&quot;,[&quot;$scope&quot;,function($scope){\n    $scope.name=&quot;张三&quot;;\n}]);\n</code></pre><p>在页面中也会输出张三，和<em>双花括号</em>的作用一样，但是使用<code>ng-bind</code>的好处就是，当页面加载速度慢的时候页面中不会出现<em>双花括号</em>，保证了页面的美观性。</p>\n<h2 id=\"ng-class\"><a href=\"#ng-class\" class=\"headerlink\" title=\"ng-class\"></a>ng-class</h2><p>HTML：</p>\n<pre><code>&lt;div ng-class=&quot;my-style:true&quot;&gt;&lt;/div&gt;\n</code></pre><p><code>ng-class</code>一般用于控制class是否使用，如果<code>:</code>后面的表达式为<code>true</code>，就使用<code>:</code>前面的类名。</p>\n<h2 id=\"ng-show和ng-hide\"><a href=\"#ng-show和ng-hide\" class=\"headerlink\" title=\"ng-show和ng-hide\"></a>ng-show和ng-hide</h2><p>HTML：</p>\n<pre><code>&lt;div ng-show=&quot;true&quot;&gt;我是显示的&lt;/div&gt;\n&lt;div ng-hide=&quot;true&quot;&gt;我是隐藏的&lt;/div&gt;\n</code></pre><p>当<code>ng-show</code>后面的变量为<code>true</code>时，这个html元素就会显示，为<code>false</code>时就回隐藏，<code>ng-hide</code>刚好相反。</p>\n<h2 id=\"ng-repeat\"><a href=\"#ng-repeat\" class=\"headerlink\" title=\"ng-repeat\"></a>ng-repeat</h2><p>HTML：</p>\n<pre><code>&lt;div ng-controller=&quot;myController&quot;&gt;\n    &lt;ul&gt;\n        &lt;li ng-repeat=&quot;data in datas&quot;&gt;{{data}}&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.controller(&quot;myController&quot;,[&quot;$scope&quot;,function($scope){\n    $scope.datas=[&quot;张三&quot;，&quot;李四&quot;,&quot;王五&quot;];\n}]);\n</code></pre><p>这个时候页面就会输出：</p>\n<pre><code>1. 张三\n2. 李四\n3. 王五\n</code></pre><p><code>ng-repeat</code>就是用来遍历数据，并且把数据在页面中全部渲染出来，非常方便。</p>\n<h2 id=\"ng-style\"><a href=\"#ng-style\" class=\"headerlink\" title=\"ng-style\"></a>ng-style</h2><p>HTML：</p>\n<pre><code>&lt;div ng-style=&quot;{&apos;color&apos;:&apos;red&apos;,&apos;background-color&apos;:&apos;green&apos;}&quot;&gt;字的颜色石红的，背景是绿的&lt;/div&gt;\n</code></pre><h2 id=\"ng-class-even和ng-class-odd\"><a href=\"#ng-class-even和ng-class-odd\" class=\"headerlink\" title=\"ng-class-even和ng-class-odd\"></a>ng-class-even和ng-class-odd</h2><p>HTML：</p>\n<pre><code>&lt;div ng-controller=&quot;myController&quot;&gt;\n    &lt;ul&gt;\n        &lt;li ng-class-even=&quot;&apos;even-style&apos;&quot; ng-class-odd=&quot;&apos;odd-style&apos;&quot; ng-repeat=&quot;data in datas&quot;&gt;{{data}}&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.controller(&quot;myController&quot;,[&quot;$scope&quot;,function($scope){\n    $scope.datas=[&quot;张三&quot;，&quot;李四&quot;,&quot;王五&quot;];\n}]);\n</code></pre><p>这样当<code>li</code>为奇数时，就会用<code>even-style</code>的class类，当<code>li</code>为偶数时就会用<code>odd-style</code>的class类。</p>\n<h2 id=\"ng-click\"><a href=\"#ng-click\" class=\"headerlink\" title=\"ng-click\"></a>ng-click</h2><p>HTML：</p>\n<pre><code>&lt;div ng-controller=&quot;myController&quot;&gt;\n    &lt;button ng-click=&quot;changeStatus()&quot;&gt;点我&lt;/button&gt;\n&lt;/div&gt;\n&lt;p&gt;{{status}}&lt;/p&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.controller(&quot;myController&quot;,[&quot;$scope&quot;,function($scope){\n    $scope.status=false;\n    $scope.changeStatus=function(){\n        $scope.status=!$scope.status;\n    }\n}]);\n</code></pre><p>每点一次按钮，<code>changeStatus</code>函数就会执行一次，<code>stauts</code>的值就会改变一次</p>\n<h2 id=\"ng-switch\"><a href=\"#ng-switch\" class=\"headerlink\" title=\"ng-switch\"></a>ng-switch</h2><p>HTML：</p>\n<pre><code>&lt;div ng-controller=&quot;myController&quot;&gt;\n    &lt;button ng-click=&quot;changeStatus()&quot;&gt;点我&lt;/button&gt;\n        &lt;ol switch=&quot;status&quot;&gt;\n            &lt;li ng-switch-when=&quot;true&quot;&gt;\n                当值为true才会显示\n            &lt;/li&gt;\n            &lt;li ng-switch-when=&quot;false&quot;&gt;\n                当值为false才会显示\n            &lt;/li&gt;\n        &lt;/ol&gt;\n&lt;/div&gt;\n&lt;p&gt;{{status}}&lt;/p&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.controller(&quot;myController&quot;,[&quot;$scope&quot;,function($scope){\n    $scope.status=false;\n    $scope.changeStatus=function(){\n        $scope.status=!$scope.status;\n    }\n}]);\n</code></pre><h2 id=\"ng-init\"><a href=\"#ng-init\" class=\"headerlink\" title=\"ng-init\"></a>ng-init</h2><p>HTML：</p>\n<pre><code>&lt;div ng-init=&quot;[firstName=&apos;张&apos;,lastName=&apos;三&apos;]&quot;&gt;\n    {{firstName+lastName}}\n&lt;/div&gt;\n</code></pre><p>这是页面就会输出<code>&quot;张三&quot;</code>。<code>ng-init</code>用于初始化变量，不过初始化变量一般不这么做。</p>\n<h2 id=\"ng-src\"><a href=\"#ng-src\" class=\"headerlink\" title=\"ng-src\"></a>ng-src</h2><p>HTML：</p>\n<pre><code>&lt;img ng-src={{imgUrl}} alt=&quot;图片&quot;&gt;\n</code></pre><p><code>ng-src</code>是用于解决 <code>src</code>属性用ng表达式bug的一个指令，如果地址中包含ng表达式，用<code>ng-src</code>比较好。</p>\n<h2 id=\"自定义指令\"><a href=\"#自定义指令\" class=\"headerlink\" title=\"自定义指令\"></a>自定义指令</h2><p>在angular内置的这些指令中肯定是不够用的，所以，angualr可以给我们自定义指令：</p>\n<p>HTML：</p>\n<pre><code>&lt;hello-world&gt;oldValue&lt;/hello-world&gt;\n&lt;div class=&quot;hello-world&quot;&gt;oldValue&lt;/div&gt;\n&lt;!-- directive:hello-world --&gt;\n&lt;div&gt;oldValue&lt;/div&gt;\n&lt;div hello-world&gt;oldValue&lt;/div&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.directive(&quot;helloWorld&quot;,[function(){\n    return{\n        restrict: &apos;ECMA&apos;,\n        template:&quot;&lt;div&gt;newValue&lt;span ng-transclude&gt;&lt;/span&gt;&lt;/div&gt;&quot;,\n        replace:true,\n        transclude:true,\n        link:function(){\n            //在这里可以操作DOM、给元素绑定事件\n        }\n    }\n}]);\n</code></pre><p>js部分有个<code>restrict</code>这个是匹配模式，用于匹配不同的属指令创建方式。</p>\n<p>E代表匹配元素模式，也就是我们说的html标签<code>&lt;hello-world&gt;oldValue&lt;/hello-world&gt;</code>，当需要创建带有自己的模板的指令时，使用这种方法。</p>\n<p>C匹配class模式，就是上面的<code>&lt;div class=&quot;hello-world&quot;&gt;oldValue&lt;/div&gt;</code></p>\n<p>M代表匹配注释模式，就是上面的<code>&lt;!-- directive:hello-world --&gt; &lt;div&gt;oldValue&lt;/div&gt;</code>，这里需要注意的就是注释的开头和结尾要有个空格，不然angular是识别不出的。</p>\n<p>A代表属性模式，即<code>&lt;div hello-world&gt;oldValue&lt;/div&gt;</code>，当要为已有的HTML标签增加功能时，使用这种方法创建指令，这也是angular默认的匹配方式。</p>\n<p><code>template</code>是填充到标签里的内容</p>\n<p><code>template</code>里可以看到有个<code>ng-transclude</code>指令，这个指令是在下面的<code>replace</code>和<code>transclude</code>值为<code>true</code>时才有用。当<code>replace</code>为真时原来的<em>oldValue</em>会被替换成<code>template</code>里的内容，但是我们有时候希望保留<em>oldValue</em>，所以把<code>transclude</code>设为<code>true</code>，这个时候angular就知道要把<em>oldValue</em>保存下来。但是保留下来得有地方放，这个时候在<code>template</code>里面加个<code>ng-transclude</code>指令，就可以把<em>oldValue</em>放进去。</p>\n<p><code>template</code>可以换成<code>templateUrl</code>，后面接的是其他的html文件的地址。</p>\n<p><code>link</code>函数可以操作DOM、绑定事件、绑定作用域。</p>\n<p>最终代码执行完后会得到(以<code>&lt;hello-world&gt;oldValue&lt;/hello-world&gt;</code>的结果为例)：</p>\n<pre><code>&lt;div&gt;\n    newValue\n    &lt;span ng-transclude=&quot;&quot;&gt;&lt;/span&gt;\n    &lt;div&gt;oldValue&lt;/div&gt;\n&lt;/div&gt;\n</code></pre><h3 id=\"自定义指令的controller和controllAs\"><a href=\"#自定义指令的controller和controllAs\" class=\"headerlink\" title=\"自定义指令的controller和controllAs\"></a>自定义指令的controller和controllAs</h3><p>还是上面的代码，将JS部分改为：</p>\n<pre><code> var myApp = angular.module(&quot;myApp&quot;, []);\n myApp.directive(&quot;helloWorld&quot;, [function () {\n     return {\n         restrict: &apos;ECMA&apos;,\n         template: &quot;&lt;div&gt;newValue&lt;span ng-transclude&gt;&lt;/span&gt;&lt;/div&gt;&quot;,\n         replace: true,\n         transclude: true,\n         controller:function($scope){\n             console.log($scope);\n         },\n         link: function () {\n             //在这里可以操作DOM、给元素绑定事件\n         }\n     }\n}]);\nmyApp.controller(&apos;myController&apos;, [&apos;$scope&apos;, function ($scope) {\n    console.log($scope);\n}]);\n</code></pre><p>这样在控制台输出的两个<code>$scope</code>实际上是同一个<code>$scope</code>。上面那个<code>controller</code>写在那里，其他指令可以通过<code>require</code>属性获得这个<code>controller</code>里面的东西，实现多个指令通过依赖注入进行通信。</p>\n<h3 id=\"require\"><a href=\"#require\" class=\"headerlink\" title=\"require\"></a>require</h3><p><code>require</code>可以将其他指令传递给自己，有三个用法：</p>\n<pre><code>1. 通过驼峰法(directiveName)的命名指定了控制器应该带有哪一条指令，默认从同一个元素上的指令找\n2. ^directiveName，在父级查找\n3. ?directiveName，指令可选，找不到不要抛出异常\n</code></pre><p>现在，上面的代码改成了：</p>\n<pre><code> myApp.directive(&quot;helloWorld&quot;, [function () {\n return {\n     restrict: &apos;ECMA&apos;,\n     template: &quot;&lt;div&gt;newValue&lt;span ng-transclude&gt;&lt;/span&gt;&lt;btn&gt;&lt;/btn&gt;&lt;/div&gt;&quot;,\n     replace: true,\n     transclude: true,\n     controller:function($scope){\n         this.fun=function(){\n             alert(&quot;s&quot;);\n         }\n     },\n     controllerAs:&quot;test&quot;,\n     link: function (scope,element,attr,test) {\n         element.on(&quot;click&quot;,test.fun);\n     }\n }\n}]);\nmyApp.directive(&apos;btn&apos;, [function () {\n    return {\n        restrict: &apos;E&apos;,\n        require:&quot;^helloWorld&quot;,\n        replace:true,\n        template:&quot;&lt;button&gt;点我&lt;/button&gt;&quot;,\n        link: function (scope, element, attrs,test) {\n            element.on(&quot;click&quot;,test.fun);\n        }\n    };\n}]);\n</code></pre><p>点击按钮会发现弹出两次a。那是因为在<code>helloWorld</code>指令里的<code>link</code>函数调用了一次<code>this.fun</code>下面的<code>btn</code>也调用了一次。如果点击文字就只会弹出一次。</p>\n<p>这里的<code>require</code>用了<code>^</code>是因为<code>helloWorld</code>是<code>btn</code>的父级。</p>\n<h3 id=\"scope\"><a href=\"#scope\" class=\"headerlink\" title=\"scope\"></a>scope</h3><h4 id=\"scope-true\"><a href=\"#scope-true\" class=\"headerlink\" title=\"scope:true\"></a>scope:true</h4><p>在上面说了自定义指令里的<code>controller</code>和下面的<code>myController</code>是同一个控制器。但是当我在自定义指令里(<code>helloWorld</code>指令)加一句<code>scope:true</code>时，这两个控制器就有不同的作用域了：</p>\n<pre><code>myApp.directive(&quot;helloWorld&quot;, [function () {\n     return {\n         restrict: &apos;ECMA&apos;,\n         template: &quot;&lt;div&gt;newValue&lt;span ng-transclude&gt;&lt;/span&gt;&lt;btn&gt;&lt;/btn&gt;&lt;/div&gt;&quot;,\n         replace: true,\n         scope:true,\n         transclude: true,\n         controller:function($scope){\n             console.log($scope);\n             this.fun=function(){\n                 alert(&quot;s&quot;);\n             }\n         },\n         controllerAs:&quot;test&quot;\n     }\n}]);\n</code></pre><p>这时，控制台输出的两个<code>scope</code>，展开来看会发现它们的<em>id</em>不一样，<em>id</em>小的那个是<em>id</em>大的父作用域，子作用域可以继承父作用域里的属性，父作用域读不到子作用域里的属性。</p>\n<h4 id=\"scope-1\"><a href=\"#scope-1\" class=\"headerlink\" title=\"scope:{}\"></a>scope:{}</h4><p>当<code>scope:{}</code>会创建一个独立作用域，有父元素，但是继承不到父元素的属性。</p>\n<p>这个对象有三个参数：</p>\n<pre><code>1 .&amp;:把父作用域包装成一个函数，从而以函数的方式读写父作用域的属性\n2 .=:作用域的属性与父作用域的属性双向绑定\n3 .@：只能读取父作用域里的值\n</code></pre><p>HTML：</p>\n<pre><code>&lt;div ng-controller=&quot;myController&quot;&gt;\n    &lt;div hello-world a-data=&quot;data&quot; b-data=&quot;data&quot; data=&quot;{{data}}&quot;&gt;oldValue&lt;/div&gt;\n    {{data}}\n&lt;/div&gt;\n</code></pre><p>JS：</p>\n<pre><code> myApp.directive(&quot;helloWorld&quot;, [function () {\n     return {\n         restrict: &apos;ECMA&apos;,\n         template: &quot;&lt;div&gt;newValue&lt;span ng-transclude&gt;&lt;/span&gt;&lt;btn&gt;&lt;/btn&gt;&lt;/div&gt;&quot;,\n         replace: true,\n         scope:{\n             a:&quot;&amp;aData&quot;,\n             b:&quot;=bData&quot;,\n             data:&quot;@&quot;\n         },\n         transclude: true,\n         controller:function($scope){\n             console.log($scope.a());\n             console.log($scope.b);\n             console.log($scope.data);\n             this.fun=function(){\n                 $scope.$apply(function(){\n                    $scope.b=&quot;aaaa&quot;; \n                 });\n             }\n         },\n         controllerAs:&quot;test&quot;\n     }\n}]);\n</code></pre><p>在html中我加了三个属性分别为：<code>a-data</code>，<code>b-data</code>，<code>data</code>分别对应着JS中的<code>a</code>，<code>b</code>，<code>data</code>。第三个是简写形式，如果名字和属性名相同，则后面的名字可以不用写。</p>\n<p>当按下按钮会发现页面上的<em>data</em>变为<em>aaaa</em>这就说明<code>b</code>是双向绑定的</p>\n<p><strong>tips:</strong><code>@</code>不能读到对象；使用<code>@</code>时html标签里的属性值需要用双花括号括起来。</p>\n<p><strong>小补充：</strong><code>priority</code>是用来设置指令的权值，也就是指令执行的顺序。<code>terminal</code>设置是否以当前设置的<code>priority</code>为界限，如果小于设置的<code>priority</code>就不执行。</p>\n<p>就到这里，打完收工！</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"angular学习笔记-1\"><a href=\"#angular学习笔记-1\" class=\"headerlink\" title=\"angular学习笔记(1)\"></a>angular学习笔记(1)</h1><p>由于之前学习了vue，所以学习angular感觉还蛮顺的，因为这两个框架有很多相似之处，例如：</p>\n<pre><code>1. 输出都可以用双括号{{}}\n2. 都有双向数据绑定\n3. 指令也有很多相似的地方，这里就不一一列举了\n</code></pre>","more":"<p>下面准备开始，在开始之前先说明：下面代码的html文件的文档声明，还有头标签、文件的引入都省略了，直接从<code>ng-app</code>的内部开始写代码，js文件的模块声明如果没有特殊情况会默认使用<code>var myApp=angular.module(&quot;myApp&quot;,[]);</code></p>\n<h1 id=\"angular的模块化\"><a href=\"#angular的模块化\" class=\"headerlink\" title=\"angular的模块化\"></a>angular的模块化</h1><p>在学习angular听到最多的就是模块化，任何一个功能都是模块。 </p>\n<p>首先，要想用angular就得先引入angular.js文件，然后在<em>.html</em>文件中标签加入<code>ng-app</code>属性，(一般加在<code>html</code>标签或者<code>body</code>后面加，作为根部作用域)，告诉angular下面这块内容由angular管，同时自动启动angular，例如以下代码： </p>\n<pre><code>&lt;html ng-app=&quot;myApp&quot;&gt;\n    &lt;!--这里是angular的作用范围--&gt;\n&lt;/html&gt;\n</code></pre><p>然后在自己的<em>.js</em>文件中声明一个变量，用于储存angular返回的模块： </p>\n<pre><code>var myApp=angular.module(&quot;myApp&quot;,[]);\n</code></pre><p>括号中的<code>myApp</code>是标签中<code>ng-app</code>的属性值<code>&quot;myApp&quot;</code>，后面的中括号是模块的依赖项，第三个参数是一个回调函数，用来定义angular的一些服务。</p>\n<p>如果在<em>html</em>文件里面如果没有写<code>ng-app</code>，这个时候就得在<em>js</em>文件里手动启动angular： </p>\n<pre><code>angular.element(document).ready(function(){\n    angular.bootstrap(document,&quot;myApp&quot;);\n});\n</code></pre><p>同一个<code>ng-app</code>不能启动两次，如果启动两次会报错！</p>\n<p><strong>注意：</strong>一般一个应用中只能有一个<code>ng-app</code>，当然有少数情况也会有多个<code>ng-app</code>，但是<code>ng-app</code>不能嵌套在<code>ng-app</code>中，这个时候第二个以后的<code>ng-app</code>需要手动启动，不过一般不建议有多个<code>ng-app</code>。</p>\n<h1 id=\"控制器\"><a href=\"#控制器\" class=\"headerlink\" title=\"控制器\"></a>控制器</h1><p>一个应用中可以有多个控制器，一般一个控制器用于管理应用中的一个功能，例如：</p>\n<p>HTML：</p>\n<pre><code>&lt;div ng-controller=&quot;controller1&quot;&gt;\n    &lt;!--这里是一些指令--&gt;\n&lt;/div&gt;\n&lt;div ng-controller=&quot;controller2&quot;&gt;\n    &lt;!--这里是一些指令--&gt;\n&lt;/div&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.controller(&quot;controller1&quot;,[&quot;$scope&quot;,function($scope){\n    //这里是一些逻辑\n}]);\nmyApp.controller(&quot;controller2&quot;,[&quot;$scope&quot;,function($scope){\n    //这里是一些逻辑\n}]);\n</code></pre><p>js中的<code>myApp</code>就是上面<code>angular.module(&quot;myApp&quot;,[])</code>返回的模块，调用<code>controller</code>方法创建一个控制器，第一个参数是HTML中<code>ng-controller</code>的属性值，第二个参数是一个数组，里面包含了控制器的一些依赖还有回调函数，<code>$scope</code>是angular的作用域，一般用于存储各种变量。</p>\n<p>在angular中还有一个<code>$rootScope</code>，它是angular的根作用域链，类似于js中的全局作用域，定义在<code>$rootScrop</code>上的变量所有控制器都可以访问。</p>\n<p><strong>注意：</strong></p>\n<pre><code>1. 不要去复用controller，一个控制器一般只负责一块视图\n2. 不要再controller中操作DOM，这不是控制器的职责\n3. 不要再controller里面做数据格式化\n4. 不要再controller里面做数据操作\n5. 一般来说，controller不会互相调用，控制器之间的交互只会通过事件来进行\n</code></pre><h1 id=\"双向数据绑定\"><a href=\"#双向数据绑定\" class=\"headerlink\" title=\"双向数据绑定\"></a>双向数据绑定</h1><p>当年angular火有一部分原因是因为它实现了数据的双向绑定，这是其他框架都没有实现的。<br>所谓的双向数据绑定就是：数据模型里面的值变了，视图也会跟着变，反过来也是，像下面：</p>\n<p>HTML：</p>\n<pre><code>&lt;div ng-controller=&quot;controller&quot;&gt;\n   &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;\n   &lt;div&gt;{{name}}&lt;div&gt;\n&lt;/div&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.controller(&quot;controller&quot;,[&quot;$scope&quot;,function($scope){\n    $scope.name=&quot;张三&quot;;\n}]);\n</code></pre><p>运行以上代码在页面中就会看见有一个输入框里面的值是张三，下面有一段字也是张三。当我们改变输入框中的值会发现下面的那段字也会变，这就实现了数据的双向绑定。</p>\n<h1 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h1><p>angular还有一个吸引人的地方就是指令系统。angular内置了很多的指令，同时，还可以让我们自定义指令。前面说到的<code>ng-app</code>和<code>ng-controller</code>就是指令。</p>\n<h2 id=\"ng-bind\"><a href=\"#ng-bind\" class=\"headerlink\" title=\"ng-bind\"></a>ng-bind</h2><p>HTML：</p>\n<pre><code>&lt;div ng-bind=&quot;name&quot;&gt;&lt;/div&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.controller(&quot;controller&quot;,[&quot;$scope&quot;,function($scope){\n    $scope.name=&quot;张三&quot;;\n}]);\n</code></pre><p>在页面中也会输出张三，和<em>双花括号</em>的作用一样，但是使用<code>ng-bind</code>的好处就是，当页面加载速度慢的时候页面中不会出现<em>双花括号</em>，保证了页面的美观性。</p>\n<h2 id=\"ng-class\"><a href=\"#ng-class\" class=\"headerlink\" title=\"ng-class\"></a>ng-class</h2><p>HTML：</p>\n<pre><code>&lt;div ng-class=&quot;my-style:true&quot;&gt;&lt;/div&gt;\n</code></pre><p><code>ng-class</code>一般用于控制class是否使用，如果<code>:</code>后面的表达式为<code>true</code>，就使用<code>:</code>前面的类名。</p>\n<h2 id=\"ng-show和ng-hide\"><a href=\"#ng-show和ng-hide\" class=\"headerlink\" title=\"ng-show和ng-hide\"></a>ng-show和ng-hide</h2><p>HTML：</p>\n<pre><code>&lt;div ng-show=&quot;true&quot;&gt;我是显示的&lt;/div&gt;\n&lt;div ng-hide=&quot;true&quot;&gt;我是隐藏的&lt;/div&gt;\n</code></pre><p>当<code>ng-show</code>后面的变量为<code>true</code>时，这个html元素就会显示，为<code>false</code>时就回隐藏，<code>ng-hide</code>刚好相反。</p>\n<h2 id=\"ng-repeat\"><a href=\"#ng-repeat\" class=\"headerlink\" title=\"ng-repeat\"></a>ng-repeat</h2><p>HTML：</p>\n<pre><code>&lt;div ng-controller=&quot;myController&quot;&gt;\n    &lt;ul&gt;\n        &lt;li ng-repeat=&quot;data in datas&quot;&gt;{{data}}&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.controller(&quot;myController&quot;,[&quot;$scope&quot;,function($scope){\n    $scope.datas=[&quot;张三&quot;，&quot;李四&quot;,&quot;王五&quot;];\n}]);\n</code></pre><p>这个时候页面就会输出：</p>\n<pre><code>1. 张三\n2. 李四\n3. 王五\n</code></pre><p><code>ng-repeat</code>就是用来遍历数据，并且把数据在页面中全部渲染出来，非常方便。</p>\n<h2 id=\"ng-style\"><a href=\"#ng-style\" class=\"headerlink\" title=\"ng-style\"></a>ng-style</h2><p>HTML：</p>\n<pre><code>&lt;div ng-style=&quot;{&apos;color&apos;:&apos;red&apos;,&apos;background-color&apos;:&apos;green&apos;}&quot;&gt;字的颜色石红的，背景是绿的&lt;/div&gt;\n</code></pre><h2 id=\"ng-class-even和ng-class-odd\"><a href=\"#ng-class-even和ng-class-odd\" class=\"headerlink\" title=\"ng-class-even和ng-class-odd\"></a>ng-class-even和ng-class-odd</h2><p>HTML：</p>\n<pre><code>&lt;div ng-controller=&quot;myController&quot;&gt;\n    &lt;ul&gt;\n        &lt;li ng-class-even=&quot;&apos;even-style&apos;&quot; ng-class-odd=&quot;&apos;odd-style&apos;&quot; ng-repeat=&quot;data in datas&quot;&gt;{{data}}&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.controller(&quot;myController&quot;,[&quot;$scope&quot;,function($scope){\n    $scope.datas=[&quot;张三&quot;，&quot;李四&quot;,&quot;王五&quot;];\n}]);\n</code></pre><p>这样当<code>li</code>为奇数时，就会用<code>even-style</code>的class类，当<code>li</code>为偶数时就会用<code>odd-style</code>的class类。</p>\n<h2 id=\"ng-click\"><a href=\"#ng-click\" class=\"headerlink\" title=\"ng-click\"></a>ng-click</h2><p>HTML：</p>\n<pre><code>&lt;div ng-controller=&quot;myController&quot;&gt;\n    &lt;button ng-click=&quot;changeStatus()&quot;&gt;点我&lt;/button&gt;\n&lt;/div&gt;\n&lt;p&gt;{{status}}&lt;/p&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.controller(&quot;myController&quot;,[&quot;$scope&quot;,function($scope){\n    $scope.status=false;\n    $scope.changeStatus=function(){\n        $scope.status=!$scope.status;\n    }\n}]);\n</code></pre><p>每点一次按钮，<code>changeStatus</code>函数就会执行一次，<code>stauts</code>的值就会改变一次</p>\n<h2 id=\"ng-switch\"><a href=\"#ng-switch\" class=\"headerlink\" title=\"ng-switch\"></a>ng-switch</h2><p>HTML：</p>\n<pre><code>&lt;div ng-controller=&quot;myController&quot;&gt;\n    &lt;button ng-click=&quot;changeStatus()&quot;&gt;点我&lt;/button&gt;\n        &lt;ol switch=&quot;status&quot;&gt;\n            &lt;li ng-switch-when=&quot;true&quot;&gt;\n                当值为true才会显示\n            &lt;/li&gt;\n            &lt;li ng-switch-when=&quot;false&quot;&gt;\n                当值为false才会显示\n            &lt;/li&gt;\n        &lt;/ol&gt;\n&lt;/div&gt;\n&lt;p&gt;{{status}}&lt;/p&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.controller(&quot;myController&quot;,[&quot;$scope&quot;,function($scope){\n    $scope.status=false;\n    $scope.changeStatus=function(){\n        $scope.status=!$scope.status;\n    }\n}]);\n</code></pre><h2 id=\"ng-init\"><a href=\"#ng-init\" class=\"headerlink\" title=\"ng-init\"></a>ng-init</h2><p>HTML：</p>\n<pre><code>&lt;div ng-init=&quot;[firstName=&apos;张&apos;,lastName=&apos;三&apos;]&quot;&gt;\n    {{firstName+lastName}}\n&lt;/div&gt;\n</code></pre><p>这是页面就会输出<code>&quot;张三&quot;</code>。<code>ng-init</code>用于初始化变量，不过初始化变量一般不这么做。</p>\n<h2 id=\"ng-src\"><a href=\"#ng-src\" class=\"headerlink\" title=\"ng-src\"></a>ng-src</h2><p>HTML：</p>\n<pre><code>&lt;img ng-src={{imgUrl}} alt=&quot;图片&quot;&gt;\n</code></pre><p><code>ng-src</code>是用于解决 <code>src</code>属性用ng表达式bug的一个指令，如果地址中包含ng表达式，用<code>ng-src</code>比较好。</p>\n<h2 id=\"自定义指令\"><a href=\"#自定义指令\" class=\"headerlink\" title=\"自定义指令\"></a>自定义指令</h2><p>在angular内置的这些指令中肯定是不够用的，所以，angualr可以给我们自定义指令：</p>\n<p>HTML：</p>\n<pre><code>&lt;hello-world&gt;oldValue&lt;/hello-world&gt;\n&lt;div class=&quot;hello-world&quot;&gt;oldValue&lt;/div&gt;\n&lt;!-- directive:hello-world --&gt;\n&lt;div&gt;oldValue&lt;/div&gt;\n&lt;div hello-world&gt;oldValue&lt;/div&gt;\n</code></pre><p>JS：</p>\n<pre><code>myApp.directive(&quot;helloWorld&quot;,[function(){\n    return{\n        restrict: &apos;ECMA&apos;,\n        template:&quot;&lt;div&gt;newValue&lt;span ng-transclude&gt;&lt;/span&gt;&lt;/div&gt;&quot;,\n        replace:true,\n        transclude:true,\n        link:function(){\n            //在这里可以操作DOM、给元素绑定事件\n        }\n    }\n}]);\n</code></pre><p>js部分有个<code>restrict</code>这个是匹配模式，用于匹配不同的属指令创建方式。</p>\n<p>E代表匹配元素模式，也就是我们说的html标签<code>&lt;hello-world&gt;oldValue&lt;/hello-world&gt;</code>，当需要创建带有自己的模板的指令时，使用这种方法。</p>\n<p>C匹配class模式，就是上面的<code>&lt;div class=&quot;hello-world&quot;&gt;oldValue&lt;/div&gt;</code></p>\n<p>M代表匹配注释模式，就是上面的<code>&lt;!-- directive:hello-world --&gt; &lt;div&gt;oldValue&lt;/div&gt;</code>，这里需要注意的就是注释的开头和结尾要有个空格，不然angular是识别不出的。</p>\n<p>A代表属性模式，即<code>&lt;div hello-world&gt;oldValue&lt;/div&gt;</code>，当要为已有的HTML标签增加功能时，使用这种方法创建指令，这也是angular默认的匹配方式。</p>\n<p><code>template</code>是填充到标签里的内容</p>\n<p><code>template</code>里可以看到有个<code>ng-transclude</code>指令，这个指令是在下面的<code>replace</code>和<code>transclude</code>值为<code>true</code>时才有用。当<code>replace</code>为真时原来的<em>oldValue</em>会被替换成<code>template</code>里的内容，但是我们有时候希望保留<em>oldValue</em>，所以把<code>transclude</code>设为<code>true</code>，这个时候angular就知道要把<em>oldValue</em>保存下来。但是保留下来得有地方放，这个时候在<code>template</code>里面加个<code>ng-transclude</code>指令，就可以把<em>oldValue</em>放进去。</p>\n<p><code>template</code>可以换成<code>templateUrl</code>，后面接的是其他的html文件的地址。</p>\n<p><code>link</code>函数可以操作DOM、绑定事件、绑定作用域。</p>\n<p>最终代码执行完后会得到(以<code>&lt;hello-world&gt;oldValue&lt;/hello-world&gt;</code>的结果为例)：</p>\n<pre><code>&lt;div&gt;\n    newValue\n    &lt;span ng-transclude=&quot;&quot;&gt;&lt;/span&gt;\n    &lt;div&gt;oldValue&lt;/div&gt;\n&lt;/div&gt;\n</code></pre><h3 id=\"自定义指令的controller和controllAs\"><a href=\"#自定义指令的controller和controllAs\" class=\"headerlink\" title=\"自定义指令的controller和controllAs\"></a>自定义指令的controller和controllAs</h3><p>还是上面的代码，将JS部分改为：</p>\n<pre><code> var myApp = angular.module(&quot;myApp&quot;, []);\n myApp.directive(&quot;helloWorld&quot;, [function () {\n     return {\n         restrict: &apos;ECMA&apos;,\n         template: &quot;&lt;div&gt;newValue&lt;span ng-transclude&gt;&lt;/span&gt;&lt;/div&gt;&quot;,\n         replace: true,\n         transclude: true,\n         controller:function($scope){\n             console.log($scope);\n         },\n         link: function () {\n             //在这里可以操作DOM、给元素绑定事件\n         }\n     }\n}]);\nmyApp.controller(&apos;myController&apos;, [&apos;$scope&apos;, function ($scope) {\n    console.log($scope);\n}]);\n</code></pre><p>这样在控制台输出的两个<code>$scope</code>实际上是同一个<code>$scope</code>。上面那个<code>controller</code>写在那里，其他指令可以通过<code>require</code>属性获得这个<code>controller</code>里面的东西，实现多个指令通过依赖注入进行通信。</p>\n<h3 id=\"require\"><a href=\"#require\" class=\"headerlink\" title=\"require\"></a>require</h3><p><code>require</code>可以将其他指令传递给自己，有三个用法：</p>\n<pre><code>1. 通过驼峰法(directiveName)的命名指定了控制器应该带有哪一条指令，默认从同一个元素上的指令找\n2. ^directiveName，在父级查找\n3. ?directiveName，指令可选，找不到不要抛出异常\n</code></pre><p>现在，上面的代码改成了：</p>\n<pre><code> myApp.directive(&quot;helloWorld&quot;, [function () {\n return {\n     restrict: &apos;ECMA&apos;,\n     template: &quot;&lt;div&gt;newValue&lt;span ng-transclude&gt;&lt;/span&gt;&lt;btn&gt;&lt;/btn&gt;&lt;/div&gt;&quot;,\n     replace: true,\n     transclude: true,\n     controller:function($scope){\n         this.fun=function(){\n             alert(&quot;s&quot;);\n         }\n     },\n     controllerAs:&quot;test&quot;,\n     link: function (scope,element,attr,test) {\n         element.on(&quot;click&quot;,test.fun);\n     }\n }\n}]);\nmyApp.directive(&apos;btn&apos;, [function () {\n    return {\n        restrict: &apos;E&apos;,\n        require:&quot;^helloWorld&quot;,\n        replace:true,\n        template:&quot;&lt;button&gt;点我&lt;/button&gt;&quot;,\n        link: function (scope, element, attrs,test) {\n            element.on(&quot;click&quot;,test.fun);\n        }\n    };\n}]);\n</code></pre><p>点击按钮会发现弹出两次a。那是因为在<code>helloWorld</code>指令里的<code>link</code>函数调用了一次<code>this.fun</code>下面的<code>btn</code>也调用了一次。如果点击文字就只会弹出一次。</p>\n<p>这里的<code>require</code>用了<code>^</code>是因为<code>helloWorld</code>是<code>btn</code>的父级。</p>\n<h3 id=\"scope\"><a href=\"#scope\" class=\"headerlink\" title=\"scope\"></a>scope</h3><h4 id=\"scope-true\"><a href=\"#scope-true\" class=\"headerlink\" title=\"scope:true\"></a>scope:true</h4><p>在上面说了自定义指令里的<code>controller</code>和下面的<code>myController</code>是同一个控制器。但是当我在自定义指令里(<code>helloWorld</code>指令)加一句<code>scope:true</code>时，这两个控制器就有不同的作用域了：</p>\n<pre><code>myApp.directive(&quot;helloWorld&quot;, [function () {\n     return {\n         restrict: &apos;ECMA&apos;,\n         template: &quot;&lt;div&gt;newValue&lt;span ng-transclude&gt;&lt;/span&gt;&lt;btn&gt;&lt;/btn&gt;&lt;/div&gt;&quot;,\n         replace: true,\n         scope:true,\n         transclude: true,\n         controller:function($scope){\n             console.log($scope);\n             this.fun=function(){\n                 alert(&quot;s&quot;);\n             }\n         },\n         controllerAs:&quot;test&quot;\n     }\n}]);\n</code></pre><p>这时，控制台输出的两个<code>scope</code>，展开来看会发现它们的<em>id</em>不一样，<em>id</em>小的那个是<em>id</em>大的父作用域，子作用域可以继承父作用域里的属性，父作用域读不到子作用域里的属性。</p>\n<h4 id=\"scope-1\"><a href=\"#scope-1\" class=\"headerlink\" title=\"scope:{}\"></a>scope:{}</h4><p>当<code>scope:{}</code>会创建一个独立作用域，有父元素，但是继承不到父元素的属性。</p>\n<p>这个对象有三个参数：</p>\n<pre><code>1 .&amp;:把父作用域包装成一个函数，从而以函数的方式读写父作用域的属性\n2 .=:作用域的属性与父作用域的属性双向绑定\n3 .@：只能读取父作用域里的值\n</code></pre><p>HTML：</p>\n<pre><code>&lt;div ng-controller=&quot;myController&quot;&gt;\n    &lt;div hello-world a-data=&quot;data&quot; b-data=&quot;data&quot; data=&quot;{{data}}&quot;&gt;oldValue&lt;/div&gt;\n    {{data}}\n&lt;/div&gt;\n</code></pre><p>JS：</p>\n<pre><code> myApp.directive(&quot;helloWorld&quot;, [function () {\n     return {\n         restrict: &apos;ECMA&apos;,\n         template: &quot;&lt;div&gt;newValue&lt;span ng-transclude&gt;&lt;/span&gt;&lt;btn&gt;&lt;/btn&gt;&lt;/div&gt;&quot;,\n         replace: true,\n         scope:{\n             a:&quot;&amp;aData&quot;,\n             b:&quot;=bData&quot;,\n             data:&quot;@&quot;\n         },\n         transclude: true,\n         controller:function($scope){\n             console.log($scope.a());\n             console.log($scope.b);\n             console.log($scope.data);\n             this.fun=function(){\n                 $scope.$apply(function(){\n                    $scope.b=&quot;aaaa&quot;; \n                 });\n             }\n         },\n         controllerAs:&quot;test&quot;\n     }\n}]);\n</code></pre><p>在html中我加了三个属性分别为：<code>a-data</code>，<code>b-data</code>，<code>data</code>分别对应着JS中的<code>a</code>，<code>b</code>，<code>data</code>。第三个是简写形式，如果名字和属性名相同，则后面的名字可以不用写。</p>\n<p>当按下按钮会发现页面上的<em>data</em>变为<em>aaaa</em>这就说明<code>b</code>是双向绑定的</p>\n<p><strong>tips:</strong><code>@</code>不能读到对象；使用<code>@</code>时html标签里的属性值需要用双花括号括起来。</p>\n<p><strong>小补充：</strong><code>priority</code>是用来设置指令的权值，也就是指令执行的顺序。<code>terminal</code>设置是否以当前设置的<code>priority</code>为界限，如果小于设置的<code>priority</code>就不执行。</p>\n<p>就到这里，打完收工！</p>"},{"title":"几个让我印象深刻的面试题(二)","date":"2017-03-19T07:19:04.000Z","_content":"\n## 前言\n\n[原文地址](https://jayzangwill.github.io/blog/2017/03/19/Some%20of%20the%20interview%20questions%20that%20impressed%20me-2/)&&[我的博客](https://jayzangwill.github.io/blog/)\n[知乎](https://zhuanlan.zhihu.com/p/25863288)&&[知乎专栏](https://zhuanlan.zhihu.com/jayzangwill)\n[简书](http://link.zhihu.com/?target=http%3A//www.jianshu.com/p/65319f42a5ce)\n[河南前端交流群官网](http://henanjs.org/)\n\n上次写了一篇[几个让我印象深刻的面试题(一)](https://jayzangwill.github.io/blog/2017/03/01/Some%20of%20the%20interview%20questions%20that%20impressed%20me-1/)没看过的同学可以去看哦。\n这次文章的题目来源：[这里有超过20家的前端面试题，你确定不点进来看看？](https://juejin.im/post/58c51b5c44d90400698da686)。\n如果上面的问题在我这篇文章里没有提到的话，那就说明有些问题可以很容易查得到或者很简单或者我能力有限不能解答出来的。如果有的问题你不会而且我又没有提的那就认为就是我能力有限不能解答出来吧。嘿嘿嘿。开个玩笑，不过可以在下面留言哦！\n\n<!-- more-->\n\n## 正文\n\n还是老规矩先给题目，然后在看我的答案，有什么意见可以在留言板提。\n\n1. 请问a，b，c分别输出什么？\n\n```javascript\nfunction fun(n,o){\n    console.log(o)\n    return{\n      fun:function(m){\n         return fun(m,n);\n      }\n    };\n}\nvar a = fun(0); a.fun(1); a.fun(2); a.fun(3);\nvar b = fun(0).fun(1).fun(2).fun(3);\nvar c = fun(0).fun(1); c.fun(2); c.fun(3);\n```\n\n2. 用尽可能多的方法找出数组中重复出现过的元素\n\n例如：[1，2，4，4，3，3，1，5，3]\n\n输出：[1，3，4]\n\n3. 给定一些文档（docs）、词（words），找出词在文档中全部存在的所有文档\n\n```javascript\nvar docs = [{\n        id: 1,\n        words: ['hello',\"world\"]\n    },\n    {\n        id: 2,\n        words: ['hello',\"kids\"]\n    },\n    {\n        id: 3,\n        words: ['zzzz',\"hello\"]\n    },\n    {\n        id: 4,\n        words: ['world',\"kids\"]\n    }\n ];\nfindDocList(docs,['hello']) //文档1，文档2，文档3\nfindDocList(docs,['hello','world']) //文档1\n```\n\n4. 下面代码会输出什么？\n\n```javascript\nvar test = (function(a){\n    this.a = a;\n    return function(b){\n        return this.a + b;\n    }\n    }(function(a,b){\n        return a;\n    }(1,2)));\nconsole.log(test(1));\n```\n\n5. 不用循环，创建一个长度为 100 的数组，并且每个元素的值等于它的下标。\n6. 一个整数，它的各位数字如果是左右对称的，则这个数字是对称数。那么请找出 1 至 10000 中所有的对称数\n7. 以下代码输出结果是什么？\n```javascript\nvar myObject = {\n    foo: \"bar\",\n    func: function(){\n         var self = this;\n         console.log('outer func : this.foo' + this.foo);\n         console.log('outer func : self.foo' + self.foo);\n         (function(){\n             console.log('inner func : this.foo' + this.foo);\n             console.log('inner func : self.foo' + self.foo);\n         })();\n    }\n};\nmyObject.func();\n```\n8. 请写出以下正则表达式的详细规则说明\n/^(0[1-9]\\d\\d?)?[1-9]\\d{6}\\d?$/\n/^(1[89]|[2-9]\\d|100)$/i\n/^[\\w-]+@[a-z0-9-]+({[a-z]{2,6}}){1,2}$/i\n9. 请写出打乱数组方法\n10. 写出element.getElementsByClassName 的实现方法\n11. 请写出代码输出结果\n```javascript\nif(!(\"a\" in window)){\n    var a = 1;\n}\nalert(a);\n```\n12. 请写出代码输出结果\n```javascript\nvar handle = function(a){\n    var b = 3;\n    var tmp = function(a){\n        b = a + b;\n        return tmp;\n    }\n    tmp.toString = function(){\n        return b;\n    }\n    return tmp;\n}\nalert(handle(4)(5)(6));\n```\n\n13. javscript表达式\"[]==''\"的值是什么，为什么？\n14. Js生成下面html，点击每个li的时候弹出1,2,3......\n//li onclick事件都能弹出当前被点击的index=?\n```html\n<ul id=\"testUrl\">\n\t<li>index=0</li>\n\t<li>index=1</li>\n</ul>\n```\n15. map方法是ES5中新增的，要求为ES5以下的环境增加个map方法\n\n## 答案揭晓\n\n### 第一题\n\n```javascript\nfunction fun(n,o){\n   console.log(o)\n   return{\n       fun:function(m){\n           return fun(m,n);\n       }\n   };\n}\nvar a = fun(0); a.fun(1); a.fun(2); a.fun(3);\nvar b = fun(0).fun(1).fun(2).fun(3);\nvar c = fun(0).fun(1); c.fun(2); c.fun(3);\n```\n\n我们先来一步一步地看。首先是`a=fun(0)`因为只传了一个参数，`console`输出的是第二个参数的值，所以毫无疑问地输出`undefined`。\n\n然后到`a.fun(1)`可以看出，这句话是调用前面`fun(0)`返回回来的一个对象里面的函数`fun`，这个`fun`又把`fun(m,n)`返回出去。这个时候**请注意**：这个对象里的`fun`在返回之前调用了一下`fun(m,n)`，所以`console`又会被执行，可以确定，它肯定不会输出传进去的1，因为1作为第一个参数传到`fun(m,n)`里，而`console`是输出第二个参数的。那么这次会输出啥呢？\n\n好了，不给大家卖关子了，答案是0。可能有人会问了，纳尼？为毛是0，0是哪来的？\n\n要想看明白我的解释，前提是你得清楚闭包。这里用到了闭包。我们知道，闭包有个功能就是外部作用域能通过闭包访问函数内部的变量。其实在运行`a=fun(0)`的时候，`return`出来的对象里的函数`fun`把传进来的这个0作为第二个参数传到`fun`里面并返回出来这时0得到了保存。所以当运行`a.fun(1)`的时候其实输出的是之前的0。后面的那两个调用也和这个的原理一样，最后都是输出0。\n\n这里可能会有点绕，需要花点时间来看或者自行去调试。（我已经在尽力表达清楚了，如果还不懂的话就留言吧=.=）。\n\n然后到`b`，如果前面搞懂了这里就不难了。`fun(0)`运行的时候会`return`一个对象出去，后面的一串链式调用都是在调用前面函数返回的对象里的`fun`，最终导致输出是`undefined 0 1 2`\n\n最后到`c`，如果`b`都搞懂了，到这里基本就没什么难度了。分别会输出`undefined 0 1 1`。\n\n如果还不懂的话建议单步调试一下，如果还是不懂可以在下面留言，我会尽最大能力给你解释。\n\n### 第二题\n\n用尽可能多的方法找出数组中重复出现过的元素\n例如：[1，2，4，4，3，3，1，5，3]\n输出：[1，3，4]\n\n我的思路是，先创建一个数组。然后将传进来的数组进行排序。然后再利用`sort`方法遍历数组，因为它能一次取到两个数然后`a`和`b`比较如果相等而且`result`里面又没有重复的就把`a`推进去。\n\n这是我的代码：\n\n4.5日更新\n----\n感谢[@倔强的小瓶盖](https://www.zhihu.com/people/jue-qiang-de-xiao-ping-gai/answers)同学指出的问题\n\n```javascript\nfunction repeat(arr) {\n    var result = [];\n    arr.sort().reduce(function(a, b) {\n        if(a === b && result.indexOf(a) === -1) {\n            result.push(a);\n        }\n        return b;\n    });\n    return result;\n}\n```\n\n```javascript\n//之前问题代码\nfunction repeat(arr){\n    var result=[];\n    arr.sort().sort(function(a,b){\n        if(a===b&&result.indexOf(a)===-1){\n            result.push(a);\n        }\n    });\n    return result;\n}\n```\n\n3.23日更新\n----\n\n感谢[@start-wrap](https://www.zhihu.com/people/start-wrap/answers)同学提供的方法：\n```javascript\nfunction repeat(arr){\n\tvar result = [], map = {};\n\tarr.map(function(num){\n\tif(map[num] === 1) result.push(num);\n\t\tmap[num] = (map[num] || 0) + 1;\n\t}); \n\treturn result;\n}\n```\n\n值得一提的是`map[num] = (map[num] || 0) + 1`，这句代码的`(map[num] || 0)`如果`map[num]`存在，则`map[num]`+1反之则0+1，个人觉得用得很巧妙。\n\n感谢[@早乙女瑞穂](https://www.zhihu.com/people/jerrywdlee/answers)提供的淫技巧：\n```javascript\n// es6\nlet array = [1, 1, 2, 3, 3, 3, 4, 4, 5];\nArray.from(new Set(array.filter((x, i, self) => self.indexOf(x) !== i)));\n// es5\nvar array = [1, 2, 4, 4, 3, 3, 1, 5, 3];\narray.filter(function(x, i, self) {\n    return self.indexOf(x) === i && self.lastIndexOf(x) !== i \n});\n```\n\nes6思路解说：\n\narray.filter((x, i, self) => self.indexOf(x) !== i)\n返回一个数组，该数组由arrary中重复的元素构成(返回N-1次)\n\nnew Set( [iterable] )\n返回一个集合(重复元素在此被合并)\n\nArray.from( [iterable] )\n返回一个数组(将上一步的集合变为数组)\n\n//es5思路解说：\n\n使用`indexOf`和`lastIndexOf`正向判断和反向判断这个元素是不是同一个数(如果是同一个数，则两个方法返回的`i`是一样的)\n### 第三题\n\n给定一些文档（docs）、词（words），找出词在文档中全部存在的所有文档\n\n我的思路是：把第二个参数的数组用`join`合成一个字符串，然后用`forEach`遍历，分别把文档里的`words`也用`join`合成一个字符串，利用`search`方法找每个文档里的`words`是否包含有`arrStr`。\n\n这是我的代码：\n```javascript\nfunction findDocList(docs, arr) {\n    let arrStr = arr.join(\"\"),\n    itemStr,\n    result = [];\n    docs.forEach(function(item) {\n        itemStr = item.words.join(\"\");\n        if(itemStr.search(new RegExp(arrStr)) !== -1) {\n        result.push(\"文档\" + item.id);\n    }\n    });\n    console.log(result);\n}\nfindDocList(docs, ['hello']) //文档1，文档2，文档3\nfindDocList(docs, ['hello', 'world']) //文档1\n```\n\n### 第四题\n\n下面代码会输出什么？\n```javascript\nvar test = (function(a){\n\t\tthis.a = a;\n\t\treturn function(b){\n\t\treturn this.a + b;\n\t\t}\n}(function(a,b){\n\t\treturn a;\n}(1,2)));\nconsole.log(test(1));\n```\n\n可以看到，这里有两个自执行函数。下面这个自执行函数执行完后向上面这个自执行函数传了个1所以`this.a=1`，这里的`this`指向`window`。然后这个自执行函数返回个函数给`test`变量。下面调用`test(1)`，这个1传进来后相当于`return 1+1`所以就输出2。\n\n### 第五题\n\n不用循环，创建一个长度为 100 的数组，并且每个元素的值等于它的下标。\n\n如果了解[Object.keys](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)和[Array.form](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from)的话，这题基本上没啥难度。\n答案：\n```javascript\nObject.keys(Array.from({length:100}))\n```\n\n哎！等下`Array.form`不是es6的吗，es5的怎么实现？\n代码来了：\n\n\tObject.keys(Array.apply(null,{length:100}))\n\t\n如果还不懂可以参考[这里](https://www.zhihu.com/question/41493194)的讲解。\n\n### 第六题\n\n一个整数，它的各位数字如果是左右对称的，则这个数字是对称数。那么请找出 1 至 10000 中所有的对称数\n\n我的思路，先将数字转为字符串，然后利用数组的`map`方法遍历这个字符串，将字符串全部分开变为数组，然后调用数组的`reverse`方法，再将翻转后的数组`join`成字符串，最后对比翻转后的字符串和翻转前的字符串是否相等即可（方法有点愚笨，望大神指教）：\n```javascript\nfunction symmetric(){\n    var i=1,\n    str,\n    newStr,\n    result=[];\n    for(;i<1000;i++){\n        str=\"\"+i;\n        newStr=result.map.call(str,function(item){\n            return item;\n        }).reverse().join(\"\");\n        if(str===newStr){\n            result.push(+str);\n        }\n    }\n    return result;\n}\n```\n\n### 第七题\n\n以下代码输出什么？\n```javascript\nvar myObject = {\n    foo: \"bar\",\n    func: function(){\n    var self = this;\n    console.log('outer func : this.foo' + this.foo);\n    console.log('outer func : self.foo' + self.foo);\n    (function(){\n        console.log('inner func : this.foo' + this.foo);\n        console.log('inner func : self.foo' + self.foo);\n    })();\n    }\n};\nmyObject.func();\n```\n\n这题主要考察`this`指向，个人觉得难度不是太大，因为`this`已经被我完全承包啦(坏笑脸)。\n这题的话只需考虑谁调用的函数`this`就指向谁。\n函数开始执行`self=this`这里的`this`是指向`myObject`的，因为`myObject.func()`很明显是`myObject`在调用它嘛，所以头两句`console`输出的`foo`都是`bar`。\n下面是一个自执行函数，要知道，自执行函数的`this`一般情况下都指向`window`这里也不例外，所以，第三个`console`输出的`foo`是`undefined`因为在`window`下`foo`没定义。第四个输出的是`self.foo`这个`self`就是上面定义的`self`即`myObject`所以，这里的`foo`为`bar`。\n\n### 第八题\n\n请写出以下正则表达式的详细规则说明\n/^(0[1-9]\\d\\d?)?[1-9]\\d{6}\\d?$/\n/^(1[89]|[2-9]\\d|100)$/i\n/^[\\w-]+@[a-z0-9-]+({[a-z]{2,6}}){1,2}$/i\n\n嘿嘿，正则也算我比较拿手的部分。我来一个一个解释吧，有些正则比较难用语言表达，大家意会意会吧。\n\n第一个：首先`^`代表的是以它后面的一堆东西为开头`$`代表以它前面一堆东西为结尾，在这里的意思就是以`(0[1-9]\\d\\d?)?[1-9]\\d{6}\\d?`为开头和结尾的字符串。然后到第一个括号里的意思是匹配第一个字符串为0第二个字符串为1-9第三个字符串为0-9第四个字符串可有可无，有的话匹配1-9，然后这整个括号里面的内容可有可无。问好后面的意思是匹配第一个字符串是1-9然后后面6个字符串匹配0-9最后一个字符串可有可无，有的话匹配0-9。\n\n所以整理整理就是：匹配以0为第一个，1-9为第二个，数字为第三个；第四个可有可无，有的话匹配数字；然后前面这一整坨可有可无。1-9为第五个(如果前面那一坨没有的话，则从第一个算起)然后后面6个都是数字最后一个数字可有可无的字符串，且以它为开头和结尾。\n\n下面是例子：\n022222222222  //true \n002222222222 //false 因为第二个数字是1-9\n02222222222 //第一个括号最后一个数字**或**者最后面的数字省略\n0222222222 //第一个括号最后一个数字**和**者最后面的数字省略\n22222222  //第一个括号里的内容全部省略\n02222222 //\\d{6}没有满足。\n\n第二个：匹配以1作为第一个，8或9作为第二个**又或者**以2-9为第一个，数字为第二个又或者匹配100的字符串，并以他们为开头和结尾，忽略大小写。\n\n还是例子比较直观：\n\n18 //true 匹配前面的1[89]\n23 //true 匹配[2-9]\\d\n100 //true 匹配100\n17 //false\n230 //false\n\n第三个：\n匹配前面至少一个数字或字母或_或-再匹配@然后再匹配至少一个字母或数字或-然后到再匹配{字母2-6个}1-2个，的字符串，并以他们为开头和结尾忽略大小写。\n\n这个用语言描述太难了，是我不会说话吗，上例子吧：\n\n3@d{aw}{ad} //true\n-@-{ddd}{fs} //true\n3@3{dw}{ddd} //true\n3@3{dw} //false {字母2-6个}少了一个即`({[a-z]{2,6}}){1,2}`后面的`{1,2}`没满足\n@3{dw}{ddd} //false [\\w-]+没满足\n33{dw}{ddd} //false 没@\ndsa@ffff{dw}{d} //false ({[a-z]{2,6}})不符合\n\n### 第九题\n请写出打乱数组方法\n\n4.5日更新\n----\n[参考这里](https://www.h5jun.com/post/array-shuffle.html)\n\n```javascript\n// 之前的问题代码\nfunction randomsort(a, b) {\n    return Math.random()>.5 ? -1 : 1;\n    //用Math.random()函数生成0~1之间的随机数与0.5比较，返回-1或1\n}\nvar arr = [1, 2, 3, 4, 5];\narr.sort(randomsort);\n```\n\n### 第十题\n写出element.getElementsByClassName 的实现方法\n我的思路：先获取页面下的所有元素，然后用`split`将传进来的多个`class`分割成数组，然后利两层循环找出符合条件的元素（个人觉得这种方法效率实在低下，就当是抛砖引玉吧，欢迎留言）\n代码：\n```javascript\nif(!document.getElementsByClassName) {\n    document.getElementsByClassName = function(className) {\n    var ele = [],\n        tags = document.getElementsByTagName(\"*\");\n    className = className.split(/\\s+/);\n    for(var i = 0; i < tags.length; i++) {\n        for(var j = 0; j < className.length; j++) {\n        //如果这个元素上有这个class且没在ele里面(主要防止多个class加在一个元素上推进去两次的情况)\n            if(tags[i].className === className[j] && ele.indexOf(tags[i]) === -1) {\n                ele.push(tags[i]);\n            }\n        }\n    }\n    return ele;\n    }\n}\n```\n### 第十一题\n请写出代码输出结果\n```javascript\n  if(!(\"a\" in window)){\n      var a = 1;\n  }\n  alert(a);\n```\n\n这题主要考察了变量的声明提升，任何变量(es5中)的声明都会提升到当前作用域的顶端。所以这里的代码其实为：\n```javascript\n  var a;\n  if(!(\"a\" in window)){\n      a = 1;\n  }\n  alert(a);\n```\n所以，在if语句执行前`a`就已经在`window`中了，所以这里会`atert undefined`\n\n### 第十二题\n请写出代码输出结果\n```javascript\nvar handle = function(a){\n    var b = 3;\n    var tmp = function(a){\n        b = a + b;\n        return tmp;\n    }\n    tmp.toString = function(){\n        return b;\n    }\n    return tmp;\n}\nalert(handle(4)(5)(6));\n```\n\n我们来一步一步看：首先是`handle(4)`，到这里，程序开始运行，创建了一个`tmp`函数，同时把`tmp`函数的`toString`方法重写了，最后返回这个`tmp`函数。\n**注意**：`tmp`里的`a`不是传进去的4，不要把`tmp`的`a`和`handle`的`a`搞混了，所以这里传的4啥也没干。\n\n然后到第二步：`handle(4)(5)`，这里就是执行了`tmp`函数，这个时候`tmp`函数的`a`就是传进来的5，·`b`就是第一步函数执行的`b`即3(不懂为何是3的同学再去了解了解闭包吧)，最后这个`b`就等于8。\n\n第三部重复第二步`8+6`，最后`b`为14，`javascript`引擎最后自动调用了`toString`返回`b`，所以结果是14。\n\n### 第十三题\njavscript表达式\"[]==''\"的值是什么，为什么？\n\n这题考察对js`==`运算符的了解，我们知道`==`运算符如果两边值类型不一样会把它们转换为相同类型的值再来比较。这题左边是`object`类型，右边是`string`类型，所以会把左边的转化为`string`类型来比较，`[].toString()`就是`''`所以最后结果是`true`。\n\n### 第十四题\nJs生成下面html，点击每个li的时候弹出1,2,3......\n//li onclick事件都能弹出当前被点击的index=?\n```html\n<ul id=\"testUrl\">\n    <li>index=0</li>\n    <li>index=1</li>\n</ul>\n```\n\n这题直接按照要求生成对应的html，再给`ul`绑定个事件，利用事件代理监听是谁被点了，然后输出它们的序号和对应的内容，没啥难度。我的代码：\n```javascript\nvar ul=document.createElement(\"ul\"),\n    lis=[];\n    ul.id=\"testUrl\";\nfor(var i=0,li;i<2;i++){\n    li=document.createElement(\"li\");\n    li.innerHTML=\"index=\"+i;\n    ul.appendChild(li);\n    lis.push(li);\n}\nul.addEventListener(\"click\",function(e){\n    alert(lis.indexOf(e.target));\n    alert(e.target.innerHTML)\n});\ndocument.body.appendChild(ul);\n```\n### 第十五题\nmap方法是ES5中新增的，要求为ES5以下的环境增加个map方法\n\n个人认为只要对[map](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Compatibility)方法够了解，自然就能封装出来了。嘿嘿，不喜勿喷。给的链接虽然也有一个实现`map`的方法，但是用到了es5的`for in`不符合题目，所以我的代码：\n```javascript\nif(!Array.prototype.map){\n    Array.prototype.map=function(callback,context){\n    var len=this.length,\n        i=0,\n        result=[];\n    if (typeof callback !== \"function\") {\n        throw new TypeError(callback + \" is not a function\");\n    }\n    context=context||window;\n    for(;i<len;i++){\n        this[i]!==undefined?result.push(callback.call(context,this[i],i,this)):result.push(this[i]);\n    }\n    return result;\n    }\n}\n```\n不过我的代码和标准的输出结果还是有点出入的。就是我不处理`undefined`和`null`，因为`this[i]!==undefined`，这两个值是会原样返回的。不过日常的一些需求还是能满足的。欢迎大家提建议哈。\n\n终于打完了，这期就这么多题，希望能对大家有帮助，同时如果有不对的地方请及时指正，欢迎留言。\n\n另外，欢迎大家来围观我封装的一个[ajax库 lightings](https://github.com/JayZangwill/lightings)。\n\n## 参考\n[JS随机打乱数组的方法小结](http://www.jb51.net/article/87094.htm)\n[如何不使用loop循环，创建一个长度为100的数组，并且每个元素的值等于它的下标](https://www.zhihu.com/question/41493194)\n[MDN map](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Compatibility)","source":"_posts/Some of the interview questions that impressed me-2.md","raw":"---\ntitle: 几个让我印象深刻的面试题(二)\ndate: 2017-03-19 15:19:04\ntags: [面试,基础,javascript]\n---\n\n## 前言\n\n[原文地址](https://jayzangwill.github.io/blog/2017/03/19/Some%20of%20the%20interview%20questions%20that%20impressed%20me-2/)&&[我的博客](https://jayzangwill.github.io/blog/)\n[知乎](https://zhuanlan.zhihu.com/p/25863288)&&[知乎专栏](https://zhuanlan.zhihu.com/jayzangwill)\n[简书](http://link.zhihu.com/?target=http%3A//www.jianshu.com/p/65319f42a5ce)\n[河南前端交流群官网](http://henanjs.org/)\n\n上次写了一篇[几个让我印象深刻的面试题(一)](https://jayzangwill.github.io/blog/2017/03/01/Some%20of%20the%20interview%20questions%20that%20impressed%20me-1/)没看过的同学可以去看哦。\n这次文章的题目来源：[这里有超过20家的前端面试题，你确定不点进来看看？](https://juejin.im/post/58c51b5c44d90400698da686)。\n如果上面的问题在我这篇文章里没有提到的话，那就说明有些问题可以很容易查得到或者很简单或者我能力有限不能解答出来的。如果有的问题你不会而且我又没有提的那就认为就是我能力有限不能解答出来吧。嘿嘿嘿。开个玩笑，不过可以在下面留言哦！\n\n<!-- more-->\n\n## 正文\n\n还是老规矩先给题目，然后在看我的答案，有什么意见可以在留言板提。\n\n1. 请问a，b，c分别输出什么？\n\n```javascript\nfunction fun(n,o){\n    console.log(o)\n    return{\n      fun:function(m){\n         return fun(m,n);\n      }\n    };\n}\nvar a = fun(0); a.fun(1); a.fun(2); a.fun(3);\nvar b = fun(0).fun(1).fun(2).fun(3);\nvar c = fun(0).fun(1); c.fun(2); c.fun(3);\n```\n\n2. 用尽可能多的方法找出数组中重复出现过的元素\n\n例如：[1，2，4，4，3，3，1，5，3]\n\n输出：[1，3，4]\n\n3. 给定一些文档（docs）、词（words），找出词在文档中全部存在的所有文档\n\n```javascript\nvar docs = [{\n        id: 1,\n        words: ['hello',\"world\"]\n    },\n    {\n        id: 2,\n        words: ['hello',\"kids\"]\n    },\n    {\n        id: 3,\n        words: ['zzzz',\"hello\"]\n    },\n    {\n        id: 4,\n        words: ['world',\"kids\"]\n    }\n ];\nfindDocList(docs,['hello']) //文档1，文档2，文档3\nfindDocList(docs,['hello','world']) //文档1\n```\n\n4. 下面代码会输出什么？\n\n```javascript\nvar test = (function(a){\n    this.a = a;\n    return function(b){\n        return this.a + b;\n    }\n    }(function(a,b){\n        return a;\n    }(1,2)));\nconsole.log(test(1));\n```\n\n5. 不用循环，创建一个长度为 100 的数组，并且每个元素的值等于它的下标。\n6. 一个整数，它的各位数字如果是左右对称的，则这个数字是对称数。那么请找出 1 至 10000 中所有的对称数\n7. 以下代码输出结果是什么？\n```javascript\nvar myObject = {\n    foo: \"bar\",\n    func: function(){\n         var self = this;\n         console.log('outer func : this.foo' + this.foo);\n         console.log('outer func : self.foo' + self.foo);\n         (function(){\n             console.log('inner func : this.foo' + this.foo);\n             console.log('inner func : self.foo' + self.foo);\n         })();\n    }\n};\nmyObject.func();\n```\n8. 请写出以下正则表达式的详细规则说明\n/^(0[1-9]\\d\\d?)?[1-9]\\d{6}\\d?$/\n/^(1[89]|[2-9]\\d|100)$/i\n/^[\\w-]+@[a-z0-9-]+({[a-z]{2,6}}){1,2}$/i\n9. 请写出打乱数组方法\n10. 写出element.getElementsByClassName 的实现方法\n11. 请写出代码输出结果\n```javascript\nif(!(\"a\" in window)){\n    var a = 1;\n}\nalert(a);\n```\n12. 请写出代码输出结果\n```javascript\nvar handle = function(a){\n    var b = 3;\n    var tmp = function(a){\n        b = a + b;\n        return tmp;\n    }\n    tmp.toString = function(){\n        return b;\n    }\n    return tmp;\n}\nalert(handle(4)(5)(6));\n```\n\n13. javscript表达式\"[]==''\"的值是什么，为什么？\n14. Js生成下面html，点击每个li的时候弹出1,2,3......\n//li onclick事件都能弹出当前被点击的index=?\n```html\n<ul id=\"testUrl\">\n\t<li>index=0</li>\n\t<li>index=1</li>\n</ul>\n```\n15. map方法是ES5中新增的，要求为ES5以下的环境增加个map方法\n\n## 答案揭晓\n\n### 第一题\n\n```javascript\nfunction fun(n,o){\n   console.log(o)\n   return{\n       fun:function(m){\n           return fun(m,n);\n       }\n   };\n}\nvar a = fun(0); a.fun(1); a.fun(2); a.fun(3);\nvar b = fun(0).fun(1).fun(2).fun(3);\nvar c = fun(0).fun(1); c.fun(2); c.fun(3);\n```\n\n我们先来一步一步地看。首先是`a=fun(0)`因为只传了一个参数，`console`输出的是第二个参数的值，所以毫无疑问地输出`undefined`。\n\n然后到`a.fun(1)`可以看出，这句话是调用前面`fun(0)`返回回来的一个对象里面的函数`fun`，这个`fun`又把`fun(m,n)`返回出去。这个时候**请注意**：这个对象里的`fun`在返回之前调用了一下`fun(m,n)`，所以`console`又会被执行，可以确定，它肯定不会输出传进去的1，因为1作为第一个参数传到`fun(m,n)`里，而`console`是输出第二个参数的。那么这次会输出啥呢？\n\n好了，不给大家卖关子了，答案是0。可能有人会问了，纳尼？为毛是0，0是哪来的？\n\n要想看明白我的解释，前提是你得清楚闭包。这里用到了闭包。我们知道，闭包有个功能就是外部作用域能通过闭包访问函数内部的变量。其实在运行`a=fun(0)`的时候，`return`出来的对象里的函数`fun`把传进来的这个0作为第二个参数传到`fun`里面并返回出来这时0得到了保存。所以当运行`a.fun(1)`的时候其实输出的是之前的0。后面的那两个调用也和这个的原理一样，最后都是输出0。\n\n这里可能会有点绕，需要花点时间来看或者自行去调试。（我已经在尽力表达清楚了，如果还不懂的话就留言吧=.=）。\n\n然后到`b`，如果前面搞懂了这里就不难了。`fun(0)`运行的时候会`return`一个对象出去，后面的一串链式调用都是在调用前面函数返回的对象里的`fun`，最终导致输出是`undefined 0 1 2`\n\n最后到`c`，如果`b`都搞懂了，到这里基本就没什么难度了。分别会输出`undefined 0 1 1`。\n\n如果还不懂的话建议单步调试一下，如果还是不懂可以在下面留言，我会尽最大能力给你解释。\n\n### 第二题\n\n用尽可能多的方法找出数组中重复出现过的元素\n例如：[1，2，4，4，3，3，1，5，3]\n输出：[1，3，4]\n\n我的思路是，先创建一个数组。然后将传进来的数组进行排序。然后再利用`sort`方法遍历数组，因为它能一次取到两个数然后`a`和`b`比较如果相等而且`result`里面又没有重复的就把`a`推进去。\n\n这是我的代码：\n\n4.5日更新\n----\n感谢[@倔强的小瓶盖](https://www.zhihu.com/people/jue-qiang-de-xiao-ping-gai/answers)同学指出的问题\n\n```javascript\nfunction repeat(arr) {\n    var result = [];\n    arr.sort().reduce(function(a, b) {\n        if(a === b && result.indexOf(a) === -1) {\n            result.push(a);\n        }\n        return b;\n    });\n    return result;\n}\n```\n\n```javascript\n//之前问题代码\nfunction repeat(arr){\n    var result=[];\n    arr.sort().sort(function(a,b){\n        if(a===b&&result.indexOf(a)===-1){\n            result.push(a);\n        }\n    });\n    return result;\n}\n```\n\n3.23日更新\n----\n\n感谢[@start-wrap](https://www.zhihu.com/people/start-wrap/answers)同学提供的方法：\n```javascript\nfunction repeat(arr){\n\tvar result = [], map = {};\n\tarr.map(function(num){\n\tif(map[num] === 1) result.push(num);\n\t\tmap[num] = (map[num] || 0) + 1;\n\t}); \n\treturn result;\n}\n```\n\n值得一提的是`map[num] = (map[num] || 0) + 1`，这句代码的`(map[num] || 0)`如果`map[num]`存在，则`map[num]`+1反之则0+1，个人觉得用得很巧妙。\n\n感谢[@早乙女瑞穂](https://www.zhihu.com/people/jerrywdlee/answers)提供的淫技巧：\n```javascript\n// es6\nlet array = [1, 1, 2, 3, 3, 3, 4, 4, 5];\nArray.from(new Set(array.filter((x, i, self) => self.indexOf(x) !== i)));\n// es5\nvar array = [1, 2, 4, 4, 3, 3, 1, 5, 3];\narray.filter(function(x, i, self) {\n    return self.indexOf(x) === i && self.lastIndexOf(x) !== i \n});\n```\n\nes6思路解说：\n\narray.filter((x, i, self) => self.indexOf(x) !== i)\n返回一个数组，该数组由arrary中重复的元素构成(返回N-1次)\n\nnew Set( [iterable] )\n返回一个集合(重复元素在此被合并)\n\nArray.from( [iterable] )\n返回一个数组(将上一步的集合变为数组)\n\n//es5思路解说：\n\n使用`indexOf`和`lastIndexOf`正向判断和反向判断这个元素是不是同一个数(如果是同一个数，则两个方法返回的`i`是一样的)\n### 第三题\n\n给定一些文档（docs）、词（words），找出词在文档中全部存在的所有文档\n\n我的思路是：把第二个参数的数组用`join`合成一个字符串，然后用`forEach`遍历，分别把文档里的`words`也用`join`合成一个字符串，利用`search`方法找每个文档里的`words`是否包含有`arrStr`。\n\n这是我的代码：\n```javascript\nfunction findDocList(docs, arr) {\n    let arrStr = arr.join(\"\"),\n    itemStr,\n    result = [];\n    docs.forEach(function(item) {\n        itemStr = item.words.join(\"\");\n        if(itemStr.search(new RegExp(arrStr)) !== -1) {\n        result.push(\"文档\" + item.id);\n    }\n    });\n    console.log(result);\n}\nfindDocList(docs, ['hello']) //文档1，文档2，文档3\nfindDocList(docs, ['hello', 'world']) //文档1\n```\n\n### 第四题\n\n下面代码会输出什么？\n```javascript\nvar test = (function(a){\n\t\tthis.a = a;\n\t\treturn function(b){\n\t\treturn this.a + b;\n\t\t}\n}(function(a,b){\n\t\treturn a;\n}(1,2)));\nconsole.log(test(1));\n```\n\n可以看到，这里有两个自执行函数。下面这个自执行函数执行完后向上面这个自执行函数传了个1所以`this.a=1`，这里的`this`指向`window`。然后这个自执行函数返回个函数给`test`变量。下面调用`test(1)`，这个1传进来后相当于`return 1+1`所以就输出2。\n\n### 第五题\n\n不用循环，创建一个长度为 100 的数组，并且每个元素的值等于它的下标。\n\n如果了解[Object.keys](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)和[Array.form](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from)的话，这题基本上没啥难度。\n答案：\n```javascript\nObject.keys(Array.from({length:100}))\n```\n\n哎！等下`Array.form`不是es6的吗，es5的怎么实现？\n代码来了：\n\n\tObject.keys(Array.apply(null,{length:100}))\n\t\n如果还不懂可以参考[这里](https://www.zhihu.com/question/41493194)的讲解。\n\n### 第六题\n\n一个整数，它的各位数字如果是左右对称的，则这个数字是对称数。那么请找出 1 至 10000 中所有的对称数\n\n我的思路，先将数字转为字符串，然后利用数组的`map`方法遍历这个字符串，将字符串全部分开变为数组，然后调用数组的`reverse`方法，再将翻转后的数组`join`成字符串，最后对比翻转后的字符串和翻转前的字符串是否相等即可（方法有点愚笨，望大神指教）：\n```javascript\nfunction symmetric(){\n    var i=1,\n    str,\n    newStr,\n    result=[];\n    for(;i<1000;i++){\n        str=\"\"+i;\n        newStr=result.map.call(str,function(item){\n            return item;\n        }).reverse().join(\"\");\n        if(str===newStr){\n            result.push(+str);\n        }\n    }\n    return result;\n}\n```\n\n### 第七题\n\n以下代码输出什么？\n```javascript\nvar myObject = {\n    foo: \"bar\",\n    func: function(){\n    var self = this;\n    console.log('outer func : this.foo' + this.foo);\n    console.log('outer func : self.foo' + self.foo);\n    (function(){\n        console.log('inner func : this.foo' + this.foo);\n        console.log('inner func : self.foo' + self.foo);\n    })();\n    }\n};\nmyObject.func();\n```\n\n这题主要考察`this`指向，个人觉得难度不是太大，因为`this`已经被我完全承包啦(坏笑脸)。\n这题的话只需考虑谁调用的函数`this`就指向谁。\n函数开始执行`self=this`这里的`this`是指向`myObject`的，因为`myObject.func()`很明显是`myObject`在调用它嘛，所以头两句`console`输出的`foo`都是`bar`。\n下面是一个自执行函数，要知道，自执行函数的`this`一般情况下都指向`window`这里也不例外，所以，第三个`console`输出的`foo`是`undefined`因为在`window`下`foo`没定义。第四个输出的是`self.foo`这个`self`就是上面定义的`self`即`myObject`所以，这里的`foo`为`bar`。\n\n### 第八题\n\n请写出以下正则表达式的详细规则说明\n/^(0[1-9]\\d\\d?)?[1-9]\\d{6}\\d?$/\n/^(1[89]|[2-9]\\d|100)$/i\n/^[\\w-]+@[a-z0-9-]+({[a-z]{2,6}}){1,2}$/i\n\n嘿嘿，正则也算我比较拿手的部分。我来一个一个解释吧，有些正则比较难用语言表达，大家意会意会吧。\n\n第一个：首先`^`代表的是以它后面的一堆东西为开头`$`代表以它前面一堆东西为结尾，在这里的意思就是以`(0[1-9]\\d\\d?)?[1-9]\\d{6}\\d?`为开头和结尾的字符串。然后到第一个括号里的意思是匹配第一个字符串为0第二个字符串为1-9第三个字符串为0-9第四个字符串可有可无，有的话匹配1-9，然后这整个括号里面的内容可有可无。问好后面的意思是匹配第一个字符串是1-9然后后面6个字符串匹配0-9最后一个字符串可有可无，有的话匹配0-9。\n\n所以整理整理就是：匹配以0为第一个，1-9为第二个，数字为第三个；第四个可有可无，有的话匹配数字；然后前面这一整坨可有可无。1-9为第五个(如果前面那一坨没有的话，则从第一个算起)然后后面6个都是数字最后一个数字可有可无的字符串，且以它为开头和结尾。\n\n下面是例子：\n022222222222  //true \n002222222222 //false 因为第二个数字是1-9\n02222222222 //第一个括号最后一个数字**或**者最后面的数字省略\n0222222222 //第一个括号最后一个数字**和**者最后面的数字省略\n22222222  //第一个括号里的内容全部省略\n02222222 //\\d{6}没有满足。\n\n第二个：匹配以1作为第一个，8或9作为第二个**又或者**以2-9为第一个，数字为第二个又或者匹配100的字符串，并以他们为开头和结尾，忽略大小写。\n\n还是例子比较直观：\n\n18 //true 匹配前面的1[89]\n23 //true 匹配[2-9]\\d\n100 //true 匹配100\n17 //false\n230 //false\n\n第三个：\n匹配前面至少一个数字或字母或_或-再匹配@然后再匹配至少一个字母或数字或-然后到再匹配{字母2-6个}1-2个，的字符串，并以他们为开头和结尾忽略大小写。\n\n这个用语言描述太难了，是我不会说话吗，上例子吧：\n\n3@d{aw}{ad} //true\n-@-{ddd}{fs} //true\n3@3{dw}{ddd} //true\n3@3{dw} //false {字母2-6个}少了一个即`({[a-z]{2,6}}){1,2}`后面的`{1,2}`没满足\n@3{dw}{ddd} //false [\\w-]+没满足\n33{dw}{ddd} //false 没@\ndsa@ffff{dw}{d} //false ({[a-z]{2,6}})不符合\n\n### 第九题\n请写出打乱数组方法\n\n4.5日更新\n----\n[参考这里](https://www.h5jun.com/post/array-shuffle.html)\n\n```javascript\n// 之前的问题代码\nfunction randomsort(a, b) {\n    return Math.random()>.5 ? -1 : 1;\n    //用Math.random()函数生成0~1之间的随机数与0.5比较，返回-1或1\n}\nvar arr = [1, 2, 3, 4, 5];\narr.sort(randomsort);\n```\n\n### 第十题\n写出element.getElementsByClassName 的实现方法\n我的思路：先获取页面下的所有元素，然后用`split`将传进来的多个`class`分割成数组，然后利两层循环找出符合条件的元素（个人觉得这种方法效率实在低下，就当是抛砖引玉吧，欢迎留言）\n代码：\n```javascript\nif(!document.getElementsByClassName) {\n    document.getElementsByClassName = function(className) {\n    var ele = [],\n        tags = document.getElementsByTagName(\"*\");\n    className = className.split(/\\s+/);\n    for(var i = 0; i < tags.length; i++) {\n        for(var j = 0; j < className.length; j++) {\n        //如果这个元素上有这个class且没在ele里面(主要防止多个class加在一个元素上推进去两次的情况)\n            if(tags[i].className === className[j] && ele.indexOf(tags[i]) === -1) {\n                ele.push(tags[i]);\n            }\n        }\n    }\n    return ele;\n    }\n}\n```\n### 第十一题\n请写出代码输出结果\n```javascript\n  if(!(\"a\" in window)){\n      var a = 1;\n  }\n  alert(a);\n```\n\n这题主要考察了变量的声明提升，任何变量(es5中)的声明都会提升到当前作用域的顶端。所以这里的代码其实为：\n```javascript\n  var a;\n  if(!(\"a\" in window)){\n      a = 1;\n  }\n  alert(a);\n```\n所以，在if语句执行前`a`就已经在`window`中了，所以这里会`atert undefined`\n\n### 第十二题\n请写出代码输出结果\n```javascript\nvar handle = function(a){\n    var b = 3;\n    var tmp = function(a){\n        b = a + b;\n        return tmp;\n    }\n    tmp.toString = function(){\n        return b;\n    }\n    return tmp;\n}\nalert(handle(4)(5)(6));\n```\n\n我们来一步一步看：首先是`handle(4)`，到这里，程序开始运行，创建了一个`tmp`函数，同时把`tmp`函数的`toString`方法重写了，最后返回这个`tmp`函数。\n**注意**：`tmp`里的`a`不是传进去的4，不要把`tmp`的`a`和`handle`的`a`搞混了，所以这里传的4啥也没干。\n\n然后到第二步：`handle(4)(5)`，这里就是执行了`tmp`函数，这个时候`tmp`函数的`a`就是传进来的5，·`b`就是第一步函数执行的`b`即3(不懂为何是3的同学再去了解了解闭包吧)，最后这个`b`就等于8。\n\n第三部重复第二步`8+6`，最后`b`为14，`javascript`引擎最后自动调用了`toString`返回`b`，所以结果是14。\n\n### 第十三题\njavscript表达式\"[]==''\"的值是什么，为什么？\n\n这题考察对js`==`运算符的了解，我们知道`==`运算符如果两边值类型不一样会把它们转换为相同类型的值再来比较。这题左边是`object`类型，右边是`string`类型，所以会把左边的转化为`string`类型来比较，`[].toString()`就是`''`所以最后结果是`true`。\n\n### 第十四题\nJs生成下面html，点击每个li的时候弹出1,2,3......\n//li onclick事件都能弹出当前被点击的index=?\n```html\n<ul id=\"testUrl\">\n    <li>index=0</li>\n    <li>index=1</li>\n</ul>\n```\n\n这题直接按照要求生成对应的html，再给`ul`绑定个事件，利用事件代理监听是谁被点了，然后输出它们的序号和对应的内容，没啥难度。我的代码：\n```javascript\nvar ul=document.createElement(\"ul\"),\n    lis=[];\n    ul.id=\"testUrl\";\nfor(var i=0,li;i<2;i++){\n    li=document.createElement(\"li\");\n    li.innerHTML=\"index=\"+i;\n    ul.appendChild(li);\n    lis.push(li);\n}\nul.addEventListener(\"click\",function(e){\n    alert(lis.indexOf(e.target));\n    alert(e.target.innerHTML)\n});\ndocument.body.appendChild(ul);\n```\n### 第十五题\nmap方法是ES5中新增的，要求为ES5以下的环境增加个map方法\n\n个人认为只要对[map](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Compatibility)方法够了解，自然就能封装出来了。嘿嘿，不喜勿喷。给的链接虽然也有一个实现`map`的方法，但是用到了es5的`for in`不符合题目，所以我的代码：\n```javascript\nif(!Array.prototype.map){\n    Array.prototype.map=function(callback,context){\n    var len=this.length,\n        i=0,\n        result=[];\n    if (typeof callback !== \"function\") {\n        throw new TypeError(callback + \" is not a function\");\n    }\n    context=context||window;\n    for(;i<len;i++){\n        this[i]!==undefined?result.push(callback.call(context,this[i],i,this)):result.push(this[i]);\n    }\n    return result;\n    }\n}\n```\n不过我的代码和标准的输出结果还是有点出入的。就是我不处理`undefined`和`null`，因为`this[i]!==undefined`，这两个值是会原样返回的。不过日常的一些需求还是能满足的。欢迎大家提建议哈。\n\n终于打完了，这期就这么多题，希望能对大家有帮助，同时如果有不对的地方请及时指正，欢迎留言。\n\n另外，欢迎大家来围观我封装的一个[ajax库 lightings](https://github.com/JayZangwill/lightings)。\n\n## 参考\n[JS随机打乱数组的方法小结](http://www.jb51.net/article/87094.htm)\n[如何不使用loop循环，创建一个长度为100的数组，并且每个元素的值等于它的下标](https://www.zhihu.com/question/41493194)\n[MDN map](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Compatibility)","slug":"Some of the interview questions that impressed me-2","published":1,"updated":"2020-04-07T03:29:17.932Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8qzc34m000g2cl63z7ox97l","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><a href=\"https://jayzangwill.github.io/blog/2017/03/19/Some%20of%20the%20interview%20questions%20that%20impressed%20me-2/\">原文地址</a>&amp;&amp;<a href=\"https://jayzangwill.github.io/blog/\">我的博客</a><br><a href=\"https://zhuanlan.zhihu.com/p/25863288\" target=\"_blank\" rel=\"noopener\">知乎</a>&amp;&amp;<a href=\"https://zhuanlan.zhihu.com/jayzangwill\" target=\"_blank\" rel=\"noopener\">知乎专栏</a><br><a href=\"http://link.zhihu.com/?target=http%3A//www.jianshu.com/p/65319f42a5ce\" target=\"_blank\" rel=\"noopener\">简书</a><br><a href=\"http://henanjs.org/\" target=\"_blank\" rel=\"noopener\">河南前端交流群官网</a></p>\n<p>上次写了一篇<a href=\"https://jayzangwill.github.io/blog/2017/03/01/Some%20of%20the%20interview%20questions%20that%20impressed%20me-1/\">几个让我印象深刻的面试题(一)</a>没看过的同学可以去看哦。<br>这次文章的题目来源：<a href=\"https://juejin.im/post/58c51b5c44d90400698da686\" target=\"_blank\" rel=\"noopener\">这里有超过20家的前端面试题，你确定不点进来看看？</a>。<br>如果上面的问题在我这篇文章里没有提到的话，那就说明有些问题可以很容易查得到或者很简单或者我能力有限不能解答出来的。如果有的问题你不会而且我又没有提的那就认为就是我能力有限不能解答出来吧。嘿嘿嘿。开个玩笑，不过可以在下面留言哦！</p>\n<a id=\"more\"></a>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>还是老规矩先给题目，然后在看我的答案，有什么意见可以在留言板提。</p>\n<ol>\n<li>请问a，b，c分别输出什么？</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\">n,o</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(o)</span><br><span class=\"line\">    <span class=\"keyword\">return</span>&#123;</span><br><span class=\"line\">      fun:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m</span>)</span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> fun(m,n);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = fun(<span class=\"number\">0</span>); a.fun(<span class=\"number\">1</span>); a.fun(<span class=\"number\">2</span>); a.fun(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = fun(<span class=\"number\">0</span>).fun(<span class=\"number\">1</span>).fun(<span class=\"number\">2</span>).fun(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = fun(<span class=\"number\">0</span>).fun(<span class=\"number\">1</span>); c.fun(<span class=\"number\">2</span>); c.fun(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>用尽可能多的方法找出数组中重复出现过的元素</li>\n</ol>\n<p>例如：[1，2，4，4，3，3，1，5，3]</p>\n<p>输出：[1，3，4]</p>\n<ol start=\"3\">\n<li>给定一些文档（docs）、词（words），找出词在文档中全部存在的所有文档</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> docs = [&#123;</span><br><span class=\"line\">        id: <span class=\"number\">1</span>,</span><br><span class=\"line\">        words: [<span class=\"string\">'hello'</span>,<span class=\"string\">\"world\"</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        id: <span class=\"number\">2</span>,</span><br><span class=\"line\">        words: [<span class=\"string\">'hello'</span>,<span class=\"string\">\"kids\"</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        id: <span class=\"number\">3</span>,</span><br><span class=\"line\">        words: [<span class=\"string\">'zzzz'</span>,<span class=\"string\">\"hello\"</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        id: <span class=\"number\">4</span>,</span><br><span class=\"line\">        words: [<span class=\"string\">'world'</span>,<span class=\"string\">\"kids\"</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> ];</span><br><span class=\"line\">findDocList(docs,[<span class=\"string\">'hello'</span>]) <span class=\"comment\">//文档1，文档2，文档3</span></span><br><span class=\"line\">findDocList(docs,[<span class=\"string\">'hello'</span>,<span class=\"string\">'world'</span>]) <span class=\"comment\">//文档1</span></span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>下面代码会输出什么？</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;(<span class=\"number\">1</span>,<span class=\"number\">2</span>)));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test(<span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>不用循环，创建一个长度为 100 的数组，并且每个元素的值等于它的下标。</li>\n<li>一个整数，它的各位数字如果是左右对称的，则这个数字是对称数。那么请找出 1 至 10000 中所有的对称数</li>\n<li><p>以下代码输出结果是什么？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">    foo: <span class=\"string\">\"bar\"</span>,</span><br><span class=\"line\">    func: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log(<span class=\"string\">'outer func : this.foo'</span> + <span class=\"keyword\">this</span>.foo);</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log(<span class=\"string\">'outer func : self.foo'</span> + self.foo);</span><br><span class=\"line\">         (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">             <span class=\"built_in\">console</span>.log(<span class=\"string\">'inner func : this.foo'</span> + <span class=\"keyword\">this</span>.foo);</span><br><span class=\"line\">             <span class=\"built_in\">console</span>.log(<span class=\"string\">'inner func : self.foo'</span> + self.foo);</span><br><span class=\"line\">         &#125;)();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myObject.func();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>请写出以下正则表达式的详细规则说明<br>/^(0[1-9]\\d\\d?)?[1-9]\\d{6}\\d?$/<br>/^(1[89]|[2-9]\\d|100)$/i<br>/^[\\w-]+@[a-z0-9-]+({[a-z]{2,6}}){1,2}$/i</p>\n</li>\n<li>请写出打乱数组方法</li>\n<li>写出element.getElementsByClassName 的实现方法</li>\n<li><p>请写出代码输出结果</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!(<span class=\"string\">\"a\"</span> <span class=\"keyword\">in</span> <span class=\"built_in\">window</span>))&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(a);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>请写出代码输出结果</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> handle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">        b = a + b;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tmp.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(handle(<span class=\"number\">4</span>)(<span class=\"number\">5</span>)(<span class=\"number\">6</span>));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>javscript表达式”[]==’’”的值是什么，为什么？</p>\n</li>\n<li><p>Js生成下面html，点击每个li的时候弹出1,2,3……<br>//li onclick事件都能弹出当前被点击的index=?</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testUrl\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>index=0<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>index=1<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>map方法是ES5中新增的，要求为ES5以下的环境增加个map方法</p>\n</li>\n</ol>\n<h2 id=\"答案揭晓\"><a href=\"#答案揭晓\" class=\"headerlink\" title=\"答案揭晓\"></a>答案揭晓</h2><h3 id=\"第一题\"><a href=\"#第一题\" class=\"headerlink\" title=\"第一题\"></a>第一题</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\">n,o</span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(o)</span><br><span class=\"line\">   <span class=\"keyword\">return</span>&#123;</span><br><span class=\"line\">       fun:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m</span>)</span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> fun(m,n);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = fun(<span class=\"number\">0</span>); a.fun(<span class=\"number\">1</span>); a.fun(<span class=\"number\">2</span>); a.fun(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = fun(<span class=\"number\">0</span>).fun(<span class=\"number\">1</span>).fun(<span class=\"number\">2</span>).fun(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = fun(<span class=\"number\">0</span>).fun(<span class=\"number\">1</span>); c.fun(<span class=\"number\">2</span>); c.fun(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n<p>我们先来一步一步地看。首先是<code>a=fun(0)</code>因为只传了一个参数，<code>console</code>输出的是第二个参数的值，所以毫无疑问地输出<code>undefined</code>。</p>\n<p>然后到<code>a.fun(1)</code>可以看出，这句话是调用前面<code>fun(0)</code>返回回来的一个对象里面的函数<code>fun</code>，这个<code>fun</code>又把<code>fun(m,n)</code>返回出去。这个时候<strong>请注意</strong>：这个对象里的<code>fun</code>在返回之前调用了一下<code>fun(m,n)</code>，所以<code>console</code>又会被执行，可以确定，它肯定不会输出传进去的1，因为1作为第一个参数传到<code>fun(m,n)</code>里，而<code>console</code>是输出第二个参数的。那么这次会输出啥呢？</p>\n<p>好了，不给大家卖关子了，答案是0。可能有人会问了，纳尼？为毛是0，0是哪来的？</p>\n<p>要想看明白我的解释，前提是你得清楚闭包。这里用到了闭包。我们知道，闭包有个功能就是外部作用域能通过闭包访问函数内部的变量。其实在运行<code>a=fun(0)</code>的时候，<code>return</code>出来的对象里的函数<code>fun</code>把传进来的这个0作为第二个参数传到<code>fun</code>里面并返回出来这时0得到了保存。所以当运行<code>a.fun(1)</code>的时候其实输出的是之前的0。后面的那两个调用也和这个的原理一样，最后都是输出0。</p>\n<p>这里可能会有点绕，需要花点时间来看或者自行去调试。（我已经在尽力表达清楚了，如果还不懂的话就留言吧=.=）。</p>\n<p>然后到<code>b</code>，如果前面搞懂了这里就不难了。<code>fun(0)</code>运行的时候会<code>return</code>一个对象出去，后面的一串链式调用都是在调用前面函数返回的对象里的<code>fun</code>，最终导致输出是<code>undefined 0 1 2</code></p>\n<p>最后到<code>c</code>，如果<code>b</code>都搞懂了，到这里基本就没什么难度了。分别会输出<code>undefined 0 1 1</code>。</p>\n<p>如果还不懂的话建议单步调试一下，如果还是不懂可以在下面留言，我会尽最大能力给你解释。</p>\n<h3 id=\"第二题\"><a href=\"#第二题\" class=\"headerlink\" title=\"第二题\"></a>第二题</h3><p>用尽可能多的方法找出数组中重复出现过的元素<br>例如：[1，2，4，4，3，3，1，5，3]<br>输出：[1，3，4]</p>\n<p>我的思路是，先创建一个数组。然后将传进来的数组进行排序。然后再利用<code>sort</code>方法遍历数组，因为它能一次取到两个数然后<code>a</code>和<code>b</code>比较如果相等而且<code>result</code>里面又没有重复的就把<code>a</code>推进去。</p>\n<p>这是我的代码：</p>\n<h2 id=\"4-5日更新\"><a href=\"#4-5日更新\" class=\"headerlink\" title=\"4.5日更新\"></a>4.5日更新</h2><p>感谢<a href=\"https://www.zhihu.com/people/jue-qiang-de-xiao-ping-gai/answers\" target=\"_blank\" rel=\"noopener\">@倔强的小瓶盖</a>同学指出的问题</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">repeat</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = [];</span><br><span class=\"line\">    arr.sort().reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a === b &amp;&amp; result.indexOf(a) === <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            result.push(a);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//之前问题代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">repeat</span>(<span class=\"params\">arr</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result=[];</span><br><span class=\"line\">    arr.sort().sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a===b&amp;&amp;result.indexOf(a)===<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            result.push(a);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-23日更新\"><a href=\"#3-23日更新\" class=\"headerlink\" title=\"3.23日更新\"></a>3.23日更新</h2><p>感谢<a href=\"https://www.zhihu.com/people/start-wrap/answers\" target=\"_blank\" rel=\"noopener\">@start-wrap</a>同学提供的方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">repeat</span>(<span class=\"params\">arr</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> result = [], map = &#123;&#125;;</span><br><span class=\"line\">\tarr.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(map[num] === <span class=\"number\">1</span>) result.push(num);</span><br><span class=\"line\">\t\tmap[num] = (map[num] || <span class=\"number\">0</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;); </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>值得一提的是<code>map[num] = (map[num] || 0) + 1</code>，这句代码的<code>(map[num] || 0)</code>如果<code>map[num]</code>存在，则<code>map[num]</code>+1反之则0+1，个人觉得用得很巧妙。</p>\n<p>感谢<a href=\"https://www.zhihu.com/people/jerrywdlee/answers\" target=\"_blank\" rel=\"noopener\">@早乙女瑞穂</a>提供的淫技巧：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// es6</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> array = [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(array.filter(<span class=\"function\">(<span class=\"params\">x, i, self</span>) =&gt;</span> self.indexOf(x) !== i)));</span><br><span class=\"line\"><span class=\"comment\">// es5</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">array.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, i, self</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.indexOf(x) === i &amp;&amp; self.lastIndexOf(x) !== i </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>es6思路解说：</p>\n<p>array.filter((x, i, self) =&gt; self.indexOf(x) !== i)<br>返回一个数组，该数组由arrary中重复的元素构成(返回N-1次)</p>\n<p>new Set( [iterable] )<br>返回一个集合(重复元素在此被合并)</p>\n<p>Array.from( [iterable] )<br>返回一个数组(将上一步的集合变为数组)</p>\n<p>//es5思路解说：</p>\n<p>使用<code>indexOf</code>和<code>lastIndexOf</code>正向判断和反向判断这个元素是不是同一个数(如果是同一个数，则两个方法返回的<code>i</code>是一样的)</p>\n<h3 id=\"第三题\"><a href=\"#第三题\" class=\"headerlink\" title=\"第三题\"></a>第三题</h3><p>给定一些文档（docs）、词（words），找出词在文档中全部存在的所有文档</p>\n<p>我的思路是：把第二个参数的数组用<code>join</code>合成一个字符串，然后用<code>forEach</code>遍历，分别把文档里的<code>words</code>也用<code>join</code>合成一个字符串，利用<code>search</code>方法找每个文档里的<code>words</code>是否包含有<code>arrStr</code>。</p>\n<p>这是我的代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findDocList</span>(<span class=\"params\">docs, arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arrStr = arr.join(<span class=\"string\">\"\"</span>),</span><br><span class=\"line\">    itemStr,</span><br><span class=\"line\">    result = [];</span><br><span class=\"line\">    docs.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">        itemStr = item.words.join(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(itemStr.search(<span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(arrStr)) !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        result.push(<span class=\"string\">\"文档\"</span> + item.id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">findDocList(docs, [<span class=\"string\">'hello'</span>]) <span class=\"comment\">//文档1，文档2，文档3</span></span><br><span class=\"line\">findDocList(docs, [<span class=\"string\">'hello'</span>, <span class=\"string\">'world'</span>]) <span class=\"comment\">//文档1</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"第四题\"><a href=\"#第四题\" class=\"headerlink\" title=\"第四题\"></a>第四题</h3><p>下面代码会输出什么？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + b;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;(<span class=\"number\">1</span>,<span class=\"number\">2</span>)));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test(<span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，这里有两个自执行函数。下面这个自执行函数执行完后向上面这个自执行函数传了个1所以<code>this.a=1</code>，这里的<code>this</code>指向<code>window</code>。然后这个自执行函数返回个函数给<code>test</code>变量。下面调用<code>test(1)</code>，这个1传进来后相当于<code>return 1+1</code>所以就输出2。</p>\n<h3 id=\"第五题\"><a href=\"#第五题\" class=\"headerlink\" title=\"第五题\"></a>第五题</h3><p>不用循环，创建一个长度为 100 的数组，并且每个元素的值等于它的下标。</p>\n<p>如果了解<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\" target=\"_blank\" rel=\"noopener\">Object.keys</a>和<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from\" target=\"_blank\" rel=\"noopener\">Array.form</a>的话，这题基本上没啥难度。<br>答案：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.keys(<span class=\"built_in\">Array</span>.from(&#123;<span class=\"attr\">length</span>:<span class=\"number\">100</span>&#125;))</span><br></pre></td></tr></table></figure></p>\n<p>哎！等下<code>Array.form</code>不是es6的吗，es5的怎么实现？<br>代码来了：</p>\n<pre><code>Object.keys(Array.apply(null,{length:100}))\n</code></pre><p>如果还不懂可以参考<a href=\"https://www.zhihu.com/question/41493194\" target=\"_blank\" rel=\"noopener\">这里</a>的讲解。</p>\n<h3 id=\"第六题\"><a href=\"#第六题\" class=\"headerlink\" title=\"第六题\"></a>第六题</h3><p>一个整数，它的各位数字如果是左右对称的，则这个数字是对称数。那么请找出 1 至 10000 中所有的对称数</p>\n<p>我的思路，先将数字转为字符串，然后利用数组的<code>map</code>方法遍历这个字符串，将字符串全部分开变为数组，然后调用数组的<code>reverse</code>方法，再将翻转后的数组<code>join</code>成字符串，最后对比翻转后的字符串和翻转前的字符串是否相等即可（方法有点愚笨，望大神指教）：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">symmetric</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i=<span class=\"number\">1</span>,</span><br><span class=\"line\">    str,</span><br><span class=\"line\">    newStr,</span><br><span class=\"line\">    result=[];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;i&lt;<span class=\"number\">1000</span>;i++)&#123;</span><br><span class=\"line\">        str=<span class=\"string\">\"\"</span>+i;</span><br><span class=\"line\">        newStr=result.map.call(str,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> item;</span><br><span class=\"line\">        &#125;).reverse().join(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str===newStr)&#123;</span><br><span class=\"line\">            result.push(+str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"第七题\"><a href=\"#第七题\" class=\"headerlink\" title=\"第七题\"></a>第七题</h3><p>以下代码输出什么？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">    foo: <span class=\"string\">\"bar\"</span>,</span><br><span class=\"line\">    func: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'outer func : this.foo'</span> + <span class=\"keyword\">this</span>.foo);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'outer func : self.foo'</span> + self.foo);</span><br><span class=\"line\">    (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'inner func : this.foo'</span> + <span class=\"keyword\">this</span>.foo);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'inner func : self.foo'</span> + self.foo);</span><br><span class=\"line\">    &#125;)();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myObject.func();</span><br></pre></td></tr></table></figure></p>\n<p>这题主要考察<code>this</code>指向，个人觉得难度不是太大，因为<code>this</code>已经被我完全承包啦(坏笑脸)。<br>这题的话只需考虑谁调用的函数<code>this</code>就指向谁。<br>函数开始执行<code>self=this</code>这里的<code>this</code>是指向<code>myObject</code>的，因为<code>myObject.func()</code>很明显是<code>myObject</code>在调用它嘛，所以头两句<code>console</code>输出的<code>foo</code>都是<code>bar</code>。<br>下面是一个自执行函数，要知道，自执行函数的<code>this</code>一般情况下都指向<code>window</code>这里也不例外，所以，第三个<code>console</code>输出的<code>foo</code>是<code>undefined</code>因为在<code>window</code>下<code>foo</code>没定义。第四个输出的是<code>self.foo</code>这个<code>self</code>就是上面定义的<code>self</code>即<code>myObject</code>所以，这里的<code>foo</code>为<code>bar</code>。</p>\n<h3 id=\"第八题\"><a href=\"#第八题\" class=\"headerlink\" title=\"第八题\"></a>第八题</h3><p>请写出以下正则表达式的详细规则说明<br>/^(0[1-9]\\d\\d?)?[1-9]\\d{6}\\d?$/<br>/^(1[89]|[2-9]\\d|100)$/i<br>/^[\\w-]+@[a-z0-9-]+({[a-z]{2,6}}){1,2}$/i</p>\n<p>嘿嘿，正则也算我比较拿手的部分。我来一个一个解释吧，有些正则比较难用语言表达，大家意会意会吧。</p>\n<p>第一个：首先<code>^</code>代表的是以它后面的一堆东西为开头<code>$</code>代表以它前面一堆东西为结尾，在这里的意思就是以<code>(0[1-9]\\d\\d?)?[1-9]\\d{6}\\d?</code>为开头和结尾的字符串。然后到第一个括号里的意思是匹配第一个字符串为0第二个字符串为1-9第三个字符串为0-9第四个字符串可有可无，有的话匹配1-9，然后这整个括号里面的内容可有可无。问好后面的意思是匹配第一个字符串是1-9然后后面6个字符串匹配0-9最后一个字符串可有可无，有的话匹配0-9。</p>\n<p>所以整理整理就是：匹配以0为第一个，1-9为第二个，数字为第三个；第四个可有可无，有的话匹配数字；然后前面这一整坨可有可无。1-9为第五个(如果前面那一坨没有的话，则从第一个算起)然后后面6个都是数字最后一个数字可有可无的字符串，且以它为开头和结尾。</p>\n<p>下面是例子：<br>022222222222  //true<br>002222222222 //false 因为第二个数字是1-9<br>02222222222 //第一个括号最后一个数字<strong>或</strong>者最后面的数字省略<br>0222222222 //第一个括号最后一个数字<strong>和</strong>者最后面的数字省略<br>22222222  //第一个括号里的内容全部省略<br>02222222 //\\d{6}没有满足。</p>\n<p>第二个：匹配以1作为第一个，8或9作为第二个<strong>又或者</strong>以2-9为第一个，数字为第二个又或者匹配100的字符串，并以他们为开头和结尾，忽略大小写。</p>\n<p>还是例子比较直观：</p>\n<p>18 //true 匹配前面的1[89]<br>23 //true 匹配[2-9]\\d<br>100 //true 匹配100<br>17 //false<br>230 //false</p>\n<p>第三个：<br>匹配前面至少一个数字或字母或_或-再匹配@然后再匹配至少一个字母或数字或-然后到再匹配{字母2-6个}1-2个，的字符串，并以他们为开头和结尾忽略大小写。</p>\n<p>这个用语言描述太难了，是我不会说话吗，上例子吧：</p>\n<p>3@d{aw}{ad} //true<br>-@-{ddd}{fs} //true<br>3@3{dw}{ddd} //true<br>3@3{dw} //false {字母2-6个}少了一个即<code>({[a-z]{2,6}}){1,2}</code>后面的<code>{1,2}</code>没满足<br>@3{dw}{ddd} //false [\\w-]+没满足<br>33{dw}{ddd} //false 没@<br>dsa@ffff{dw}{d} //false ({[a-z]{2,6}})不符合</p>\n<h3 id=\"第九题\"><a href=\"#第九题\" class=\"headerlink\" title=\"第九题\"></a>第九题</h3><p>请写出打乱数组方法</p>\n<h2 id=\"4-5日更新-1\"><a href=\"#4-5日更新-1\" class=\"headerlink\" title=\"4.5日更新\"></a>4.5日更新</h2><p><a href=\"https://www.h5jun.com/post/array-shuffle.html\" target=\"_blank\" rel=\"noopener\">参考这里</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 之前的问题代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">randomsort</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.random()&gt;<span class=\"number\">.5</span> ? <span class=\"number\">-1</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//用Math.random()函数生成0~1之间的随机数与0.5比较，返回-1或1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">arr.sort(randomsort);</span><br></pre></td></tr></table></figure>\n<h3 id=\"第十题\"><a href=\"#第十题\" class=\"headerlink\" title=\"第十题\"></a>第十题</h3><p>写出element.getElementsByClassName 的实现方法<br>我的思路：先获取页面下的所有元素，然后用<code>split</code>将传进来的多个<code>class</code>分割成数组，然后利两层循环找出符合条件的元素（个人觉得这种方法效率实在低下，就当是抛砖引玉吧，欢迎留言）<br>代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!<span class=\"built_in\">document</span>.getElementsByClassName) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementsByClassName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">className</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ele = [],</span><br><span class=\"line\">        tags = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"*\"</span>);</span><br><span class=\"line\">    className = className.split(<span class=\"regexp\">/\\s+/</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; tags.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; className.length; j++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果这个元素上有这个class且没在ele里面(主要防止多个class加在一个元素上推进去两次的情况)</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tags[i].className === className[j] &amp;&amp; ele.indexOf(tags[i]) === <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">                ele.push(tags[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ele;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"第十一题\"><a href=\"#第十一题\" class=\"headerlink\" title=\"第十一题\"></a>第十一题</h3><p>请写出代码输出结果<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!(<span class=\"string\">\"a\"</span> <span class=\"keyword\">in</span> <span class=\"built_in\">window</span>))&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(a);</span><br></pre></td></tr></table></figure></p>\n<p>这题主要考察了变量的声明提升，任何变量(es5中)的声明都会提升到当前作用域的顶端。所以这里的代码其实为：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(!(<span class=\"string\">\"a\"</span> <span class=\"keyword\">in</span> <span class=\"built_in\">window</span>))&#123;</span><br><span class=\"line\">    a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(a);</span><br></pre></td></tr></table></figure></p>\n<p>所以，在if语句执行前<code>a</code>就已经在<code>window</code>中了，所以这里会<code>atert undefined</code></p>\n<h3 id=\"第十二题\"><a href=\"#第十二题\" class=\"headerlink\" title=\"第十二题\"></a>第十二题</h3><p>请写出代码输出结果<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> handle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">        b = a + b;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tmp.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(handle(<span class=\"number\">4</span>)(<span class=\"number\">5</span>)(<span class=\"number\">6</span>));</span><br></pre></td></tr></table></figure></p>\n<p>我们来一步一步看：首先是<code>handle(4)</code>，到这里，程序开始运行，创建了一个<code>tmp</code>函数，同时把<code>tmp</code>函数的<code>toString</code>方法重写了，最后返回这个<code>tmp</code>函数。<br><strong>注意</strong>：<code>tmp</code>里的<code>a</code>不是传进去的4，不要把<code>tmp</code>的<code>a</code>和<code>handle</code>的<code>a</code>搞混了，所以这里传的4啥也没干。</p>\n<p>然后到第二步：<code>handle(4)(5)</code>，这里就是执行了<code>tmp</code>函数，这个时候<code>tmp</code>函数的<code>a</code>就是传进来的5，·<code>b</code>就是第一步函数执行的<code>b</code>即3(不懂为何是3的同学再去了解了解闭包吧)，最后这个<code>b</code>就等于8。</p>\n<p>第三部重复第二步<code>8+6</code>，最后<code>b</code>为14，<code>javascript</code>引擎最后自动调用了<code>toString</code>返回<code>b</code>，所以结果是14。</p>\n<h3 id=\"第十三题\"><a href=\"#第十三题\" class=\"headerlink\" title=\"第十三题\"></a>第十三题</h3><p>javscript表达式”[]==’’”的值是什么，为什么？</p>\n<p>这题考察对js<code>==</code>运算符的了解，我们知道<code>==</code>运算符如果两边值类型不一样会把它们转换为相同类型的值再来比较。这题左边是<code>object</code>类型，右边是<code>string</code>类型，所以会把左边的转化为<code>string</code>类型来比较，<code>[].toString()</code>就是<code>&#39;&#39;</code>所以最后结果是<code>true</code>。</p>\n<h3 id=\"第十四题\"><a href=\"#第十四题\" class=\"headerlink\" title=\"第十四题\"></a>第十四题</h3><p>Js生成下面html，点击每个li的时候弹出1,2,3……<br>//li onclick事件都能弹出当前被点击的index=?<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testUrl\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>index=0<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>index=1<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这题直接按照要求生成对应的html，再给<code>ul</code>绑定个事件，利用事件代理监听是谁被点了，然后输出它们的序号和对应的内容，没啥难度。我的代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ul=<span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"ul\"</span>),</span><br><span class=\"line\">    lis=[];</span><br><span class=\"line\">    ul.id=<span class=\"string\">\"testUrl\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>,li;i&lt;<span class=\"number\">2</span>;i++)&#123;</span><br><span class=\"line\">    li=<span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"li\"</span>);</span><br><span class=\"line\">    li.innerHTML=<span class=\"string\">\"index=\"</span>+i;</span><br><span class=\"line\">    ul.appendChild(li);</span><br><span class=\"line\">    lis.push(li);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ul.addEventListener(<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">    alert(lis.indexOf(e.target));</span><br><span class=\"line\">    alert(e.target.innerHTML)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild(ul);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"第十五题\"><a href=\"#第十五题\" class=\"headerlink\" title=\"第十五题\"></a>第十五题</h3><p>map方法是ES5中新增的，要求为ES5以下的环境增加个map方法</p>\n<p>个人认为只要对<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Compatibility\" target=\"_blank\" rel=\"noopener\">map</a>方法够了解，自然就能封装出来了。嘿嘿，不喜勿喷。给的链接虽然也有一个实现<code>map</code>的方法，但是用到了es5的<code>for in</code>不符合题目，所以我的代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!<span class=\"built_in\">Array</span>.prototype.map)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Array</span>.prototype.map=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback,context</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len=<span class=\"keyword\">this</span>.length,</span><br><span class=\"line\">        i=<span class=\"number\">0</span>,</span><br><span class=\"line\">        result=[];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> callback !== <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(callback + <span class=\"string\">\" is not a function\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    context=context||<span class=\"built_in\">window</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;i&lt;len;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>[i]!==<span class=\"literal\">undefined</span>?result.push(callback.call(context,<span class=\"keyword\">this</span>[i],i,<span class=\"keyword\">this</span>)):result.push(<span class=\"keyword\">this</span>[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>不过我的代码和标准的输出结果还是有点出入的。就是我不处理<code>undefined</code>和<code>null</code>，因为<code>this[i]!==undefined</code>，这两个值是会原样返回的。不过日常的一些需求还是能满足的。欢迎大家提建议哈。</p>\n<p>终于打完了，这期就这么多题，希望能对大家有帮助，同时如果有不对的地方请及时指正，欢迎留言。</p>\n<p>另外，欢迎大家来围观我封装的一个<a href=\"https://github.com/JayZangwill/lightings\" target=\"_blank\" rel=\"noopener\">ajax库 lightings</a>。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.jb51.net/article/87094.htm\" target=\"_blank\" rel=\"noopener\">JS随机打乱数组的方法小结</a><br><a href=\"https://www.zhihu.com/question/41493194\" target=\"_blank\" rel=\"noopener\">如何不使用loop循环，创建一个长度为100的数组，并且每个元素的值等于它的下标</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Compatibility\" target=\"_blank\" rel=\"noopener\">MDN map</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><a href=\"https://jayzangwill.github.io/blog/2017/03/19/Some%20of%20the%20interview%20questions%20that%20impressed%20me-2/\">原文地址</a>&amp;&amp;<a href=\"https://jayzangwill.github.io/blog/\">我的博客</a><br><a href=\"https://zhuanlan.zhihu.com/p/25863288\" target=\"_blank\" rel=\"noopener\">知乎</a>&amp;&amp;<a href=\"https://zhuanlan.zhihu.com/jayzangwill\" target=\"_blank\" rel=\"noopener\">知乎专栏</a><br><a href=\"http://link.zhihu.com/?target=http%3A//www.jianshu.com/p/65319f42a5ce\" target=\"_blank\" rel=\"noopener\">简书</a><br><a href=\"http://henanjs.org/\" target=\"_blank\" rel=\"noopener\">河南前端交流群官网</a></p>\n<p>上次写了一篇<a href=\"https://jayzangwill.github.io/blog/2017/03/01/Some%20of%20the%20interview%20questions%20that%20impressed%20me-1/\">几个让我印象深刻的面试题(一)</a>没看过的同学可以去看哦。<br>这次文章的题目来源：<a href=\"https://juejin.im/post/58c51b5c44d90400698da686\" target=\"_blank\" rel=\"noopener\">这里有超过20家的前端面试题，你确定不点进来看看？</a>。<br>如果上面的问题在我这篇文章里没有提到的话，那就说明有些问题可以很容易查得到或者很简单或者我能力有限不能解答出来的。如果有的问题你不会而且我又没有提的那就认为就是我能力有限不能解答出来吧。嘿嘿嘿。开个玩笑，不过可以在下面留言哦！</p>","more":"<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>还是老规矩先给题目，然后在看我的答案，有什么意见可以在留言板提。</p>\n<ol>\n<li>请问a，b，c分别输出什么？</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\">n,o</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(o)</span><br><span class=\"line\">    <span class=\"keyword\">return</span>&#123;</span><br><span class=\"line\">      fun:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m</span>)</span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> fun(m,n);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = fun(<span class=\"number\">0</span>); a.fun(<span class=\"number\">1</span>); a.fun(<span class=\"number\">2</span>); a.fun(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = fun(<span class=\"number\">0</span>).fun(<span class=\"number\">1</span>).fun(<span class=\"number\">2</span>).fun(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = fun(<span class=\"number\">0</span>).fun(<span class=\"number\">1</span>); c.fun(<span class=\"number\">2</span>); c.fun(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>用尽可能多的方法找出数组中重复出现过的元素</li>\n</ol>\n<p>例如：[1，2，4，4，3，3，1，5，3]</p>\n<p>输出：[1，3，4]</p>\n<ol start=\"3\">\n<li>给定一些文档（docs）、词（words），找出词在文档中全部存在的所有文档</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> docs = [&#123;</span><br><span class=\"line\">        id: <span class=\"number\">1</span>,</span><br><span class=\"line\">        words: [<span class=\"string\">'hello'</span>,<span class=\"string\">\"world\"</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        id: <span class=\"number\">2</span>,</span><br><span class=\"line\">        words: [<span class=\"string\">'hello'</span>,<span class=\"string\">\"kids\"</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        id: <span class=\"number\">3</span>,</span><br><span class=\"line\">        words: [<span class=\"string\">'zzzz'</span>,<span class=\"string\">\"hello\"</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        id: <span class=\"number\">4</span>,</span><br><span class=\"line\">        words: [<span class=\"string\">'world'</span>,<span class=\"string\">\"kids\"</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> ];</span><br><span class=\"line\">findDocList(docs,[<span class=\"string\">'hello'</span>]) <span class=\"comment\">//文档1，文档2，文档3</span></span><br><span class=\"line\">findDocList(docs,[<span class=\"string\">'hello'</span>,<span class=\"string\">'world'</span>]) <span class=\"comment\">//文档1</span></span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>下面代码会输出什么？</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;(<span class=\"number\">1</span>,<span class=\"number\">2</span>)));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test(<span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>不用循环，创建一个长度为 100 的数组，并且每个元素的值等于它的下标。</li>\n<li>一个整数，它的各位数字如果是左右对称的，则这个数字是对称数。那么请找出 1 至 10000 中所有的对称数</li>\n<li><p>以下代码输出结果是什么？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">    foo: <span class=\"string\">\"bar\"</span>,</span><br><span class=\"line\">    func: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log(<span class=\"string\">'outer func : this.foo'</span> + <span class=\"keyword\">this</span>.foo);</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log(<span class=\"string\">'outer func : self.foo'</span> + self.foo);</span><br><span class=\"line\">         (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">             <span class=\"built_in\">console</span>.log(<span class=\"string\">'inner func : this.foo'</span> + <span class=\"keyword\">this</span>.foo);</span><br><span class=\"line\">             <span class=\"built_in\">console</span>.log(<span class=\"string\">'inner func : self.foo'</span> + self.foo);</span><br><span class=\"line\">         &#125;)();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myObject.func();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>请写出以下正则表达式的详细规则说明<br>/^(0[1-9]\\d\\d?)?[1-9]\\d{6}\\d?$/<br>/^(1[89]|[2-9]\\d|100)$/i<br>/^[\\w-]+@[a-z0-9-]+({[a-z]{2,6}}){1,2}$/i</p>\n</li>\n<li>请写出打乱数组方法</li>\n<li>写出element.getElementsByClassName 的实现方法</li>\n<li><p>请写出代码输出结果</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!(<span class=\"string\">\"a\"</span> <span class=\"keyword\">in</span> <span class=\"built_in\">window</span>))&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(a);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>请写出代码输出结果</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> handle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">        b = a + b;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tmp.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(handle(<span class=\"number\">4</span>)(<span class=\"number\">5</span>)(<span class=\"number\">6</span>));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>javscript表达式”[]==’’”的值是什么，为什么？</p>\n</li>\n<li><p>Js生成下面html，点击每个li的时候弹出1,2,3……<br>//li onclick事件都能弹出当前被点击的index=?</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testUrl\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>index=0<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>index=1<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>map方法是ES5中新增的，要求为ES5以下的环境增加个map方法</p>\n</li>\n</ol>\n<h2 id=\"答案揭晓\"><a href=\"#答案揭晓\" class=\"headerlink\" title=\"答案揭晓\"></a>答案揭晓</h2><h3 id=\"第一题\"><a href=\"#第一题\" class=\"headerlink\" title=\"第一题\"></a>第一题</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\">n,o</span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(o)</span><br><span class=\"line\">   <span class=\"keyword\">return</span>&#123;</span><br><span class=\"line\">       fun:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m</span>)</span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> fun(m,n);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = fun(<span class=\"number\">0</span>); a.fun(<span class=\"number\">1</span>); a.fun(<span class=\"number\">2</span>); a.fun(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = fun(<span class=\"number\">0</span>).fun(<span class=\"number\">1</span>).fun(<span class=\"number\">2</span>).fun(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = fun(<span class=\"number\">0</span>).fun(<span class=\"number\">1</span>); c.fun(<span class=\"number\">2</span>); c.fun(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n<p>我们先来一步一步地看。首先是<code>a=fun(0)</code>因为只传了一个参数，<code>console</code>输出的是第二个参数的值，所以毫无疑问地输出<code>undefined</code>。</p>\n<p>然后到<code>a.fun(1)</code>可以看出，这句话是调用前面<code>fun(0)</code>返回回来的一个对象里面的函数<code>fun</code>，这个<code>fun</code>又把<code>fun(m,n)</code>返回出去。这个时候<strong>请注意</strong>：这个对象里的<code>fun</code>在返回之前调用了一下<code>fun(m,n)</code>，所以<code>console</code>又会被执行，可以确定，它肯定不会输出传进去的1，因为1作为第一个参数传到<code>fun(m,n)</code>里，而<code>console</code>是输出第二个参数的。那么这次会输出啥呢？</p>\n<p>好了，不给大家卖关子了，答案是0。可能有人会问了，纳尼？为毛是0，0是哪来的？</p>\n<p>要想看明白我的解释，前提是你得清楚闭包。这里用到了闭包。我们知道，闭包有个功能就是外部作用域能通过闭包访问函数内部的变量。其实在运行<code>a=fun(0)</code>的时候，<code>return</code>出来的对象里的函数<code>fun</code>把传进来的这个0作为第二个参数传到<code>fun</code>里面并返回出来这时0得到了保存。所以当运行<code>a.fun(1)</code>的时候其实输出的是之前的0。后面的那两个调用也和这个的原理一样，最后都是输出0。</p>\n<p>这里可能会有点绕，需要花点时间来看或者自行去调试。（我已经在尽力表达清楚了，如果还不懂的话就留言吧=.=）。</p>\n<p>然后到<code>b</code>，如果前面搞懂了这里就不难了。<code>fun(0)</code>运行的时候会<code>return</code>一个对象出去，后面的一串链式调用都是在调用前面函数返回的对象里的<code>fun</code>，最终导致输出是<code>undefined 0 1 2</code></p>\n<p>最后到<code>c</code>，如果<code>b</code>都搞懂了，到这里基本就没什么难度了。分别会输出<code>undefined 0 1 1</code>。</p>\n<p>如果还不懂的话建议单步调试一下，如果还是不懂可以在下面留言，我会尽最大能力给你解释。</p>\n<h3 id=\"第二题\"><a href=\"#第二题\" class=\"headerlink\" title=\"第二题\"></a>第二题</h3><p>用尽可能多的方法找出数组中重复出现过的元素<br>例如：[1，2，4，4，3，3，1，5，3]<br>输出：[1，3，4]</p>\n<p>我的思路是，先创建一个数组。然后将传进来的数组进行排序。然后再利用<code>sort</code>方法遍历数组，因为它能一次取到两个数然后<code>a</code>和<code>b</code>比较如果相等而且<code>result</code>里面又没有重复的就把<code>a</code>推进去。</p>\n<p>这是我的代码：</p>\n<h2 id=\"4-5日更新\"><a href=\"#4-5日更新\" class=\"headerlink\" title=\"4.5日更新\"></a>4.5日更新</h2><p>感谢<a href=\"https://www.zhihu.com/people/jue-qiang-de-xiao-ping-gai/answers\" target=\"_blank\" rel=\"noopener\">@倔强的小瓶盖</a>同学指出的问题</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">repeat</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = [];</span><br><span class=\"line\">    arr.sort().reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a === b &amp;&amp; result.indexOf(a) === <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            result.push(a);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//之前问题代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">repeat</span>(<span class=\"params\">arr</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result=[];</span><br><span class=\"line\">    arr.sort().sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a===b&amp;&amp;result.indexOf(a)===<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            result.push(a);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-23日更新\"><a href=\"#3-23日更新\" class=\"headerlink\" title=\"3.23日更新\"></a>3.23日更新</h2><p>感谢<a href=\"https://www.zhihu.com/people/start-wrap/answers\" target=\"_blank\" rel=\"noopener\">@start-wrap</a>同学提供的方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">repeat</span>(<span class=\"params\">arr</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> result = [], map = &#123;&#125;;</span><br><span class=\"line\">\tarr.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(map[num] === <span class=\"number\">1</span>) result.push(num);</span><br><span class=\"line\">\t\tmap[num] = (map[num] || <span class=\"number\">0</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;); </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>值得一提的是<code>map[num] = (map[num] || 0) + 1</code>，这句代码的<code>(map[num] || 0)</code>如果<code>map[num]</code>存在，则<code>map[num]</code>+1反之则0+1，个人觉得用得很巧妙。</p>\n<p>感谢<a href=\"https://www.zhihu.com/people/jerrywdlee/answers\" target=\"_blank\" rel=\"noopener\">@早乙女瑞穂</a>提供的淫技巧：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// es6</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> array = [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(array.filter(<span class=\"function\">(<span class=\"params\">x, i, self</span>) =&gt;</span> self.indexOf(x) !== i)));</span><br><span class=\"line\"><span class=\"comment\">// es5</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">array.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, i, self</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.indexOf(x) === i &amp;&amp; self.lastIndexOf(x) !== i </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>es6思路解说：</p>\n<p>array.filter((x, i, self) =&gt; self.indexOf(x) !== i)<br>返回一个数组，该数组由arrary中重复的元素构成(返回N-1次)</p>\n<p>new Set( [iterable] )<br>返回一个集合(重复元素在此被合并)</p>\n<p>Array.from( [iterable] )<br>返回一个数组(将上一步的集合变为数组)</p>\n<p>//es5思路解说：</p>\n<p>使用<code>indexOf</code>和<code>lastIndexOf</code>正向判断和反向判断这个元素是不是同一个数(如果是同一个数，则两个方法返回的<code>i</code>是一样的)</p>\n<h3 id=\"第三题\"><a href=\"#第三题\" class=\"headerlink\" title=\"第三题\"></a>第三题</h3><p>给定一些文档（docs）、词（words），找出词在文档中全部存在的所有文档</p>\n<p>我的思路是：把第二个参数的数组用<code>join</code>合成一个字符串，然后用<code>forEach</code>遍历，分别把文档里的<code>words</code>也用<code>join</code>合成一个字符串，利用<code>search</code>方法找每个文档里的<code>words</code>是否包含有<code>arrStr</code>。</p>\n<p>这是我的代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findDocList</span>(<span class=\"params\">docs, arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arrStr = arr.join(<span class=\"string\">\"\"</span>),</span><br><span class=\"line\">    itemStr,</span><br><span class=\"line\">    result = [];</span><br><span class=\"line\">    docs.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">        itemStr = item.words.join(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(itemStr.search(<span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(arrStr)) !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        result.push(<span class=\"string\">\"文档\"</span> + item.id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">findDocList(docs, [<span class=\"string\">'hello'</span>]) <span class=\"comment\">//文档1，文档2，文档3</span></span><br><span class=\"line\">findDocList(docs, [<span class=\"string\">'hello'</span>, <span class=\"string\">'world'</span>]) <span class=\"comment\">//文档1</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"第四题\"><a href=\"#第四题\" class=\"headerlink\" title=\"第四题\"></a>第四题</h3><p>下面代码会输出什么？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + b;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;(<span class=\"number\">1</span>,<span class=\"number\">2</span>)));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test(<span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，这里有两个自执行函数。下面这个自执行函数执行完后向上面这个自执行函数传了个1所以<code>this.a=1</code>，这里的<code>this</code>指向<code>window</code>。然后这个自执行函数返回个函数给<code>test</code>变量。下面调用<code>test(1)</code>，这个1传进来后相当于<code>return 1+1</code>所以就输出2。</p>\n<h3 id=\"第五题\"><a href=\"#第五题\" class=\"headerlink\" title=\"第五题\"></a>第五题</h3><p>不用循环，创建一个长度为 100 的数组，并且每个元素的值等于它的下标。</p>\n<p>如果了解<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\" target=\"_blank\" rel=\"noopener\">Object.keys</a>和<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from\" target=\"_blank\" rel=\"noopener\">Array.form</a>的话，这题基本上没啥难度。<br>答案：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.keys(<span class=\"built_in\">Array</span>.from(&#123;<span class=\"attr\">length</span>:<span class=\"number\">100</span>&#125;))</span><br></pre></td></tr></table></figure></p>\n<p>哎！等下<code>Array.form</code>不是es6的吗，es5的怎么实现？<br>代码来了：</p>\n<pre><code>Object.keys(Array.apply(null,{length:100}))\n</code></pre><p>如果还不懂可以参考<a href=\"https://www.zhihu.com/question/41493194\" target=\"_blank\" rel=\"noopener\">这里</a>的讲解。</p>\n<h3 id=\"第六题\"><a href=\"#第六题\" class=\"headerlink\" title=\"第六题\"></a>第六题</h3><p>一个整数，它的各位数字如果是左右对称的，则这个数字是对称数。那么请找出 1 至 10000 中所有的对称数</p>\n<p>我的思路，先将数字转为字符串，然后利用数组的<code>map</code>方法遍历这个字符串，将字符串全部分开变为数组，然后调用数组的<code>reverse</code>方法，再将翻转后的数组<code>join</code>成字符串，最后对比翻转后的字符串和翻转前的字符串是否相等即可（方法有点愚笨，望大神指教）：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">symmetric</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i=<span class=\"number\">1</span>,</span><br><span class=\"line\">    str,</span><br><span class=\"line\">    newStr,</span><br><span class=\"line\">    result=[];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;i&lt;<span class=\"number\">1000</span>;i++)&#123;</span><br><span class=\"line\">        str=<span class=\"string\">\"\"</span>+i;</span><br><span class=\"line\">        newStr=result.map.call(str,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> item;</span><br><span class=\"line\">        &#125;).reverse().join(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str===newStr)&#123;</span><br><span class=\"line\">            result.push(+str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"第七题\"><a href=\"#第七题\" class=\"headerlink\" title=\"第七题\"></a>第七题</h3><p>以下代码输出什么？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">    foo: <span class=\"string\">\"bar\"</span>,</span><br><span class=\"line\">    func: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'outer func : this.foo'</span> + <span class=\"keyword\">this</span>.foo);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'outer func : self.foo'</span> + self.foo);</span><br><span class=\"line\">    (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'inner func : this.foo'</span> + <span class=\"keyword\">this</span>.foo);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'inner func : self.foo'</span> + self.foo);</span><br><span class=\"line\">    &#125;)();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myObject.func();</span><br></pre></td></tr></table></figure></p>\n<p>这题主要考察<code>this</code>指向，个人觉得难度不是太大，因为<code>this</code>已经被我完全承包啦(坏笑脸)。<br>这题的话只需考虑谁调用的函数<code>this</code>就指向谁。<br>函数开始执行<code>self=this</code>这里的<code>this</code>是指向<code>myObject</code>的，因为<code>myObject.func()</code>很明显是<code>myObject</code>在调用它嘛，所以头两句<code>console</code>输出的<code>foo</code>都是<code>bar</code>。<br>下面是一个自执行函数，要知道，自执行函数的<code>this</code>一般情况下都指向<code>window</code>这里也不例外，所以，第三个<code>console</code>输出的<code>foo</code>是<code>undefined</code>因为在<code>window</code>下<code>foo</code>没定义。第四个输出的是<code>self.foo</code>这个<code>self</code>就是上面定义的<code>self</code>即<code>myObject</code>所以，这里的<code>foo</code>为<code>bar</code>。</p>\n<h3 id=\"第八题\"><a href=\"#第八题\" class=\"headerlink\" title=\"第八题\"></a>第八题</h3><p>请写出以下正则表达式的详细规则说明<br>/^(0[1-9]\\d\\d?)?[1-9]\\d{6}\\d?$/<br>/^(1[89]|[2-9]\\d|100)$/i<br>/^[\\w-]+@[a-z0-9-]+({[a-z]{2,6}}){1,2}$/i</p>\n<p>嘿嘿，正则也算我比较拿手的部分。我来一个一个解释吧，有些正则比较难用语言表达，大家意会意会吧。</p>\n<p>第一个：首先<code>^</code>代表的是以它后面的一堆东西为开头<code>$</code>代表以它前面一堆东西为结尾，在这里的意思就是以<code>(0[1-9]\\d\\d?)?[1-9]\\d{6}\\d?</code>为开头和结尾的字符串。然后到第一个括号里的意思是匹配第一个字符串为0第二个字符串为1-9第三个字符串为0-9第四个字符串可有可无，有的话匹配1-9，然后这整个括号里面的内容可有可无。问好后面的意思是匹配第一个字符串是1-9然后后面6个字符串匹配0-9最后一个字符串可有可无，有的话匹配0-9。</p>\n<p>所以整理整理就是：匹配以0为第一个，1-9为第二个，数字为第三个；第四个可有可无，有的话匹配数字；然后前面这一整坨可有可无。1-9为第五个(如果前面那一坨没有的话，则从第一个算起)然后后面6个都是数字最后一个数字可有可无的字符串，且以它为开头和结尾。</p>\n<p>下面是例子：<br>022222222222  //true<br>002222222222 //false 因为第二个数字是1-9<br>02222222222 //第一个括号最后一个数字<strong>或</strong>者最后面的数字省略<br>0222222222 //第一个括号最后一个数字<strong>和</strong>者最后面的数字省略<br>22222222  //第一个括号里的内容全部省略<br>02222222 //\\d{6}没有满足。</p>\n<p>第二个：匹配以1作为第一个，8或9作为第二个<strong>又或者</strong>以2-9为第一个，数字为第二个又或者匹配100的字符串，并以他们为开头和结尾，忽略大小写。</p>\n<p>还是例子比较直观：</p>\n<p>18 //true 匹配前面的1[89]<br>23 //true 匹配[2-9]\\d<br>100 //true 匹配100<br>17 //false<br>230 //false</p>\n<p>第三个：<br>匹配前面至少一个数字或字母或_或-再匹配@然后再匹配至少一个字母或数字或-然后到再匹配{字母2-6个}1-2个，的字符串，并以他们为开头和结尾忽略大小写。</p>\n<p>这个用语言描述太难了，是我不会说话吗，上例子吧：</p>\n<p>3@d{aw}{ad} //true<br>-@-{ddd}{fs} //true<br>3@3{dw}{ddd} //true<br>3@3{dw} //false {字母2-6个}少了一个即<code>({[a-z]{2,6}}){1,2}</code>后面的<code>{1,2}</code>没满足<br>@3{dw}{ddd} //false [\\w-]+没满足<br>33{dw}{ddd} //false 没@<br>dsa@ffff{dw}{d} //false ({[a-z]{2,6}})不符合</p>\n<h3 id=\"第九题\"><a href=\"#第九题\" class=\"headerlink\" title=\"第九题\"></a>第九题</h3><p>请写出打乱数组方法</p>\n<h2 id=\"4-5日更新-1\"><a href=\"#4-5日更新-1\" class=\"headerlink\" title=\"4.5日更新\"></a>4.5日更新</h2><p><a href=\"https://www.h5jun.com/post/array-shuffle.html\" target=\"_blank\" rel=\"noopener\">参考这里</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 之前的问题代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">randomsort</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.random()&gt;<span class=\"number\">.5</span> ? <span class=\"number\">-1</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//用Math.random()函数生成0~1之间的随机数与0.5比较，返回-1或1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">arr.sort(randomsort);</span><br></pre></td></tr></table></figure>\n<h3 id=\"第十题\"><a href=\"#第十题\" class=\"headerlink\" title=\"第十题\"></a>第十题</h3><p>写出element.getElementsByClassName 的实现方法<br>我的思路：先获取页面下的所有元素，然后用<code>split</code>将传进来的多个<code>class</code>分割成数组，然后利两层循环找出符合条件的元素（个人觉得这种方法效率实在低下，就当是抛砖引玉吧，欢迎留言）<br>代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!<span class=\"built_in\">document</span>.getElementsByClassName) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementsByClassName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">className</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ele = [],</span><br><span class=\"line\">        tags = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"*\"</span>);</span><br><span class=\"line\">    className = className.split(<span class=\"regexp\">/\\s+/</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; tags.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; className.length; j++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果这个元素上有这个class且没在ele里面(主要防止多个class加在一个元素上推进去两次的情况)</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tags[i].className === className[j] &amp;&amp; ele.indexOf(tags[i]) === <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">                ele.push(tags[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ele;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"第十一题\"><a href=\"#第十一题\" class=\"headerlink\" title=\"第十一题\"></a>第十一题</h3><p>请写出代码输出结果<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!(<span class=\"string\">\"a\"</span> <span class=\"keyword\">in</span> <span class=\"built_in\">window</span>))&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(a);</span><br></pre></td></tr></table></figure></p>\n<p>这题主要考察了变量的声明提升，任何变量(es5中)的声明都会提升到当前作用域的顶端。所以这里的代码其实为：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(!(<span class=\"string\">\"a\"</span> <span class=\"keyword\">in</span> <span class=\"built_in\">window</span>))&#123;</span><br><span class=\"line\">    a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(a);</span><br></pre></td></tr></table></figure></p>\n<p>所以，在if语句执行前<code>a</code>就已经在<code>window</code>中了，所以这里会<code>atert undefined</code></p>\n<h3 id=\"第十二题\"><a href=\"#第十二题\" class=\"headerlink\" title=\"第十二题\"></a>第十二题</h3><p>请写出代码输出结果<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> handle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">        b = a + b;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tmp.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(handle(<span class=\"number\">4</span>)(<span class=\"number\">5</span>)(<span class=\"number\">6</span>));</span><br></pre></td></tr></table></figure></p>\n<p>我们来一步一步看：首先是<code>handle(4)</code>，到这里，程序开始运行，创建了一个<code>tmp</code>函数，同时把<code>tmp</code>函数的<code>toString</code>方法重写了，最后返回这个<code>tmp</code>函数。<br><strong>注意</strong>：<code>tmp</code>里的<code>a</code>不是传进去的4，不要把<code>tmp</code>的<code>a</code>和<code>handle</code>的<code>a</code>搞混了，所以这里传的4啥也没干。</p>\n<p>然后到第二步：<code>handle(4)(5)</code>，这里就是执行了<code>tmp</code>函数，这个时候<code>tmp</code>函数的<code>a</code>就是传进来的5，·<code>b</code>就是第一步函数执行的<code>b</code>即3(不懂为何是3的同学再去了解了解闭包吧)，最后这个<code>b</code>就等于8。</p>\n<p>第三部重复第二步<code>8+6</code>，最后<code>b</code>为14，<code>javascript</code>引擎最后自动调用了<code>toString</code>返回<code>b</code>，所以结果是14。</p>\n<h3 id=\"第十三题\"><a href=\"#第十三题\" class=\"headerlink\" title=\"第十三题\"></a>第十三题</h3><p>javscript表达式”[]==’’”的值是什么，为什么？</p>\n<p>这题考察对js<code>==</code>运算符的了解，我们知道<code>==</code>运算符如果两边值类型不一样会把它们转换为相同类型的值再来比较。这题左边是<code>object</code>类型，右边是<code>string</code>类型，所以会把左边的转化为<code>string</code>类型来比较，<code>[].toString()</code>就是<code>&#39;&#39;</code>所以最后结果是<code>true</code>。</p>\n<h3 id=\"第十四题\"><a href=\"#第十四题\" class=\"headerlink\" title=\"第十四题\"></a>第十四题</h3><p>Js生成下面html，点击每个li的时候弹出1,2,3……<br>//li onclick事件都能弹出当前被点击的index=?<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testUrl\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>index=0<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>index=1<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这题直接按照要求生成对应的html，再给<code>ul</code>绑定个事件，利用事件代理监听是谁被点了，然后输出它们的序号和对应的内容，没啥难度。我的代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ul=<span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"ul\"</span>),</span><br><span class=\"line\">    lis=[];</span><br><span class=\"line\">    ul.id=<span class=\"string\">\"testUrl\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>,li;i&lt;<span class=\"number\">2</span>;i++)&#123;</span><br><span class=\"line\">    li=<span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"li\"</span>);</span><br><span class=\"line\">    li.innerHTML=<span class=\"string\">\"index=\"</span>+i;</span><br><span class=\"line\">    ul.appendChild(li);</span><br><span class=\"line\">    lis.push(li);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ul.addEventListener(<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">    alert(lis.indexOf(e.target));</span><br><span class=\"line\">    alert(e.target.innerHTML)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild(ul);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"第十五题\"><a href=\"#第十五题\" class=\"headerlink\" title=\"第十五题\"></a>第十五题</h3><p>map方法是ES5中新增的，要求为ES5以下的环境增加个map方法</p>\n<p>个人认为只要对<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Compatibility\" target=\"_blank\" rel=\"noopener\">map</a>方法够了解，自然就能封装出来了。嘿嘿，不喜勿喷。给的链接虽然也有一个实现<code>map</code>的方法，但是用到了es5的<code>for in</code>不符合题目，所以我的代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!<span class=\"built_in\">Array</span>.prototype.map)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Array</span>.prototype.map=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback,context</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len=<span class=\"keyword\">this</span>.length,</span><br><span class=\"line\">        i=<span class=\"number\">0</span>,</span><br><span class=\"line\">        result=[];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> callback !== <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(callback + <span class=\"string\">\" is not a function\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    context=context||<span class=\"built_in\">window</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;i&lt;len;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>[i]!==<span class=\"literal\">undefined</span>?result.push(callback.call(context,<span class=\"keyword\">this</span>[i],i,<span class=\"keyword\">this</span>)):result.push(<span class=\"keyword\">this</span>[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>不过我的代码和标准的输出结果还是有点出入的。就是我不处理<code>undefined</code>和<code>null</code>，因为<code>this[i]!==undefined</code>，这两个值是会原样返回的。不过日常的一些需求还是能满足的。欢迎大家提建议哈。</p>\n<p>终于打完了，这期就这么多题，希望能对大家有帮助，同时如果有不对的地方请及时指正，欢迎留言。</p>\n<p>另外，欢迎大家来围观我封装的一个<a href=\"https://github.com/JayZangwill/lightings\" target=\"_blank\" rel=\"noopener\">ajax库 lightings</a>。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.jb51.net/article/87094.htm\" target=\"_blank\" rel=\"noopener\">JS随机打乱数组的方法小结</a><br><a href=\"https://www.zhihu.com/question/41493194\" target=\"_blank\" rel=\"noopener\">如何不使用loop循环，创建一个长度为100的数组，并且每个元素的值等于它的下标</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Compatibility\" target=\"_blank\" rel=\"noopener\">MDN map</a></p>"},{"title":"移动端适配","date":"2019-04-02T07:55:55.000Z","_content":"\n## 前言\n\n[原文](https://jayzangwill.github.io/blog/2019/04/02/flexible/) && [个人主页](https://www.jayzangwill.cn)\n\n[知乎](https://zhuanlan.zhihu.com/p/61697375) && [知乎专栏](https://zhuanlan.zhihu.com/jayzangwill)\n\n## 背景\n\n随着移动端的普及，以及手机尺寸越来越多，这就衍生了众多的适配方案，以下挑一些常见的适配方案进行探讨。\n\n本文默认读者已经对视口、物理像素、逻辑像素、css像素等移动端基本概念已经了解了。\n\n<!-- more -->\n\n## px + viewport适配\n\n这种适配方案原理比较简单：实际上就是通过动态设置`meta`标签的viewport让css中的1px等于设备的1px。\n\njs伪代码： \n\n```javascript\n    const scale = 1 / devicePixelRatio\n\n    head.appendChild(`<meta name='viewport' content='width=device-width, initial-scale=${scale}, maximum-scale=${scale}, minimum-scale=${scale}, user-scalable='no'>`)\n\n    body.setAttribute('data-dpr', devicePixelRatio)\n```\n\ncss伪代码\n```css\n[data-dpr='3'] {\n    property: value * 3\n    ...\n}\n\n[data-dpr='2'] {\n    property: value * 2\n    ...\n}\n```\n\n大家可以用不同手机进入[这里](https://www.jayzangwill.cn/demo/flexible1.html)，或者用浏览器模拟。\n\n**优点**：简单易于理解\n\n**缺点**：不能涵盖所有dpr的机型，即使能，也会造成代码臃肿。\n\n## rem布局\n\n首先我们需要知道\n\n1. `rem`的大小是基于页面根元素的`font-size`。\n2. `rem`的本质是等比缩放。\n\n例如：根元素的`font-size: 16px`则，`1rem`就等于`16px`；根元素的`font-size:32px`则，`1rem`就等于`32px`\n\n可以到[这里](https://www.jayzangwill.cn/demo/flexible2.html)来意会一下`rem`的本质是缩放\n\n这么一来，我们就可以利用这个特性动态设置根元素的`font-size`来达到我们想要的效果。\n\n### 基于设计图的rem布局\n\n通常我们拿到的设计图宽度的是750也就是基于iphone6/7/8的设计图，我们如果要想让1px像素等于设计图的1px该怎么做呢？\n\n其实很简单，直接让根元素的`font-size: 0.5px`即可（因为是2倍图，1px等于2实际像素，所以为`0.5px`）。\n\n那么问题来了：设计图一定会是750的，可是市面上机型那么多，屏幕不一定是750啊，怎么办？\n\n![表情](/blog/img/common/biaoqing1.png)\n\n前面我说过，**rem的本质是等比缩放**，让大于750或者小于750屏幕的手机等比缩放不就完事了？\n\njs伪代码：\n\n```javascript\nhtml.fontSize = clientWidth / 750\n```\n\n你以为这就完事了？其实事情并没有那么简单。\n\n![表情](/blog/img/common/yaoming.jpeg)\n\n别忘了，平时我们开发都是在chrome下开发的。chrome并不支持`font-size`小于12的字体，那怎么办呢？\n\n还能怎么办，为了方便计算，让`font-size`大于12呗，在以上基础上将结果放大100倍，然后写样式的时候再除以100：\n\n![表情](/blog/img/common/baobao.jpg)\n\njs伪代码：\n\n```javascript\nhtml.fontSize = clientWidth / 750 * 100\n```\n\n样式：\n\n```css\n.element {\n    width: 0.1rem; /* 实际到6/7/8上就是10px */\n}\n```\n\n### 基于屏幕百分比的rem布局\n\n假设一个页面有100份，每一份的宽度用`x`表示，则`x=屏幕宽度(即clientWidth)/100`，如果`font-size: x`，那我们不就实现了`1rem === 1%`屏幕宽度了吗？\n\n可是现实是残酷的，平时我们开发的时候写样式可不是按照屏幕宽度的百分之几来写的，而是根据设计给的标注来写的，而且设计通常给的设计图宽度是`750`的，那么如何转换呢？\n\n其实可以换种思维：如果得到这个元素的宽度占页面宽度的百分之几不就完事了吗？\n\n所以，`实际的rem = 元素标注长度 / 设计图宽度(这里是750) * 100`\n\n当然，这个转换过程可以让[postcss](https://www.npmjs.com/package/px2rem)去帮我们转换。\n\n### rem布局的优缺点\n\n**优点:** 易于理解，且兼容性好，能够很好地解决适配问题。\n\n**缺点：**\n\n1. 需要用js额外设置字体大小,强制设置根元素的字体大小，剥夺了用户的自由\n2. 在webview中，部分机型下用户设置系统默认字体大小会造成布局错乱\n\n## 小程序的黑魔法rpx布局\n\n做过小程序的都知道，小程序有个`wxss`，这玩意有个rpx的单位，[官方文档](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html)是这么介绍他的：`可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素`\n\n再看到下面那个转换表时我瞬间就不淡定了：\n\n![rpx](/blog/img/flexible/rpx.png)\n\n既是根据屏幕宽度自适应的又和上一章讲到的：基于设计图的rem布局的换算结果一样的，那它内部的实现原理其实和基于设计图的rem布局的原理差不多。\n\n只不过小程序内部处理了一下，让rpx直接能够根据屏幕宽度自适应，而不是像rem那样依赖于根元素的`font-size`\n\n## vw布局\n\n上一章基于屏幕百分比的rem布局小节中提到的`x`代表1份屏幕的宽度，在css中刚好有个单位代表这个`x`，即vw，至于vw是啥这里就不多说了，都9012年了，竟然还不知道vw是什么，[传送门](https://developer.mozilla.org/zh-CN/docs/Web/CSS/length)。\n\n那么问题来了，平时我们拿到的设计图都是基于`px`标记的，怎么将`px`转为`vw`呢？\n\nemmm，这里有个专门的插件专门做这件事[postcss-px-to-viewport](https://github.com/evrone/postcss-px-to-viewport)\n\n其代码中有这么一句：\n\n```javascript\ntoFixed((pixels / viewportSize * 100), opts.unitPrecision)\n```\n\n是不是和我们上面所说的`实际的rem = 元素标注长度 / 设计图宽度(这里是750) * 100`很像？\n\n这个插件会解析我们的css文件，将`px`转换为`vw`,至于为什么要这么转化，上面已经说过了，这里就不再赘述。\n\n`vw`完美地避开了`rem`的缺点，还继承了`rem`的优点，然而`vw`并不是完美的，由于`px`转`vw`是经过js计算的，多少都会优些精度损失，不过这是个小问题，不会丢失多少精度，除非你对精度要求特别高。\n\n## 参考\n\n[Rem布局的原理解析](https://yanhaijing.com/css/2017/09/29/principle-of-rem-layout/)\n[rem, vw, 还是...? 各凭本事的移动端适配方案](https://juejin.im/post/5bc07ebf6fb9a05d026119a9)","source":"_posts/flexible.md","raw":"---\ntitle: 移动端适配\ndate: 2019-04-02 15:55:55\ntags: [移动端,适配]\n---\n\n## 前言\n\n[原文](https://jayzangwill.github.io/blog/2019/04/02/flexible/) && [个人主页](https://www.jayzangwill.cn)\n\n[知乎](https://zhuanlan.zhihu.com/p/61697375) && [知乎专栏](https://zhuanlan.zhihu.com/jayzangwill)\n\n## 背景\n\n随着移动端的普及，以及手机尺寸越来越多，这就衍生了众多的适配方案，以下挑一些常见的适配方案进行探讨。\n\n本文默认读者已经对视口、物理像素、逻辑像素、css像素等移动端基本概念已经了解了。\n\n<!-- more -->\n\n## px + viewport适配\n\n这种适配方案原理比较简单：实际上就是通过动态设置`meta`标签的viewport让css中的1px等于设备的1px。\n\njs伪代码： \n\n```javascript\n    const scale = 1 / devicePixelRatio\n\n    head.appendChild(`<meta name='viewport' content='width=device-width, initial-scale=${scale}, maximum-scale=${scale}, minimum-scale=${scale}, user-scalable='no'>`)\n\n    body.setAttribute('data-dpr', devicePixelRatio)\n```\n\ncss伪代码\n```css\n[data-dpr='3'] {\n    property: value * 3\n    ...\n}\n\n[data-dpr='2'] {\n    property: value * 2\n    ...\n}\n```\n\n大家可以用不同手机进入[这里](https://www.jayzangwill.cn/demo/flexible1.html)，或者用浏览器模拟。\n\n**优点**：简单易于理解\n\n**缺点**：不能涵盖所有dpr的机型，即使能，也会造成代码臃肿。\n\n## rem布局\n\n首先我们需要知道\n\n1. `rem`的大小是基于页面根元素的`font-size`。\n2. `rem`的本质是等比缩放。\n\n例如：根元素的`font-size: 16px`则，`1rem`就等于`16px`；根元素的`font-size:32px`则，`1rem`就等于`32px`\n\n可以到[这里](https://www.jayzangwill.cn/demo/flexible2.html)来意会一下`rem`的本质是缩放\n\n这么一来，我们就可以利用这个特性动态设置根元素的`font-size`来达到我们想要的效果。\n\n### 基于设计图的rem布局\n\n通常我们拿到的设计图宽度的是750也就是基于iphone6/7/8的设计图，我们如果要想让1px像素等于设计图的1px该怎么做呢？\n\n其实很简单，直接让根元素的`font-size: 0.5px`即可（因为是2倍图，1px等于2实际像素，所以为`0.5px`）。\n\n那么问题来了：设计图一定会是750的，可是市面上机型那么多，屏幕不一定是750啊，怎么办？\n\n![表情](/blog/img/common/biaoqing1.png)\n\n前面我说过，**rem的本质是等比缩放**，让大于750或者小于750屏幕的手机等比缩放不就完事了？\n\njs伪代码：\n\n```javascript\nhtml.fontSize = clientWidth / 750\n```\n\n你以为这就完事了？其实事情并没有那么简单。\n\n![表情](/blog/img/common/yaoming.jpeg)\n\n别忘了，平时我们开发都是在chrome下开发的。chrome并不支持`font-size`小于12的字体，那怎么办呢？\n\n还能怎么办，为了方便计算，让`font-size`大于12呗，在以上基础上将结果放大100倍，然后写样式的时候再除以100：\n\n![表情](/blog/img/common/baobao.jpg)\n\njs伪代码：\n\n```javascript\nhtml.fontSize = clientWidth / 750 * 100\n```\n\n样式：\n\n```css\n.element {\n    width: 0.1rem; /* 实际到6/7/8上就是10px */\n}\n```\n\n### 基于屏幕百分比的rem布局\n\n假设一个页面有100份，每一份的宽度用`x`表示，则`x=屏幕宽度(即clientWidth)/100`，如果`font-size: x`，那我们不就实现了`1rem === 1%`屏幕宽度了吗？\n\n可是现实是残酷的，平时我们开发的时候写样式可不是按照屏幕宽度的百分之几来写的，而是根据设计给的标注来写的，而且设计通常给的设计图宽度是`750`的，那么如何转换呢？\n\n其实可以换种思维：如果得到这个元素的宽度占页面宽度的百分之几不就完事了吗？\n\n所以，`实际的rem = 元素标注长度 / 设计图宽度(这里是750) * 100`\n\n当然，这个转换过程可以让[postcss](https://www.npmjs.com/package/px2rem)去帮我们转换。\n\n### rem布局的优缺点\n\n**优点:** 易于理解，且兼容性好，能够很好地解决适配问题。\n\n**缺点：**\n\n1. 需要用js额外设置字体大小,强制设置根元素的字体大小，剥夺了用户的自由\n2. 在webview中，部分机型下用户设置系统默认字体大小会造成布局错乱\n\n## 小程序的黑魔法rpx布局\n\n做过小程序的都知道，小程序有个`wxss`，这玩意有个rpx的单位，[官方文档](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html)是这么介绍他的：`可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素`\n\n再看到下面那个转换表时我瞬间就不淡定了：\n\n![rpx](/blog/img/flexible/rpx.png)\n\n既是根据屏幕宽度自适应的又和上一章讲到的：基于设计图的rem布局的换算结果一样的，那它内部的实现原理其实和基于设计图的rem布局的原理差不多。\n\n只不过小程序内部处理了一下，让rpx直接能够根据屏幕宽度自适应，而不是像rem那样依赖于根元素的`font-size`\n\n## vw布局\n\n上一章基于屏幕百分比的rem布局小节中提到的`x`代表1份屏幕的宽度，在css中刚好有个单位代表这个`x`，即vw，至于vw是啥这里就不多说了，都9012年了，竟然还不知道vw是什么，[传送门](https://developer.mozilla.org/zh-CN/docs/Web/CSS/length)。\n\n那么问题来了，平时我们拿到的设计图都是基于`px`标记的，怎么将`px`转为`vw`呢？\n\nemmm，这里有个专门的插件专门做这件事[postcss-px-to-viewport](https://github.com/evrone/postcss-px-to-viewport)\n\n其代码中有这么一句：\n\n```javascript\ntoFixed((pixels / viewportSize * 100), opts.unitPrecision)\n```\n\n是不是和我们上面所说的`实际的rem = 元素标注长度 / 设计图宽度(这里是750) * 100`很像？\n\n这个插件会解析我们的css文件，将`px`转换为`vw`,至于为什么要这么转化，上面已经说过了，这里就不再赘述。\n\n`vw`完美地避开了`rem`的缺点，还继承了`rem`的优点，然而`vw`并不是完美的，由于`px`转`vw`是经过js计算的，多少都会优些精度损失，不过这是个小问题，不会丢失多少精度，除非你对精度要求特别高。\n\n## 参考\n\n[Rem布局的原理解析](https://yanhaijing.com/css/2017/09/29/principle-of-rem-layout/)\n[rem, vw, 还是...? 各凭本事的移动端适配方案](https://juejin.im/post/5bc07ebf6fb9a05d026119a9)","slug":"flexible","published":1,"updated":"2020-04-07T03:29:17.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8qzc34p000i2cl6kxbxx2vo","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><a href=\"https://jayzangwill.github.io/blog/2019/04/02/flexible/\">原文</a> &amp;&amp; <a href=\"https://www.jayzangwill.cn\" target=\"_blank\" rel=\"noopener\">个人主页</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/61697375\" target=\"_blank\" rel=\"noopener\">知乎</a> &amp;&amp; <a href=\"https://zhuanlan.zhihu.com/jayzangwill\" target=\"_blank\" rel=\"noopener\">知乎专栏</a></p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>随着移动端的普及，以及手机尺寸越来越多，这就衍生了众多的适配方案，以下挑一些常见的适配方案进行探讨。</p>\n<p>本文默认读者已经对视口、物理像素、逻辑像素、css像素等移动端基本概念已经了解了。</p>\n<a id=\"more\"></a>\n<h2 id=\"px-viewport适配\"><a href=\"#px-viewport适配\" class=\"headerlink\" title=\"px + viewport适配\"></a>px + viewport适配</h2><p>这种适配方案原理比较简单：实际上就是通过动态设置<code>meta</code>标签的viewport让css中的1px等于设备的1px。</p>\n<p>js伪代码： </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> scale = <span class=\"number\">1</span> / devicePixelRatio</span><br><span class=\"line\"></span><br><span class=\"line\">head.appendChild(<span class=\"string\">`&lt;meta name='viewport' content='width=device-width, initial-scale=<span class=\"subst\">$&#123;scale&#125;</span>, maximum-scale=<span class=\"subst\">$&#123;scale&#125;</span>, minimum-scale=<span class=\"subst\">$&#123;scale&#125;</span>, user-scalable='no'&gt;`</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">body.setAttribute(<span class=\"string\">'data-dpr'</span>, devicePixelRatio)</span><br></pre></td></tr></table></figure>\n<p>css伪代码<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-attr\">[data-dpr=<span class=\"string\">'3'</span>]</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">property</span>: value * <span class=\"number\">3</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-attr\">[data-dpr=<span class=\"string\">'2'</span>]</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">property</span>: value * <span class=\"number\">2</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>大家可以用不同手机进入<a href=\"https://www.jayzangwill.cn/demo/flexible1.html\" target=\"_blank\" rel=\"noopener\">这里</a>，或者用浏览器模拟。</p>\n<p><strong>优点</strong>：简单易于理解</p>\n<p><strong>缺点</strong>：不能涵盖所有dpr的机型，即使能，也会造成代码臃肿。</p>\n<h2 id=\"rem布局\"><a href=\"#rem布局\" class=\"headerlink\" title=\"rem布局\"></a>rem布局</h2><p>首先我们需要知道</p>\n<ol>\n<li><code>rem</code>的大小是基于页面根元素的<code>font-size</code>。</li>\n<li><code>rem</code>的本质是等比缩放。</li>\n</ol>\n<p>例如：根元素的<code>font-size: 16px</code>则，<code>1rem</code>就等于<code>16px</code>；根元素的<code>font-size:32px</code>则，<code>1rem</code>就等于<code>32px</code></p>\n<p>可以到<a href=\"https://www.jayzangwill.cn/demo/flexible2.html\" target=\"_blank\" rel=\"noopener\">这里</a>来意会一下<code>rem</code>的本质是缩放</p>\n<p>这么一来，我们就可以利用这个特性动态设置根元素的<code>font-size</code>来达到我们想要的效果。</p>\n<h3 id=\"基于设计图的rem布局\"><a href=\"#基于设计图的rem布局\" class=\"headerlink\" title=\"基于设计图的rem布局\"></a>基于设计图的rem布局</h3><p>通常我们拿到的设计图宽度的是750也就是基于iphone6/7/8的设计图，我们如果要想让1px像素等于设计图的1px该怎么做呢？</p>\n<p>其实很简单，直接让根元素的<code>font-size: 0.5px</code>即可（因为是2倍图，1px等于2实际像素，所以为<code>0.5px</code>）。</p>\n<p>那么问题来了：设计图一定会是750的，可是市面上机型那么多，屏幕不一定是750啊，怎么办？</p>\n<p><img src=\"/blog/img/common/biaoqing1.png\" alt=\"表情\"></p>\n<p>前面我说过，<strong>rem的本质是等比缩放</strong>，让大于750或者小于750屏幕的手机等比缩放不就完事了？</p>\n<p>js伪代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html.fontSize = clientWidth / <span class=\"number\">750</span></span><br></pre></td></tr></table></figure>\n<p>你以为这就完事了？其实事情并没有那么简单。</p>\n<p><img src=\"/blog/img/common/yaoming.jpeg\" alt=\"表情\"></p>\n<p>别忘了，平时我们开发都是在chrome下开发的。chrome并不支持<code>font-size</code>小于12的字体，那怎么办呢？</p>\n<p>还能怎么办，为了方便计算，让<code>font-size</code>大于12呗，在以上基础上将结果放大100倍，然后写样式的时候再除以100：</p>\n<p><img src=\"/blog/img/common/baobao.jpg\" alt=\"表情\"></p>\n<p>js伪代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html.fontSize = clientWidth / <span class=\"number\">750</span> * <span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n<p>样式：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.element</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">0.1rem</span>; <span class=\"comment\">/* 实际到6/7/8上就是10px */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"基于屏幕百分比的rem布局\"><a href=\"#基于屏幕百分比的rem布局\" class=\"headerlink\" title=\"基于屏幕百分比的rem布局\"></a>基于屏幕百分比的rem布局</h3><p>假设一个页面有100份，每一份的宽度用<code>x</code>表示，则<code>x=屏幕宽度(即clientWidth)/100</code>，如果<code>font-size: x</code>，那我们不就实现了<code>1rem === 1%</code>屏幕宽度了吗？</p>\n<p>可是现实是残酷的，平时我们开发的时候写样式可不是按照屏幕宽度的百分之几来写的，而是根据设计给的标注来写的，而且设计通常给的设计图宽度是<code>750</code>的，那么如何转换呢？</p>\n<p>其实可以换种思维：如果得到这个元素的宽度占页面宽度的百分之几不就完事了吗？</p>\n<p>所以，<code>实际的rem = 元素标注长度 / 设计图宽度(这里是750) * 100</code></p>\n<p>当然，这个转换过程可以让<a href=\"https://www.npmjs.com/package/px2rem\" target=\"_blank\" rel=\"noopener\">postcss</a>去帮我们转换。</p>\n<h3 id=\"rem布局的优缺点\"><a href=\"#rem布局的优缺点\" class=\"headerlink\" title=\"rem布局的优缺点\"></a>rem布局的优缺点</h3><p><strong>优点:</strong> 易于理解，且兼容性好，能够很好地解决适配问题。</p>\n<p><strong>缺点：</strong></p>\n<ol>\n<li>需要用js额外设置字体大小,强制设置根元素的字体大小，剥夺了用户的自由</li>\n<li>在webview中，部分机型下用户设置系统默认字体大小会造成布局错乱</li>\n</ol>\n<h2 id=\"小程序的黑魔法rpx布局\"><a href=\"#小程序的黑魔法rpx布局\" class=\"headerlink\" title=\"小程序的黑魔法rpx布局\"></a>小程序的黑魔法rpx布局</h2><p>做过小程序的都知道，小程序有个<code>wxss</code>，这玩意有个rpx的单位，<a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>是这么介绍他的：<code>可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素</code></p>\n<p>再看到下面那个转换表时我瞬间就不淡定了：</p>\n<p><img src=\"/blog/img/flexible/rpx.png\" alt=\"rpx\"></p>\n<p>既是根据屏幕宽度自适应的又和上一章讲到的：基于设计图的rem布局的换算结果一样的，那它内部的实现原理其实和基于设计图的rem布局的原理差不多。</p>\n<p>只不过小程序内部处理了一下，让rpx直接能够根据屏幕宽度自适应，而不是像rem那样依赖于根元素的<code>font-size</code></p>\n<h2 id=\"vw布局\"><a href=\"#vw布局\" class=\"headerlink\" title=\"vw布局\"></a>vw布局</h2><p>上一章基于屏幕百分比的rem布局小节中提到的<code>x</code>代表1份屏幕的宽度，在css中刚好有个单位代表这个<code>x</code>，即vw，至于vw是啥这里就不多说了，都9012年了，竟然还不知道vw是什么，<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/length\" target=\"_blank\" rel=\"noopener\">传送门</a>。</p>\n<p>那么问题来了，平时我们拿到的设计图都是基于<code>px</code>标记的，怎么将<code>px</code>转为<code>vw</code>呢？</p>\n<p>emmm，这里有个专门的插件专门做这件事<a href=\"https://github.com/evrone/postcss-px-to-viewport\" target=\"_blank\" rel=\"noopener\">postcss-px-to-viewport</a></p>\n<p>其代码中有这么一句：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">toFixed((pixels / viewportSize * <span class=\"number\">100</span>), opts.unitPrecision)</span><br></pre></td></tr></table></figure>\n<p>是不是和我们上面所说的<code>实际的rem = 元素标注长度 / 设计图宽度(这里是750) * 100</code>很像？</p>\n<p>这个插件会解析我们的css文件，将<code>px</code>转换为<code>vw</code>,至于为什么要这么转化，上面已经说过了，这里就不再赘述。</p>\n<p><code>vw</code>完美地避开了<code>rem</code>的缺点，还继承了<code>rem</code>的优点，然而<code>vw</code>并不是完美的，由于<code>px</code>转<code>vw</code>是经过js计算的，多少都会优些精度损失，不过这是个小问题，不会丢失多少精度，除非你对精度要求特别高。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://yanhaijing.com/css/2017/09/29/principle-of-rem-layout/\" target=\"_blank\" rel=\"noopener\">Rem布局的原理解析</a><br><a href=\"https://juejin.im/post/5bc07ebf6fb9a05d026119a9\" target=\"_blank\" rel=\"noopener\">rem, vw, 还是…? 各凭本事的移动端适配方案</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><a href=\"https://jayzangwill.github.io/blog/2019/04/02/flexible/\">原文</a> &amp;&amp; <a href=\"https://www.jayzangwill.cn\" target=\"_blank\" rel=\"noopener\">个人主页</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/61697375\" target=\"_blank\" rel=\"noopener\">知乎</a> &amp;&amp; <a href=\"https://zhuanlan.zhihu.com/jayzangwill\" target=\"_blank\" rel=\"noopener\">知乎专栏</a></p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>随着移动端的普及，以及手机尺寸越来越多，这就衍生了众多的适配方案，以下挑一些常见的适配方案进行探讨。</p>\n<p>本文默认读者已经对视口、物理像素、逻辑像素、css像素等移动端基本概念已经了解了。</p>","more":"<h2 id=\"px-viewport适配\"><a href=\"#px-viewport适配\" class=\"headerlink\" title=\"px + viewport适配\"></a>px + viewport适配</h2><p>这种适配方案原理比较简单：实际上就是通过动态设置<code>meta</code>标签的viewport让css中的1px等于设备的1px。</p>\n<p>js伪代码： </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> scale = <span class=\"number\">1</span> / devicePixelRatio</span><br><span class=\"line\"></span><br><span class=\"line\">head.appendChild(<span class=\"string\">`&lt;meta name='viewport' content='width=device-width, initial-scale=<span class=\"subst\">$&#123;scale&#125;</span>, maximum-scale=<span class=\"subst\">$&#123;scale&#125;</span>, minimum-scale=<span class=\"subst\">$&#123;scale&#125;</span>, user-scalable='no'&gt;`</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">body.setAttribute(<span class=\"string\">'data-dpr'</span>, devicePixelRatio)</span><br></pre></td></tr></table></figure>\n<p>css伪代码<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-attr\">[data-dpr=<span class=\"string\">'3'</span>]</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">property</span>: value * <span class=\"number\">3</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-attr\">[data-dpr=<span class=\"string\">'2'</span>]</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">property</span>: value * <span class=\"number\">2</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>大家可以用不同手机进入<a href=\"https://www.jayzangwill.cn/demo/flexible1.html\" target=\"_blank\" rel=\"noopener\">这里</a>，或者用浏览器模拟。</p>\n<p><strong>优点</strong>：简单易于理解</p>\n<p><strong>缺点</strong>：不能涵盖所有dpr的机型，即使能，也会造成代码臃肿。</p>\n<h2 id=\"rem布局\"><a href=\"#rem布局\" class=\"headerlink\" title=\"rem布局\"></a>rem布局</h2><p>首先我们需要知道</p>\n<ol>\n<li><code>rem</code>的大小是基于页面根元素的<code>font-size</code>。</li>\n<li><code>rem</code>的本质是等比缩放。</li>\n</ol>\n<p>例如：根元素的<code>font-size: 16px</code>则，<code>1rem</code>就等于<code>16px</code>；根元素的<code>font-size:32px</code>则，<code>1rem</code>就等于<code>32px</code></p>\n<p>可以到<a href=\"https://www.jayzangwill.cn/demo/flexible2.html\" target=\"_blank\" rel=\"noopener\">这里</a>来意会一下<code>rem</code>的本质是缩放</p>\n<p>这么一来，我们就可以利用这个特性动态设置根元素的<code>font-size</code>来达到我们想要的效果。</p>\n<h3 id=\"基于设计图的rem布局\"><a href=\"#基于设计图的rem布局\" class=\"headerlink\" title=\"基于设计图的rem布局\"></a>基于设计图的rem布局</h3><p>通常我们拿到的设计图宽度的是750也就是基于iphone6/7/8的设计图，我们如果要想让1px像素等于设计图的1px该怎么做呢？</p>\n<p>其实很简单，直接让根元素的<code>font-size: 0.5px</code>即可（因为是2倍图，1px等于2实际像素，所以为<code>0.5px</code>）。</p>\n<p>那么问题来了：设计图一定会是750的，可是市面上机型那么多，屏幕不一定是750啊，怎么办？</p>\n<p><img src=\"/blog/img/common/biaoqing1.png\" alt=\"表情\"></p>\n<p>前面我说过，<strong>rem的本质是等比缩放</strong>，让大于750或者小于750屏幕的手机等比缩放不就完事了？</p>\n<p>js伪代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html.fontSize = clientWidth / <span class=\"number\">750</span></span><br></pre></td></tr></table></figure>\n<p>你以为这就完事了？其实事情并没有那么简单。</p>\n<p><img src=\"/blog/img/common/yaoming.jpeg\" alt=\"表情\"></p>\n<p>别忘了，平时我们开发都是在chrome下开发的。chrome并不支持<code>font-size</code>小于12的字体，那怎么办呢？</p>\n<p>还能怎么办，为了方便计算，让<code>font-size</code>大于12呗，在以上基础上将结果放大100倍，然后写样式的时候再除以100：</p>\n<p><img src=\"/blog/img/common/baobao.jpg\" alt=\"表情\"></p>\n<p>js伪代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html.fontSize = clientWidth / <span class=\"number\">750</span> * <span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n<p>样式：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.element</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">0.1rem</span>; <span class=\"comment\">/* 实际到6/7/8上就是10px */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"基于屏幕百分比的rem布局\"><a href=\"#基于屏幕百分比的rem布局\" class=\"headerlink\" title=\"基于屏幕百分比的rem布局\"></a>基于屏幕百分比的rem布局</h3><p>假设一个页面有100份，每一份的宽度用<code>x</code>表示，则<code>x=屏幕宽度(即clientWidth)/100</code>，如果<code>font-size: x</code>，那我们不就实现了<code>1rem === 1%</code>屏幕宽度了吗？</p>\n<p>可是现实是残酷的，平时我们开发的时候写样式可不是按照屏幕宽度的百分之几来写的，而是根据设计给的标注来写的，而且设计通常给的设计图宽度是<code>750</code>的，那么如何转换呢？</p>\n<p>其实可以换种思维：如果得到这个元素的宽度占页面宽度的百分之几不就完事了吗？</p>\n<p>所以，<code>实际的rem = 元素标注长度 / 设计图宽度(这里是750) * 100</code></p>\n<p>当然，这个转换过程可以让<a href=\"https://www.npmjs.com/package/px2rem\" target=\"_blank\" rel=\"noopener\">postcss</a>去帮我们转换。</p>\n<h3 id=\"rem布局的优缺点\"><a href=\"#rem布局的优缺点\" class=\"headerlink\" title=\"rem布局的优缺点\"></a>rem布局的优缺点</h3><p><strong>优点:</strong> 易于理解，且兼容性好，能够很好地解决适配问题。</p>\n<p><strong>缺点：</strong></p>\n<ol>\n<li>需要用js额外设置字体大小,强制设置根元素的字体大小，剥夺了用户的自由</li>\n<li>在webview中，部分机型下用户设置系统默认字体大小会造成布局错乱</li>\n</ol>\n<h2 id=\"小程序的黑魔法rpx布局\"><a href=\"#小程序的黑魔法rpx布局\" class=\"headerlink\" title=\"小程序的黑魔法rpx布局\"></a>小程序的黑魔法rpx布局</h2><p>做过小程序的都知道，小程序有个<code>wxss</code>，这玩意有个rpx的单位，<a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>是这么介绍他的：<code>可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素</code></p>\n<p>再看到下面那个转换表时我瞬间就不淡定了：</p>\n<p><img src=\"/blog/img/flexible/rpx.png\" alt=\"rpx\"></p>\n<p>既是根据屏幕宽度自适应的又和上一章讲到的：基于设计图的rem布局的换算结果一样的，那它内部的实现原理其实和基于设计图的rem布局的原理差不多。</p>\n<p>只不过小程序内部处理了一下，让rpx直接能够根据屏幕宽度自适应，而不是像rem那样依赖于根元素的<code>font-size</code></p>\n<h2 id=\"vw布局\"><a href=\"#vw布局\" class=\"headerlink\" title=\"vw布局\"></a>vw布局</h2><p>上一章基于屏幕百分比的rem布局小节中提到的<code>x</code>代表1份屏幕的宽度，在css中刚好有个单位代表这个<code>x</code>，即vw，至于vw是啥这里就不多说了，都9012年了，竟然还不知道vw是什么，<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/length\" target=\"_blank\" rel=\"noopener\">传送门</a>。</p>\n<p>那么问题来了，平时我们拿到的设计图都是基于<code>px</code>标记的，怎么将<code>px</code>转为<code>vw</code>呢？</p>\n<p>emmm，这里有个专门的插件专门做这件事<a href=\"https://github.com/evrone/postcss-px-to-viewport\" target=\"_blank\" rel=\"noopener\">postcss-px-to-viewport</a></p>\n<p>其代码中有这么一句：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">toFixed((pixels / viewportSize * <span class=\"number\">100</span>), opts.unitPrecision)</span><br></pre></td></tr></table></figure>\n<p>是不是和我们上面所说的<code>实际的rem = 元素标注长度 / 设计图宽度(这里是750) * 100</code>很像？</p>\n<p>这个插件会解析我们的css文件，将<code>px</code>转换为<code>vw</code>,至于为什么要这么转化，上面已经说过了，这里就不再赘述。</p>\n<p><code>vw</code>完美地避开了<code>rem</code>的缺点，还继承了<code>rem</code>的优点，然而<code>vw</code>并不是完美的，由于<code>px</code>转<code>vw</code>是经过js计算的，多少都会优些精度损失，不过这是个小问题，不会丢失多少精度，除非你对精度要求特别高。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://yanhaijing.com/css/2017/09/29/principle-of-rem-layout/\" target=\"_blank\" rel=\"noopener\">Rem布局的原理解析</a><br><a href=\"https://juejin.im/post/5bc07ebf6fb9a05d026119a9\" target=\"_blank\" rel=\"noopener\">rem, vw, 还是…? 各凭本事的移动端适配方案</a></p>"},{"title":"扒一扒浏览器缓存机制","date":"2019-02-07T12:05:41.000Z","_content":"\n## 前言\n\n[原文](https://jayzangwill.github.io/blog/2019/02/07/cache/) && [个人主页](https://www.jayzangwill.cn)\n\n[知乎](https://zhuanlan.zhihu.com/p/56943873) && [知乎专栏](https://zhuanlan.zhihu.com/jayzangwill)\n\n## 背景\n\n之所以会写这篇文章，是因为之前在工作中发生的一次微信浏览器莫名缓存的问题。这个问题的源头是因为万恶的微信浏览器将页面的入口文件给缓存起来了（单页面应用），因此，通过写下这篇文章来理一理浏览器的缓存机制。\n\n详细的解决方案可以看[这里](https://www.jianshu.com/p/cce9511c0914)\n\n<!-- more -->\n\n## 浏览器的缓存机制\n\n既然浏览器需要缓存资源，就得知道资源啥时候更新。要想知道资源啥时候更新，这就得引出两个概念：**强制缓存**和**协商缓存**\n\n### 强制缓存\n\n当命中强制缓存后，浏览器不会去请求服务器，而是直接使用本地缓存的资源，并返回状态码`200(缓存来源)`。是否命中强制缓存是由响应头中的`expires`和`Cache-Control`控制（浏览器的第一个请求不会命中强制缓存，Service Worker除外，感兴趣的同学可以用node试一试）。\n\n响应头如图：![响应头](/blog/img/cache/header_1.png)\n\n当命中强制缓存的时候返回的状态码：![强制缓存状态码](/blog/img/cache/code_200.png)\n\n#### expires\n\n`expires`是http1.0的标准，表明服务器的过期时间，是格林威治时间，当请求的时候客户端的时间超过`expires`标识的时间时，就会去请求服务器。\n\n可以看到，**当请求的时候客户端的时间超过`expires`标识的时间时，就会去请求服务器**，但是这个其实是存在问题的，当用户的系统时间改到这个标识的时间之后，就永远不会命中这个强制缓存。所以`Cache-Control`就诞生了。\n\n#### Cache-Control\n\n`Cache-Control`是http1.1的产物，他可以看成是`expries`的补充。\n\n介绍一些`Cache-Control`常用的值：\n\n1. max-age: 设置缓存的最大的有效时间，单位为秒（s）。max-age会覆盖掉expires。\n2. s-maxage: 设置代理服务器缓存的最大的有效时间，单位为秒（s）。s-maxage会覆盖掉max-age。\n3. public: 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存。\n4. private: 只有发起请求的浏览器可进行缓存。\n5. no-cache: 虽然字面意义是“不要缓存”。但它实际上的机制是，仍然对资源使用缓存，但每一次在使用缓存之前必须向服务器对缓存资源进行验证。\n6. no-store: 所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存。\n7. must-revalidate: 如果你配置了max-age信息，当缓存资源仍然新鲜（小于max-age）时使用缓存，否则需要对资源进行验证\n\n所以判断缓存是否过期步骤是：\n\n1. 查看是否有cache-control的max-age / s-maxage，如果有，则用服务器时间date值 + max-age/s-maxage 的秒数计算出新的过期时间，将当前时间与过期时间进行比较，判断是否过期。如果没有则用expires 作为过期时间比较。\n\n![步骤图](/blog/img/cache/step.png)\n\n\n### 小结\n\n浏览器的强制缓存由响应头中的`expires`和`Cache-Control`控制。当`Cache-Control`中有max-age/s-maxage时则用服务器时间date值 + max-age/s-maxage 的秒数计算出新的过期时间；否则用`expires`作为资源的过期时间。\n\n#### 协商缓存\n\n顾名思义，协商缓存就是得与服务器商量一下是否使用缓存，命中协商缓存的话会返回状态`304`。\n\n协商缓存由响应头中的`Last-Modified`和`ETag`还有请求头中的`If-Modified-Since`和`If-None-Match`控制。\n\n如图：![响应头和请求头](/blog/img/cache/header_2.png)\n\n那么这四个东西是什么玩意呢？接下来就由我细细道来：\n\n**Last-Modified**：标示这个响应资源的最后修改时间。\n\n**If-Modified-Since**：当资源过期时（使用`Cache-Control`标识的max-age/s-maxage），发现资源具有`Last-Msodified`声明，则向服务器请求时带上头 `If-Modified-Since`（即响应头中的`Last-Modified`值），表示请求时间。这个时候服务器收到请求后发现有头`If-Modified-Since`则与**被请求资源**的最后修改时间进行比对。若最后修改时间较新，说明资源有被改动过，将新资源返回并返回状态`200`，否则返回`304`表示资源没被更新使用缓存即可。\n\n**Etag**：服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。例如在Apache中，`ETag`的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。\n\n**If-None-Match**：当资源过期时（使用Cache-Control标识的max-age/s-maxage），发现资源具有`Etage`声明，则向服务器请求时带上头`If-None-Match`（即响应头中`Etag`的值）。服务器收到请求后发现有头`If-None-Match` 则与被请求资源的相应校验串进行比对，决定返回200或304（**注意：服务器会优先验证If-None-Match**）。\n\nemm，文字看起来文绉绉的，那就上图吧：\n\n如图：![步骤图](/blog/img/cache/step_2.png)\n\n**问**：咦？这个`Last-Modified`和`If-Modified-Since`貌似看起来够用了啊，为啥还要有`Etag`和`If-None-Match`啊？\n\n**答**：\n\n1. `Last-Modified`标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间\n2. 如果某些文件会被定期生成，当有时内容并没有任何变化，但`Last-Modified`却改变了，导致文件没法使用缓存\n3. 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形\n\n### 小结\n\n当浏览器没命中强制缓存时，会和服务器协商是否使用缓存，这个就是**协商缓存**，协商缓存由响应头中的`Last-Modified`和`ETag`还有请求头中的`If-Modified-Since`和`If-None-Match`控制。命中协商缓存的资源，服务器会返回`304`\n\n## CDN缓存\n\n### 什么是CDN\n\nCDN即Content Delivery network，内容分发网络。CDN可以理解为一个火车票的代售点，用户在浏览网站的时候，CDN会选择一个离用户最近的CDN边缘节点来响应用户的请求。例如，上海用户想要访问我[www.jayzangwill.cn](www.jayzangwill.cn)上的一个资源，这个时候，刚好我在上海有台CND服务器，用户的请求直接会被打到这台上海的CDN服务器上，而不会跑到北京深圳的服务器上去请求我的资源，这样就加快了服务器的相应时间。\n\n### CDN的原理\n\n在用户和服务器之间增加cache层，通过接管DNS,将用户的请求引导到cache上获得服务器的资源。\n\n### CDN缓存策略\n\n和浏览器缓存机制类似，CND也有一套类似的缓存策略，这套缓存策略会决定CDN服务器什么时候去更新自己的资源。\n\n上文所说的`Cache-Control`的`max-age`头可以告知文件在浏览器的缓存时间，在`max-age`指定的时间内，浏览器会直接使用本地缓存，而不会请求服务器，CDN采取了类似的机制，你只要把CDN节点看成浏览器，源服务器看成浏览器需要请求的服务器即可，此时，源服务器的`max-age`头决定了资源在CDN节点本地缓存的时间，有一点差别的是，CDN规定了一个自定义协议，也就是上文说的`s-maxage`，若源站该`s-maxage`存在，会优先使用`s-maxage`作为CDN的缓存时间。\n\n如下图为CDN的缓存机制示意图：\n\n![CND缓存示意图](/blog/img/cache/cdn_step.png)\n\n## 强制缓存的几个位置\n\n总的来说就分为四个位置：\n\n1. Memory Cache\n2. Disk Cache\n3. Push Cache\n4. [Service Worker](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers)\n\n### Memory Cache\n\n存在内存中的缓存，一般是页面刷新后，浏览器从内存中获取缓存，从内存中获取缓存的速度要比从硬盘中获取的速度要快，因此在刷新的时候会从内存中获取缓存比较方便。当页面关闭后，内存就会释放。\n\n### Disk Cache\n\n存在硬盘中的缓存，当重新打开页面后，会从硬盘中获取缓存。它与内存缓存最大的区别是：硬盘缓存不会在页面关闭后被清除，当页面关闭后再进入页面读取的就是硬盘缓存。\n\n### Push Cache\n\n“推送缓存”是针对HTTP/2标准下的推送资源设定的。推送缓存是session级别的，如果用户的session结束则资源被释放；即使URL相同但处于不同的session中也不会发生匹配。推送缓存的存储时间较短，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。更多详情可参阅[HTTP/2 push is tougher than I thought](https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/)\n\n以下我列出几点：\n\n1. 几乎所有的资源都能被推送，并且能够被缓存。测试过程是作者在推送资源之后尝试用fetch()、XMLHttpRequest、link、script、iframe获取推送的资源。Edge和Safari浏览器支持相对比较差\n2. no-cache和no-store资源也能被推送\n3. Push Cache是最后一道缓存机制（之前会经过Service Worker、Memory Cache、HTTP Cache）\n4. 如果连接被关闭则Push Cache被释放\n5. 多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。\n6. 一旦Push Cache中的资源被使用即被移除\n7. 如果Push Cache或者HTTP Cache已经存在被推送的资源，则有可能浏览器拒绝推送\n8. 你可以为其他域名推送资源\n\n### [Service Worker](https://developers.google.com/web/fundamentals/primers/service-workers/)\n\n关于service worker是什么大家可以看连接，链接需要特殊技术才能访问，访问不了的可以看以下我的截图：\n\n![service介绍](/blog/img/cache/servicework.png)\n\n总的来说Service Worker就类似于一个中间人，所有浏览器发出的请求都会被Service Worker拦截到，并被Service Worker处理，从而决定资源都是从哪获取。\n\n另外还需要注意的是Service Worker依赖https或者localhost环境\n\n所有被Service Worker缓存的资源都能在控制台的Application下的Cache Tab里的Cache Storage看到：\n\n![application](/blog/img/cache/application.png)\n\n以下代码展示了一个Service Worker的使用示例（如果不了解sw的同学建议阅读[链接](https://developers.google.com/web/fundamentals/primers/service-workers/)中的代码示例再继续）\n\n```javascript\nnavigator.serviceWorker && navigator.serviceWorker.register('/sw.js', { scope: '/' })\n\n// 以下是sw.js中的代码\nvar CACHE_KEY = 'v1.' + (new Date().getMonth()) + '.0';\nvar IS_ENV_TEST = /^(localhost)|(test-)/.test(self.location.host);\nvar CACHE_TYPES = /(\\/index(#\\/)?)|(\\.(png|jpe?g|gif|webp|svg|mp3|wav|aac|mp4|mov|m4v|mkv|wma|wmv|rm|3gp|rmvb|avi|flv|js|css))$/;\nself.addEventListener('install', function(event) {\n    self.skipWaiting();\n    event.waitUntil(caches.keys().then(function(cacheNames) {\n        return Promise.all(cacheNames.map(function(cacheName) {\n            if (cacheName !== CACHE_KEY) {\n                return caches.delete(cacheName)\n            }\n        }))\n    }))\n});\n\nself.addEventListener('fetch', function(event) {\n    var method = event.request.method;\n    var url = event.request.url;\n    if (method !== 'GET' || !CACHE_TYPES.test(url) || /sw\\.js$/.test(url)) {\n        return\n    }\n    event.respondWith(caches.match(event.request).then(function(cacheRes) {\n        if (!navigator.onLine) {\n            return cacheRes\n        }\n        if (!cacheRes || /\\/index(#\\/)?$/.test(url) || (IS_ENV_TEST && /\\.(js|css)$/.test(url))) {\n            return fetch(event.request).then(function(fetchResponse) {\n                caches.open(CACHE_KEY).then(function(cache) {\n                    cache.put(event.request, fetchResponse)\n                });\n                return fetchResponse.clone()\n            })\n        }\n        return cacheRes\n    }))\n});\n\n```\n\n#### 命中强制缓存时，该从哪拿缓存\n\n对于这个问题，网上有不同的解释，同时不同的浏览器也有不同的缓存机制，所以这个问题我决定做个试验，以下是我的实验结果（截图均为chrome浏览器）：\n\n没有Service Worker时：\n![没有Service Worker](/blog/img/cache/weizhi_1.gif)\n\n有Service Worker时：\n![有Service Worker](/blog/img/cache/weizhi_2.gif)\n\n从图中可以看到，当没有使用Service Worker时，浏览器有的资源从memory中拿，有的资源从disk中拿。同时，相同的资源有可能是从memory中拿，有的可能是从disk中拿。加上第一次进入页面时都是从硬盘中拿取的缓存，因此可以判断当当前内存足够大时从内存中拿，反之从硬盘中拿。\n\n再看图二，所有资源几乎都是从Service Worker中拿的。因此，可以总结：\n\n1. 当有Service Worker时，浏览器（chrome）会从Service Worker拿取缓存\n2. 浏览器（chrome）首先会从内存中获取缓存，获取多少由当前内存和内存空间决定\n3. 浏览器（chrome）拿取缓存的顺序：Service Worker > memory cache > disk cache\n4. 其他：在chrome中状态码为200（from disk cache和from memory cache）的文件在edge和firefox中都是304（感兴趣的同学可以试一试）\n\n## 参考\n\n[彻底理解浏览器缓存机制](https://www.cnblogs.com/shixiaomiao1122/p/7591556.html)\n[浏览器缓存和CDN缓存基本介绍](https://blog.csdn.net/longaiyunlay/article/details/78390226)\n[CDN缓存策略](https://www.cnblogs.com/quincyWang/p/6911664.html)\n[设计一个无懈可击的浏览器缓存方案：关于思路，细节，ServiceWorker，以及HTTP/2](https://zhuanlan.zhihu.com/p/28113197)\n[Service Worker初体验](https://blog.csdn.net/xiangzhihong8/article/details/55225829)\n","source":"_posts/cache.md","raw":"---\ntitle: 扒一扒浏览器缓存机制\ndate: 2019-02-07 20:05:41\ntags: [基础,浏览器]\n---\n\n## 前言\n\n[原文](https://jayzangwill.github.io/blog/2019/02/07/cache/) && [个人主页](https://www.jayzangwill.cn)\n\n[知乎](https://zhuanlan.zhihu.com/p/56943873) && [知乎专栏](https://zhuanlan.zhihu.com/jayzangwill)\n\n## 背景\n\n之所以会写这篇文章，是因为之前在工作中发生的一次微信浏览器莫名缓存的问题。这个问题的源头是因为万恶的微信浏览器将页面的入口文件给缓存起来了（单页面应用），因此，通过写下这篇文章来理一理浏览器的缓存机制。\n\n详细的解决方案可以看[这里](https://www.jianshu.com/p/cce9511c0914)\n\n<!-- more -->\n\n## 浏览器的缓存机制\n\n既然浏览器需要缓存资源，就得知道资源啥时候更新。要想知道资源啥时候更新，这就得引出两个概念：**强制缓存**和**协商缓存**\n\n### 强制缓存\n\n当命中强制缓存后，浏览器不会去请求服务器，而是直接使用本地缓存的资源，并返回状态码`200(缓存来源)`。是否命中强制缓存是由响应头中的`expires`和`Cache-Control`控制（浏览器的第一个请求不会命中强制缓存，Service Worker除外，感兴趣的同学可以用node试一试）。\n\n响应头如图：![响应头](/blog/img/cache/header_1.png)\n\n当命中强制缓存的时候返回的状态码：![强制缓存状态码](/blog/img/cache/code_200.png)\n\n#### expires\n\n`expires`是http1.0的标准，表明服务器的过期时间，是格林威治时间，当请求的时候客户端的时间超过`expires`标识的时间时，就会去请求服务器。\n\n可以看到，**当请求的时候客户端的时间超过`expires`标识的时间时，就会去请求服务器**，但是这个其实是存在问题的，当用户的系统时间改到这个标识的时间之后，就永远不会命中这个强制缓存。所以`Cache-Control`就诞生了。\n\n#### Cache-Control\n\n`Cache-Control`是http1.1的产物，他可以看成是`expries`的补充。\n\n介绍一些`Cache-Control`常用的值：\n\n1. max-age: 设置缓存的最大的有效时间，单位为秒（s）。max-age会覆盖掉expires。\n2. s-maxage: 设置代理服务器缓存的最大的有效时间，单位为秒（s）。s-maxage会覆盖掉max-age。\n3. public: 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存。\n4. private: 只有发起请求的浏览器可进行缓存。\n5. no-cache: 虽然字面意义是“不要缓存”。但它实际上的机制是，仍然对资源使用缓存，但每一次在使用缓存之前必须向服务器对缓存资源进行验证。\n6. no-store: 所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存。\n7. must-revalidate: 如果你配置了max-age信息，当缓存资源仍然新鲜（小于max-age）时使用缓存，否则需要对资源进行验证\n\n所以判断缓存是否过期步骤是：\n\n1. 查看是否有cache-control的max-age / s-maxage，如果有，则用服务器时间date值 + max-age/s-maxage 的秒数计算出新的过期时间，将当前时间与过期时间进行比较，判断是否过期。如果没有则用expires 作为过期时间比较。\n\n![步骤图](/blog/img/cache/step.png)\n\n\n### 小结\n\n浏览器的强制缓存由响应头中的`expires`和`Cache-Control`控制。当`Cache-Control`中有max-age/s-maxage时则用服务器时间date值 + max-age/s-maxage 的秒数计算出新的过期时间；否则用`expires`作为资源的过期时间。\n\n#### 协商缓存\n\n顾名思义，协商缓存就是得与服务器商量一下是否使用缓存，命中协商缓存的话会返回状态`304`。\n\n协商缓存由响应头中的`Last-Modified`和`ETag`还有请求头中的`If-Modified-Since`和`If-None-Match`控制。\n\n如图：![响应头和请求头](/blog/img/cache/header_2.png)\n\n那么这四个东西是什么玩意呢？接下来就由我细细道来：\n\n**Last-Modified**：标示这个响应资源的最后修改时间。\n\n**If-Modified-Since**：当资源过期时（使用`Cache-Control`标识的max-age/s-maxage），发现资源具有`Last-Msodified`声明，则向服务器请求时带上头 `If-Modified-Since`（即响应头中的`Last-Modified`值），表示请求时间。这个时候服务器收到请求后发现有头`If-Modified-Since`则与**被请求资源**的最后修改时间进行比对。若最后修改时间较新，说明资源有被改动过，将新资源返回并返回状态`200`，否则返回`304`表示资源没被更新使用缓存即可。\n\n**Etag**：服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。例如在Apache中，`ETag`的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。\n\n**If-None-Match**：当资源过期时（使用Cache-Control标识的max-age/s-maxage），发现资源具有`Etage`声明，则向服务器请求时带上头`If-None-Match`（即响应头中`Etag`的值）。服务器收到请求后发现有头`If-None-Match` 则与被请求资源的相应校验串进行比对，决定返回200或304（**注意：服务器会优先验证If-None-Match**）。\n\nemm，文字看起来文绉绉的，那就上图吧：\n\n如图：![步骤图](/blog/img/cache/step_2.png)\n\n**问**：咦？这个`Last-Modified`和`If-Modified-Since`貌似看起来够用了啊，为啥还要有`Etag`和`If-None-Match`啊？\n\n**答**：\n\n1. `Last-Modified`标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间\n2. 如果某些文件会被定期生成，当有时内容并没有任何变化，但`Last-Modified`却改变了，导致文件没法使用缓存\n3. 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形\n\n### 小结\n\n当浏览器没命中强制缓存时，会和服务器协商是否使用缓存，这个就是**协商缓存**，协商缓存由响应头中的`Last-Modified`和`ETag`还有请求头中的`If-Modified-Since`和`If-None-Match`控制。命中协商缓存的资源，服务器会返回`304`\n\n## CDN缓存\n\n### 什么是CDN\n\nCDN即Content Delivery network，内容分发网络。CDN可以理解为一个火车票的代售点，用户在浏览网站的时候，CDN会选择一个离用户最近的CDN边缘节点来响应用户的请求。例如，上海用户想要访问我[www.jayzangwill.cn](www.jayzangwill.cn)上的一个资源，这个时候，刚好我在上海有台CND服务器，用户的请求直接会被打到这台上海的CDN服务器上，而不会跑到北京深圳的服务器上去请求我的资源，这样就加快了服务器的相应时间。\n\n### CDN的原理\n\n在用户和服务器之间增加cache层，通过接管DNS,将用户的请求引导到cache上获得服务器的资源。\n\n### CDN缓存策略\n\n和浏览器缓存机制类似，CND也有一套类似的缓存策略，这套缓存策略会决定CDN服务器什么时候去更新自己的资源。\n\n上文所说的`Cache-Control`的`max-age`头可以告知文件在浏览器的缓存时间，在`max-age`指定的时间内，浏览器会直接使用本地缓存，而不会请求服务器，CDN采取了类似的机制，你只要把CDN节点看成浏览器，源服务器看成浏览器需要请求的服务器即可，此时，源服务器的`max-age`头决定了资源在CDN节点本地缓存的时间，有一点差别的是，CDN规定了一个自定义协议，也就是上文说的`s-maxage`，若源站该`s-maxage`存在，会优先使用`s-maxage`作为CDN的缓存时间。\n\n如下图为CDN的缓存机制示意图：\n\n![CND缓存示意图](/blog/img/cache/cdn_step.png)\n\n## 强制缓存的几个位置\n\n总的来说就分为四个位置：\n\n1. Memory Cache\n2. Disk Cache\n3. Push Cache\n4. [Service Worker](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers)\n\n### Memory Cache\n\n存在内存中的缓存，一般是页面刷新后，浏览器从内存中获取缓存，从内存中获取缓存的速度要比从硬盘中获取的速度要快，因此在刷新的时候会从内存中获取缓存比较方便。当页面关闭后，内存就会释放。\n\n### Disk Cache\n\n存在硬盘中的缓存，当重新打开页面后，会从硬盘中获取缓存。它与内存缓存最大的区别是：硬盘缓存不会在页面关闭后被清除，当页面关闭后再进入页面读取的就是硬盘缓存。\n\n### Push Cache\n\n“推送缓存”是针对HTTP/2标准下的推送资源设定的。推送缓存是session级别的，如果用户的session结束则资源被释放；即使URL相同但处于不同的session中也不会发生匹配。推送缓存的存储时间较短，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。更多详情可参阅[HTTP/2 push is tougher than I thought](https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/)\n\n以下我列出几点：\n\n1. 几乎所有的资源都能被推送，并且能够被缓存。测试过程是作者在推送资源之后尝试用fetch()、XMLHttpRequest、link、script、iframe获取推送的资源。Edge和Safari浏览器支持相对比较差\n2. no-cache和no-store资源也能被推送\n3. Push Cache是最后一道缓存机制（之前会经过Service Worker、Memory Cache、HTTP Cache）\n4. 如果连接被关闭则Push Cache被释放\n5. 多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。\n6. 一旦Push Cache中的资源被使用即被移除\n7. 如果Push Cache或者HTTP Cache已经存在被推送的资源，则有可能浏览器拒绝推送\n8. 你可以为其他域名推送资源\n\n### [Service Worker](https://developers.google.com/web/fundamentals/primers/service-workers/)\n\n关于service worker是什么大家可以看连接，链接需要特殊技术才能访问，访问不了的可以看以下我的截图：\n\n![service介绍](/blog/img/cache/servicework.png)\n\n总的来说Service Worker就类似于一个中间人，所有浏览器发出的请求都会被Service Worker拦截到，并被Service Worker处理，从而决定资源都是从哪获取。\n\n另外还需要注意的是Service Worker依赖https或者localhost环境\n\n所有被Service Worker缓存的资源都能在控制台的Application下的Cache Tab里的Cache Storage看到：\n\n![application](/blog/img/cache/application.png)\n\n以下代码展示了一个Service Worker的使用示例（如果不了解sw的同学建议阅读[链接](https://developers.google.com/web/fundamentals/primers/service-workers/)中的代码示例再继续）\n\n```javascript\nnavigator.serviceWorker && navigator.serviceWorker.register('/sw.js', { scope: '/' })\n\n// 以下是sw.js中的代码\nvar CACHE_KEY = 'v1.' + (new Date().getMonth()) + '.0';\nvar IS_ENV_TEST = /^(localhost)|(test-)/.test(self.location.host);\nvar CACHE_TYPES = /(\\/index(#\\/)?)|(\\.(png|jpe?g|gif|webp|svg|mp3|wav|aac|mp4|mov|m4v|mkv|wma|wmv|rm|3gp|rmvb|avi|flv|js|css))$/;\nself.addEventListener('install', function(event) {\n    self.skipWaiting();\n    event.waitUntil(caches.keys().then(function(cacheNames) {\n        return Promise.all(cacheNames.map(function(cacheName) {\n            if (cacheName !== CACHE_KEY) {\n                return caches.delete(cacheName)\n            }\n        }))\n    }))\n});\n\nself.addEventListener('fetch', function(event) {\n    var method = event.request.method;\n    var url = event.request.url;\n    if (method !== 'GET' || !CACHE_TYPES.test(url) || /sw\\.js$/.test(url)) {\n        return\n    }\n    event.respondWith(caches.match(event.request).then(function(cacheRes) {\n        if (!navigator.onLine) {\n            return cacheRes\n        }\n        if (!cacheRes || /\\/index(#\\/)?$/.test(url) || (IS_ENV_TEST && /\\.(js|css)$/.test(url))) {\n            return fetch(event.request).then(function(fetchResponse) {\n                caches.open(CACHE_KEY).then(function(cache) {\n                    cache.put(event.request, fetchResponse)\n                });\n                return fetchResponse.clone()\n            })\n        }\n        return cacheRes\n    }))\n});\n\n```\n\n#### 命中强制缓存时，该从哪拿缓存\n\n对于这个问题，网上有不同的解释，同时不同的浏览器也有不同的缓存机制，所以这个问题我决定做个试验，以下是我的实验结果（截图均为chrome浏览器）：\n\n没有Service Worker时：\n![没有Service Worker](/blog/img/cache/weizhi_1.gif)\n\n有Service Worker时：\n![有Service Worker](/blog/img/cache/weizhi_2.gif)\n\n从图中可以看到，当没有使用Service Worker时，浏览器有的资源从memory中拿，有的资源从disk中拿。同时，相同的资源有可能是从memory中拿，有的可能是从disk中拿。加上第一次进入页面时都是从硬盘中拿取的缓存，因此可以判断当当前内存足够大时从内存中拿，反之从硬盘中拿。\n\n再看图二，所有资源几乎都是从Service Worker中拿的。因此，可以总结：\n\n1. 当有Service Worker时，浏览器（chrome）会从Service Worker拿取缓存\n2. 浏览器（chrome）首先会从内存中获取缓存，获取多少由当前内存和内存空间决定\n3. 浏览器（chrome）拿取缓存的顺序：Service Worker > memory cache > disk cache\n4. 其他：在chrome中状态码为200（from disk cache和from memory cache）的文件在edge和firefox中都是304（感兴趣的同学可以试一试）\n\n## 参考\n\n[彻底理解浏览器缓存机制](https://www.cnblogs.com/shixiaomiao1122/p/7591556.html)\n[浏览器缓存和CDN缓存基本介绍](https://blog.csdn.net/longaiyunlay/article/details/78390226)\n[CDN缓存策略](https://www.cnblogs.com/quincyWang/p/6911664.html)\n[设计一个无懈可击的浏览器缓存方案：关于思路，细节，ServiceWorker，以及HTTP/2](https://zhuanlan.zhihu.com/p/28113197)\n[Service Worker初体验](https://blog.csdn.net/xiangzhihong8/article/details/55225829)\n","slug":"cache","published":1,"updated":"2020-04-07T03:29:17.934Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8qzc34q000k2cl6mkpxc5ed","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><a href=\"https://jayzangwill.github.io/blog/2019/02/07/cache/\">原文</a> &amp;&amp; <a href=\"https://www.jayzangwill.cn\" target=\"_blank\" rel=\"noopener\">个人主页</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/56943873\" target=\"_blank\" rel=\"noopener\">知乎</a> &amp;&amp; <a href=\"https://zhuanlan.zhihu.com/jayzangwill\" target=\"_blank\" rel=\"noopener\">知乎专栏</a></p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>之所以会写这篇文章，是因为之前在工作中发生的一次微信浏览器莫名缓存的问题。这个问题的源头是因为万恶的微信浏览器将页面的入口文件给缓存起来了（单页面应用），因此，通过写下这篇文章来理一理浏览器的缓存机制。</p>\n<p>详细的解决方案可以看<a href=\"https://www.jianshu.com/p/cce9511c0914\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<a id=\"more\"></a>\n<h2 id=\"浏览器的缓存机制\"><a href=\"#浏览器的缓存机制\" class=\"headerlink\" title=\"浏览器的缓存机制\"></a>浏览器的缓存机制</h2><p>既然浏览器需要缓存资源，就得知道资源啥时候更新。要想知道资源啥时候更新，这就得引出两个概念：<strong>强制缓存</strong>和<strong>协商缓存</strong></p>\n<h3 id=\"强制缓存\"><a href=\"#强制缓存\" class=\"headerlink\" title=\"强制缓存\"></a>强制缓存</h3><p>当命中强制缓存后，浏览器不会去请求服务器，而是直接使用本地缓存的资源，并返回状态码<code>200(缓存来源)</code>。是否命中强制缓存是由响应头中的<code>expires</code>和<code>Cache-Control</code>控制（浏览器的第一个请求不会命中强制缓存，Service Worker除外，感兴趣的同学可以用node试一试）。</p>\n<p>响应头如图：<img src=\"/blog/img/cache/header_1.png\" alt=\"响应头\"></p>\n<p>当命中强制缓存的时候返回的状态码：<img src=\"/blog/img/cache/code_200.png\" alt=\"强制缓存状态码\"></p>\n<h4 id=\"expires\"><a href=\"#expires\" class=\"headerlink\" title=\"expires\"></a>expires</h4><p><code>expires</code>是http1.0的标准，表明服务器的过期时间，是格林威治时间，当请求的时候客户端的时间超过<code>expires</code>标识的时间时，就会去请求服务器。</p>\n<p>可以看到，<strong>当请求的时候客户端的时间超过<code>expires</code>标识的时间时，就会去请求服务器</strong>，但是这个其实是存在问题的，当用户的系统时间改到这个标识的时间之后，就永远不会命中这个强制缓存。所以<code>Cache-Control</code>就诞生了。</p>\n<h4 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h4><p><code>Cache-Control</code>是http1.1的产物，他可以看成是<code>expries</code>的补充。</p>\n<p>介绍一些<code>Cache-Control</code>常用的值：</p>\n<ol>\n<li>max-age: 设置缓存的最大的有效时间，单位为秒（s）。max-age会覆盖掉expires。</li>\n<li>s-maxage: 设置代理服务器缓存的最大的有效时间，单位为秒（s）。s-maxage会覆盖掉max-age。</li>\n<li>public: 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存。</li>\n<li>private: 只有发起请求的浏览器可进行缓存。</li>\n<li>no-cache: 虽然字面意义是“不要缓存”。但它实际上的机制是，仍然对资源使用缓存，但每一次在使用缓存之前必须向服务器对缓存资源进行验证。</li>\n<li>no-store: 所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存。</li>\n<li>must-revalidate: 如果你配置了max-age信息，当缓存资源仍然新鲜（小于max-age）时使用缓存，否则需要对资源进行验证</li>\n</ol>\n<p>所以判断缓存是否过期步骤是：</p>\n<ol>\n<li>查看是否有cache-control的max-age / s-maxage，如果有，则用服务器时间date值 + max-age/s-maxage 的秒数计算出新的过期时间，将当前时间与过期时间进行比较，判断是否过期。如果没有则用expires 作为过期时间比较。</li>\n</ol>\n<p><img src=\"/blog/img/cache/step.png\" alt=\"步骤图\"></p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>浏览器的强制缓存由响应头中的<code>expires</code>和<code>Cache-Control</code>控制。当<code>Cache-Control</code>中有max-age/s-maxage时则用服务器时间date值 + max-age/s-maxage 的秒数计算出新的过期时间；否则用<code>expires</code>作为资源的过期时间。</p>\n<h4 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h4><p>顾名思义，协商缓存就是得与服务器商量一下是否使用缓存，命中协商缓存的话会返回状态<code>304</code>。</p>\n<p>协商缓存由响应头中的<code>Last-Modified</code>和<code>ETag</code>还有请求头中的<code>If-Modified-Since</code>和<code>If-None-Match</code>控制。</p>\n<p>如图：<img src=\"/blog/img/cache/header_2.png\" alt=\"响应头和请求头\"></p>\n<p>那么这四个东西是什么玩意呢？接下来就由我细细道来：</p>\n<p><strong>Last-Modified</strong>：标示这个响应资源的最后修改时间。</p>\n<p><strong>If-Modified-Since</strong>：当资源过期时（使用<code>Cache-Control</code>标识的max-age/s-maxage），发现资源具有<code>Last-Msodified</code>声明，则向服务器请求时带上头 <code>If-Modified-Since</code>（即响应头中的<code>Last-Modified</code>值），表示请求时间。这个时候服务器收到请求后发现有头<code>If-Modified-Since</code>则与<strong>被请求资源</strong>的最后修改时间进行比对。若最后修改时间较新，说明资源有被改动过，将新资源返回并返回状态<code>200</code>，否则返回<code>304</code>表示资源没被更新使用缓存即可。</p>\n<p><strong>Etag</strong>：服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。例如在Apache中，<code>ETag</code>的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。</p>\n<p><strong>If-None-Match</strong>：当资源过期时（使用Cache-Control标识的max-age/s-maxage），发现资源具有<code>Etage</code>声明，则向服务器请求时带上头<code>If-None-Match</code>（即响应头中<code>Etag</code>的值）。服务器收到请求后发现有头<code>If-None-Match</code> 则与被请求资源的相应校验串进行比对，决定返回200或304（<strong>注意：服务器会优先验证If-None-Match</strong>）。</p>\n<p>emm，文字看起来文绉绉的，那就上图吧：</p>\n<p>如图：<img src=\"/blog/img/cache/step_2.png\" alt=\"步骤图\"></p>\n<p><strong>问</strong>：咦？这个<code>Last-Modified</code>和<code>If-Modified-Since</code>貌似看起来够用了啊，为啥还要有<code>Etag</code>和<code>If-None-Match</code>啊？</p>\n<p><strong>答</strong>：</p>\n<ol>\n<li><code>Last-Modified</code>标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</li>\n<li>如果某些文件会被定期生成，当有时内容并没有任何变化，但<code>Last-Modified</code>却改变了，导致文件没法使用缓存</li>\n<li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li>\n</ol>\n<h3 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>当浏览器没命中强制缓存时，会和服务器协商是否使用缓存，这个就是<strong>协商缓存</strong>，协商缓存由响应头中的<code>Last-Modified</code>和<code>ETag</code>还有请求头中的<code>If-Modified-Since</code>和<code>If-None-Match</code>控制。命中协商缓存的资源，服务器会返回<code>304</code></p>\n<h2 id=\"CDN缓存\"><a href=\"#CDN缓存\" class=\"headerlink\" title=\"CDN缓存\"></a>CDN缓存</h2><h3 id=\"什么是CDN\"><a href=\"#什么是CDN\" class=\"headerlink\" title=\"什么是CDN\"></a>什么是CDN</h3><p>CDN即Content Delivery network，内容分发网络。CDN可以理解为一个火车票的代售点，用户在浏览网站的时候，CDN会选择一个离用户最近的CDN边缘节点来响应用户的请求。例如，上海用户想要访问我<a href=\"www.jayzangwill.cn\">www.jayzangwill.cn</a>上的一个资源，这个时候，刚好我在上海有台CND服务器，用户的请求直接会被打到这台上海的CDN服务器上，而不会跑到北京深圳的服务器上去请求我的资源，这样就加快了服务器的相应时间。</p>\n<h3 id=\"CDN的原理\"><a href=\"#CDN的原理\" class=\"headerlink\" title=\"CDN的原理\"></a>CDN的原理</h3><p>在用户和服务器之间增加cache层，通过接管DNS,将用户的请求引导到cache上获得服务器的资源。</p>\n<h3 id=\"CDN缓存策略\"><a href=\"#CDN缓存策略\" class=\"headerlink\" title=\"CDN缓存策略\"></a>CDN缓存策略</h3><p>和浏览器缓存机制类似，CND也有一套类似的缓存策略，这套缓存策略会决定CDN服务器什么时候去更新自己的资源。</p>\n<p>上文所说的<code>Cache-Control</code>的<code>max-age</code>头可以告知文件在浏览器的缓存时间，在<code>max-age</code>指定的时间内，浏览器会直接使用本地缓存，而不会请求服务器，CDN采取了类似的机制，你只要把CDN节点看成浏览器，源服务器看成浏览器需要请求的服务器即可，此时，源服务器的<code>max-age</code>头决定了资源在CDN节点本地缓存的时间，有一点差别的是，CDN规定了一个自定义协议，也就是上文说的<code>s-maxage</code>，若源站该<code>s-maxage</code>存在，会优先使用<code>s-maxage</code>作为CDN的缓存时间。</p>\n<p>如下图为CDN的缓存机制示意图：</p>\n<p><img src=\"/blog/img/cache/cdn_step.png\" alt=\"CND缓存示意图\"></p>\n<h2 id=\"强制缓存的几个位置\"><a href=\"#强制缓存的几个位置\" class=\"headerlink\" title=\"强制缓存的几个位置\"></a>强制缓存的几个位置</h2><p>总的来说就分为四个位置：</p>\n<ol>\n<li>Memory Cache</li>\n<li>Disk Cache</li>\n<li>Push Cache</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers\" target=\"_blank\" rel=\"noopener\">Service Worker</a></li>\n</ol>\n<h3 id=\"Memory-Cache\"><a href=\"#Memory-Cache\" class=\"headerlink\" title=\"Memory Cache\"></a>Memory Cache</h3><p>存在内存中的缓存，一般是页面刷新后，浏览器从内存中获取缓存，从内存中获取缓存的速度要比从硬盘中获取的速度要快，因此在刷新的时候会从内存中获取缓存比较方便。当页面关闭后，内存就会释放。</p>\n<h3 id=\"Disk-Cache\"><a href=\"#Disk-Cache\" class=\"headerlink\" title=\"Disk Cache\"></a>Disk Cache</h3><p>存在硬盘中的缓存，当重新打开页面后，会从硬盘中获取缓存。它与内存缓存最大的区别是：硬盘缓存不会在页面关闭后被清除，当页面关闭后再进入页面读取的就是硬盘缓存。</p>\n<h3 id=\"Push-Cache\"><a href=\"#Push-Cache\" class=\"headerlink\" title=\"Push Cache\"></a>Push Cache</h3><p>“推送缓存”是针对HTTP/2标准下的推送资源设定的。推送缓存是session级别的，如果用户的session结束则资源被释放；即使URL相同但处于不同的session中也不会发生匹配。推送缓存的存储时间较短，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。更多详情可参阅<a href=\"https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/\" target=\"_blank\" rel=\"noopener\">HTTP/2 push is tougher than I thought</a></p>\n<p>以下我列出几点：</p>\n<ol>\n<li>几乎所有的资源都能被推送，并且能够被缓存。测试过程是作者在推送资源之后尝试用fetch()、XMLHttpRequest、link、script、iframe获取推送的资源。Edge和Safari浏览器支持相对比较差</li>\n<li>no-cache和no-store资源也能被推送</li>\n<li>Push Cache是最后一道缓存机制（之前会经过Service Worker、Memory Cache、HTTP Cache）</li>\n<li>如果连接被关闭则Push Cache被释放</li>\n<li>多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。</li>\n<li>一旦Push Cache中的资源被使用即被移除</li>\n<li>如果Push Cache或者HTTP Cache已经存在被推送的资源，则有可能浏览器拒绝推送</li>\n<li>你可以为其他域名推送资源</li>\n</ol>\n<h3 id=\"Service-Worker\"><a href=\"#Service-Worker\" class=\"headerlink\" title=\"Service Worker\"></a><a href=\"https://developers.google.com/web/fundamentals/primers/service-workers/\" target=\"_blank\" rel=\"noopener\">Service Worker</a></h3><p>关于service worker是什么大家可以看连接，链接需要特殊技术才能访问，访问不了的可以看以下我的截图：</p>\n<p><img src=\"/blog/img/cache/servicework.png\" alt=\"service介绍\"></p>\n<p>总的来说Service Worker就类似于一个中间人，所有浏览器发出的请求都会被Service Worker拦截到，并被Service Worker处理，从而决定资源都是从哪获取。</p>\n<p>另外还需要注意的是Service Worker依赖https或者localhost环境</p>\n<p>所有被Service Worker缓存的资源都能在控制台的Application下的Cache Tab里的Cache Storage看到：</p>\n<p><img src=\"/blog/img/cache/application.png\" alt=\"application\"></p>\n<p>以下代码展示了一个Service Worker的使用示例（如果不了解sw的同学建议阅读<a href=\"https://developers.google.com/web/fundamentals/primers/service-workers/\" target=\"_blank\" rel=\"noopener\">链接</a>中的代码示例再继续）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">navigator.serviceWorker &amp;&amp; navigator.serviceWorker.register(<span class=\"string\">'/sw.js'</span>, &#123; <span class=\"attr\">scope</span>: <span class=\"string\">'/'</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下是sw.js中的代码</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> CACHE_KEY = <span class=\"string\">'v1.'</span> + (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getMonth()) + <span class=\"string\">'.0'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> IS_ENV_TEST = <span class=\"regexp\">/^(localhost)|(test-)/</span>.test(self.location.host);</span><br><span class=\"line\"><span class=\"keyword\">var</span> CACHE_TYPES = <span class=\"regexp\">/(\\/index(#\\/)?)|(\\.(png|jpe?g|gif|webp|svg|mp3|wav|aac|mp4|mov|m4v|mkv|wma|wmv|rm|3gp|rmvb|avi|flv|js|css))$/</span>;</span><br><span class=\"line\">self.addEventListener(<span class=\"string\">'install'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    self.skipWaiting();</span><br><span class=\"line\">    event.waitUntil(caches.keys().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cacheNames</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(cacheNames.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cacheName</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cacheName !== CACHE_KEY) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> caches.delete(cacheName)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;))</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">self.addEventListener(<span class=\"string\">'fetch'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> method = event.request.method;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> url = event.request.url;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (method !== <span class=\"string\">'GET'</span> || !CACHE_TYPES.test(url) || <span class=\"regexp\">/sw\\.js$/</span>.test(url)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    event.respondWith(caches.match(event.request).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cacheRes</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!navigator.onLine) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cacheRes</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cacheRes || <span class=\"regexp\">/\\/index(#\\/)?$/</span>.test(url) || (IS_ENV_TEST &amp;&amp; <span class=\"regexp\">/\\.(js|css)$/</span>.test(url))) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fetch(event.request).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fetchResponse</span>) </span>&#123;</span><br><span class=\"line\">                caches.open(CACHE_KEY).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cache</span>) </span>&#123;</span><br><span class=\"line\">                    cache.put(event.request, fetchResponse)</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> fetchResponse.clone()</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cacheRes</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"命中强制缓存时，该从哪拿缓存\"><a href=\"#命中强制缓存时，该从哪拿缓存\" class=\"headerlink\" title=\"命中强制缓存时，该从哪拿缓存\"></a>命中强制缓存时，该从哪拿缓存</h4><p>对于这个问题，网上有不同的解释，同时不同的浏览器也有不同的缓存机制，所以这个问题我决定做个试验，以下是我的实验结果（截图均为chrome浏览器）：</p>\n<p>没有Service Worker时：<br><img src=\"/blog/img/cache/weizhi_1.gif\" alt=\"没有Service Worker\"></p>\n<p>有Service Worker时：<br><img src=\"/blog/img/cache/weizhi_2.gif\" alt=\"有Service Worker\"></p>\n<p>从图中可以看到，当没有使用Service Worker时，浏览器有的资源从memory中拿，有的资源从disk中拿。同时，相同的资源有可能是从memory中拿，有的可能是从disk中拿。加上第一次进入页面时都是从硬盘中拿取的缓存，因此可以判断当当前内存足够大时从内存中拿，反之从硬盘中拿。</p>\n<p>再看图二，所有资源几乎都是从Service Worker中拿的。因此，可以总结：</p>\n<ol>\n<li>当有Service Worker时，浏览器（chrome）会从Service Worker拿取缓存</li>\n<li>浏览器（chrome）首先会从内存中获取缓存，获取多少由当前内存和内存空间决定</li>\n<li>浏览器（chrome）拿取缓存的顺序：Service Worker &gt; memory cache &gt; disk cache</li>\n<li>其他：在chrome中状态码为200（from disk cache和from memory cache）的文件在edge和firefox中都是304（感兴趣的同学可以试一试）</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.cnblogs.com/shixiaomiao1122/p/7591556.html\" target=\"_blank\" rel=\"noopener\">彻底理解浏览器缓存机制</a><br><a href=\"https://blog.csdn.net/longaiyunlay/article/details/78390226\" target=\"_blank\" rel=\"noopener\">浏览器缓存和CDN缓存基本介绍</a><br><a href=\"https://www.cnblogs.com/quincyWang/p/6911664.html\" target=\"_blank\" rel=\"noopener\">CDN缓存策略</a><br><a href=\"https://zhuanlan.zhihu.com/p/28113197\" target=\"_blank\" rel=\"noopener\">设计一个无懈可击的浏览器缓存方案：关于思路，细节，ServiceWorker，以及HTTP/2</a><br><a href=\"https://blog.csdn.net/xiangzhihong8/article/details/55225829\" target=\"_blank\" rel=\"noopener\">Service Worker初体验</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><a href=\"https://jayzangwill.github.io/blog/2019/02/07/cache/\">原文</a> &amp;&amp; <a href=\"https://www.jayzangwill.cn\" target=\"_blank\" rel=\"noopener\">个人主页</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/56943873\" target=\"_blank\" rel=\"noopener\">知乎</a> &amp;&amp; <a href=\"https://zhuanlan.zhihu.com/jayzangwill\" target=\"_blank\" rel=\"noopener\">知乎专栏</a></p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>之所以会写这篇文章，是因为之前在工作中发生的一次微信浏览器莫名缓存的问题。这个问题的源头是因为万恶的微信浏览器将页面的入口文件给缓存起来了（单页面应用），因此，通过写下这篇文章来理一理浏览器的缓存机制。</p>\n<p>详细的解决方案可以看<a href=\"https://www.jianshu.com/p/cce9511c0914\" target=\"_blank\" rel=\"noopener\">这里</a></p>","more":"<h2 id=\"浏览器的缓存机制\"><a href=\"#浏览器的缓存机制\" class=\"headerlink\" title=\"浏览器的缓存机制\"></a>浏览器的缓存机制</h2><p>既然浏览器需要缓存资源，就得知道资源啥时候更新。要想知道资源啥时候更新，这就得引出两个概念：<strong>强制缓存</strong>和<strong>协商缓存</strong></p>\n<h3 id=\"强制缓存\"><a href=\"#强制缓存\" class=\"headerlink\" title=\"强制缓存\"></a>强制缓存</h3><p>当命中强制缓存后，浏览器不会去请求服务器，而是直接使用本地缓存的资源，并返回状态码<code>200(缓存来源)</code>。是否命中强制缓存是由响应头中的<code>expires</code>和<code>Cache-Control</code>控制（浏览器的第一个请求不会命中强制缓存，Service Worker除外，感兴趣的同学可以用node试一试）。</p>\n<p>响应头如图：<img src=\"/blog/img/cache/header_1.png\" alt=\"响应头\"></p>\n<p>当命中强制缓存的时候返回的状态码：<img src=\"/blog/img/cache/code_200.png\" alt=\"强制缓存状态码\"></p>\n<h4 id=\"expires\"><a href=\"#expires\" class=\"headerlink\" title=\"expires\"></a>expires</h4><p><code>expires</code>是http1.0的标准，表明服务器的过期时间，是格林威治时间，当请求的时候客户端的时间超过<code>expires</code>标识的时间时，就会去请求服务器。</p>\n<p>可以看到，<strong>当请求的时候客户端的时间超过<code>expires</code>标识的时间时，就会去请求服务器</strong>，但是这个其实是存在问题的，当用户的系统时间改到这个标识的时间之后，就永远不会命中这个强制缓存。所以<code>Cache-Control</code>就诞生了。</p>\n<h4 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h4><p><code>Cache-Control</code>是http1.1的产物，他可以看成是<code>expries</code>的补充。</p>\n<p>介绍一些<code>Cache-Control</code>常用的值：</p>\n<ol>\n<li>max-age: 设置缓存的最大的有效时间，单位为秒（s）。max-age会覆盖掉expires。</li>\n<li>s-maxage: 设置代理服务器缓存的最大的有效时间，单位为秒（s）。s-maxage会覆盖掉max-age。</li>\n<li>public: 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存。</li>\n<li>private: 只有发起请求的浏览器可进行缓存。</li>\n<li>no-cache: 虽然字面意义是“不要缓存”。但它实际上的机制是，仍然对资源使用缓存，但每一次在使用缓存之前必须向服务器对缓存资源进行验证。</li>\n<li>no-store: 所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存。</li>\n<li>must-revalidate: 如果你配置了max-age信息，当缓存资源仍然新鲜（小于max-age）时使用缓存，否则需要对资源进行验证</li>\n</ol>\n<p>所以判断缓存是否过期步骤是：</p>\n<ol>\n<li>查看是否有cache-control的max-age / s-maxage，如果有，则用服务器时间date值 + max-age/s-maxage 的秒数计算出新的过期时间，将当前时间与过期时间进行比较，判断是否过期。如果没有则用expires 作为过期时间比较。</li>\n</ol>\n<p><img src=\"/blog/img/cache/step.png\" alt=\"步骤图\"></p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>浏览器的强制缓存由响应头中的<code>expires</code>和<code>Cache-Control</code>控制。当<code>Cache-Control</code>中有max-age/s-maxage时则用服务器时间date值 + max-age/s-maxage 的秒数计算出新的过期时间；否则用<code>expires</code>作为资源的过期时间。</p>\n<h4 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h4><p>顾名思义，协商缓存就是得与服务器商量一下是否使用缓存，命中协商缓存的话会返回状态<code>304</code>。</p>\n<p>协商缓存由响应头中的<code>Last-Modified</code>和<code>ETag</code>还有请求头中的<code>If-Modified-Since</code>和<code>If-None-Match</code>控制。</p>\n<p>如图：<img src=\"/blog/img/cache/header_2.png\" alt=\"响应头和请求头\"></p>\n<p>那么这四个东西是什么玩意呢？接下来就由我细细道来：</p>\n<p><strong>Last-Modified</strong>：标示这个响应资源的最后修改时间。</p>\n<p><strong>If-Modified-Since</strong>：当资源过期时（使用<code>Cache-Control</code>标识的max-age/s-maxage），发现资源具有<code>Last-Msodified</code>声明，则向服务器请求时带上头 <code>If-Modified-Since</code>（即响应头中的<code>Last-Modified</code>值），表示请求时间。这个时候服务器收到请求后发现有头<code>If-Modified-Since</code>则与<strong>被请求资源</strong>的最后修改时间进行比对。若最后修改时间较新，说明资源有被改动过，将新资源返回并返回状态<code>200</code>，否则返回<code>304</code>表示资源没被更新使用缓存即可。</p>\n<p><strong>Etag</strong>：服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。例如在Apache中，<code>ETag</code>的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。</p>\n<p><strong>If-None-Match</strong>：当资源过期时（使用Cache-Control标识的max-age/s-maxage），发现资源具有<code>Etage</code>声明，则向服务器请求时带上头<code>If-None-Match</code>（即响应头中<code>Etag</code>的值）。服务器收到请求后发现有头<code>If-None-Match</code> 则与被请求资源的相应校验串进行比对，决定返回200或304（<strong>注意：服务器会优先验证If-None-Match</strong>）。</p>\n<p>emm，文字看起来文绉绉的，那就上图吧：</p>\n<p>如图：<img src=\"/blog/img/cache/step_2.png\" alt=\"步骤图\"></p>\n<p><strong>问</strong>：咦？这个<code>Last-Modified</code>和<code>If-Modified-Since</code>貌似看起来够用了啊，为啥还要有<code>Etag</code>和<code>If-None-Match</code>啊？</p>\n<p><strong>答</strong>：</p>\n<ol>\n<li><code>Last-Modified</code>标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</li>\n<li>如果某些文件会被定期生成，当有时内容并没有任何变化，但<code>Last-Modified</code>却改变了，导致文件没法使用缓存</li>\n<li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li>\n</ol>\n<h3 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>当浏览器没命中强制缓存时，会和服务器协商是否使用缓存，这个就是<strong>协商缓存</strong>，协商缓存由响应头中的<code>Last-Modified</code>和<code>ETag</code>还有请求头中的<code>If-Modified-Since</code>和<code>If-None-Match</code>控制。命中协商缓存的资源，服务器会返回<code>304</code></p>\n<h2 id=\"CDN缓存\"><a href=\"#CDN缓存\" class=\"headerlink\" title=\"CDN缓存\"></a>CDN缓存</h2><h3 id=\"什么是CDN\"><a href=\"#什么是CDN\" class=\"headerlink\" title=\"什么是CDN\"></a>什么是CDN</h3><p>CDN即Content Delivery network，内容分发网络。CDN可以理解为一个火车票的代售点，用户在浏览网站的时候，CDN会选择一个离用户最近的CDN边缘节点来响应用户的请求。例如，上海用户想要访问我<a href=\"www.jayzangwill.cn\">www.jayzangwill.cn</a>上的一个资源，这个时候，刚好我在上海有台CND服务器，用户的请求直接会被打到这台上海的CDN服务器上，而不会跑到北京深圳的服务器上去请求我的资源，这样就加快了服务器的相应时间。</p>\n<h3 id=\"CDN的原理\"><a href=\"#CDN的原理\" class=\"headerlink\" title=\"CDN的原理\"></a>CDN的原理</h3><p>在用户和服务器之间增加cache层，通过接管DNS,将用户的请求引导到cache上获得服务器的资源。</p>\n<h3 id=\"CDN缓存策略\"><a href=\"#CDN缓存策略\" class=\"headerlink\" title=\"CDN缓存策略\"></a>CDN缓存策略</h3><p>和浏览器缓存机制类似，CND也有一套类似的缓存策略，这套缓存策略会决定CDN服务器什么时候去更新自己的资源。</p>\n<p>上文所说的<code>Cache-Control</code>的<code>max-age</code>头可以告知文件在浏览器的缓存时间，在<code>max-age</code>指定的时间内，浏览器会直接使用本地缓存，而不会请求服务器，CDN采取了类似的机制，你只要把CDN节点看成浏览器，源服务器看成浏览器需要请求的服务器即可，此时，源服务器的<code>max-age</code>头决定了资源在CDN节点本地缓存的时间，有一点差别的是，CDN规定了一个自定义协议，也就是上文说的<code>s-maxage</code>，若源站该<code>s-maxage</code>存在，会优先使用<code>s-maxage</code>作为CDN的缓存时间。</p>\n<p>如下图为CDN的缓存机制示意图：</p>\n<p><img src=\"/blog/img/cache/cdn_step.png\" alt=\"CND缓存示意图\"></p>\n<h2 id=\"强制缓存的几个位置\"><a href=\"#强制缓存的几个位置\" class=\"headerlink\" title=\"强制缓存的几个位置\"></a>强制缓存的几个位置</h2><p>总的来说就分为四个位置：</p>\n<ol>\n<li>Memory Cache</li>\n<li>Disk Cache</li>\n<li>Push Cache</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers\" target=\"_blank\" rel=\"noopener\">Service Worker</a></li>\n</ol>\n<h3 id=\"Memory-Cache\"><a href=\"#Memory-Cache\" class=\"headerlink\" title=\"Memory Cache\"></a>Memory Cache</h3><p>存在内存中的缓存，一般是页面刷新后，浏览器从内存中获取缓存，从内存中获取缓存的速度要比从硬盘中获取的速度要快，因此在刷新的时候会从内存中获取缓存比较方便。当页面关闭后，内存就会释放。</p>\n<h3 id=\"Disk-Cache\"><a href=\"#Disk-Cache\" class=\"headerlink\" title=\"Disk Cache\"></a>Disk Cache</h3><p>存在硬盘中的缓存，当重新打开页面后，会从硬盘中获取缓存。它与内存缓存最大的区别是：硬盘缓存不会在页面关闭后被清除，当页面关闭后再进入页面读取的就是硬盘缓存。</p>\n<h3 id=\"Push-Cache\"><a href=\"#Push-Cache\" class=\"headerlink\" title=\"Push Cache\"></a>Push Cache</h3><p>“推送缓存”是针对HTTP/2标准下的推送资源设定的。推送缓存是session级别的，如果用户的session结束则资源被释放；即使URL相同但处于不同的session中也不会发生匹配。推送缓存的存储时间较短，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。更多详情可参阅<a href=\"https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/\" target=\"_blank\" rel=\"noopener\">HTTP/2 push is tougher than I thought</a></p>\n<p>以下我列出几点：</p>\n<ol>\n<li>几乎所有的资源都能被推送，并且能够被缓存。测试过程是作者在推送资源之后尝试用fetch()、XMLHttpRequest、link、script、iframe获取推送的资源。Edge和Safari浏览器支持相对比较差</li>\n<li>no-cache和no-store资源也能被推送</li>\n<li>Push Cache是最后一道缓存机制（之前会经过Service Worker、Memory Cache、HTTP Cache）</li>\n<li>如果连接被关闭则Push Cache被释放</li>\n<li>多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。</li>\n<li>一旦Push Cache中的资源被使用即被移除</li>\n<li>如果Push Cache或者HTTP Cache已经存在被推送的资源，则有可能浏览器拒绝推送</li>\n<li>你可以为其他域名推送资源</li>\n</ol>\n<h3 id=\"Service-Worker\"><a href=\"#Service-Worker\" class=\"headerlink\" title=\"Service Worker\"></a><a href=\"https://developers.google.com/web/fundamentals/primers/service-workers/\" target=\"_blank\" rel=\"noopener\">Service Worker</a></h3><p>关于service worker是什么大家可以看连接，链接需要特殊技术才能访问，访问不了的可以看以下我的截图：</p>\n<p><img src=\"/blog/img/cache/servicework.png\" alt=\"service介绍\"></p>\n<p>总的来说Service Worker就类似于一个中间人，所有浏览器发出的请求都会被Service Worker拦截到，并被Service Worker处理，从而决定资源都是从哪获取。</p>\n<p>另外还需要注意的是Service Worker依赖https或者localhost环境</p>\n<p>所有被Service Worker缓存的资源都能在控制台的Application下的Cache Tab里的Cache Storage看到：</p>\n<p><img src=\"/blog/img/cache/application.png\" alt=\"application\"></p>\n<p>以下代码展示了一个Service Worker的使用示例（如果不了解sw的同学建议阅读<a href=\"https://developers.google.com/web/fundamentals/primers/service-workers/\" target=\"_blank\" rel=\"noopener\">链接</a>中的代码示例再继续）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">navigator.serviceWorker &amp;&amp; navigator.serviceWorker.register(<span class=\"string\">'/sw.js'</span>, &#123; <span class=\"attr\">scope</span>: <span class=\"string\">'/'</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下是sw.js中的代码</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> CACHE_KEY = <span class=\"string\">'v1.'</span> + (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getMonth()) + <span class=\"string\">'.0'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> IS_ENV_TEST = <span class=\"regexp\">/^(localhost)|(test-)/</span>.test(self.location.host);</span><br><span class=\"line\"><span class=\"keyword\">var</span> CACHE_TYPES = <span class=\"regexp\">/(\\/index(#\\/)?)|(\\.(png|jpe?g|gif|webp|svg|mp3|wav|aac|mp4|mov|m4v|mkv|wma|wmv|rm|3gp|rmvb|avi|flv|js|css))$/</span>;</span><br><span class=\"line\">self.addEventListener(<span class=\"string\">'install'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    self.skipWaiting();</span><br><span class=\"line\">    event.waitUntil(caches.keys().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cacheNames</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(cacheNames.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cacheName</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cacheName !== CACHE_KEY) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> caches.delete(cacheName)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;))</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">self.addEventListener(<span class=\"string\">'fetch'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> method = event.request.method;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> url = event.request.url;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (method !== <span class=\"string\">'GET'</span> || !CACHE_TYPES.test(url) || <span class=\"regexp\">/sw\\.js$/</span>.test(url)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    event.respondWith(caches.match(event.request).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cacheRes</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!navigator.onLine) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cacheRes</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cacheRes || <span class=\"regexp\">/\\/index(#\\/)?$/</span>.test(url) || (IS_ENV_TEST &amp;&amp; <span class=\"regexp\">/\\.(js|css)$/</span>.test(url))) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fetch(event.request).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fetchResponse</span>) </span>&#123;</span><br><span class=\"line\">                caches.open(CACHE_KEY).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cache</span>) </span>&#123;</span><br><span class=\"line\">                    cache.put(event.request, fetchResponse)</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> fetchResponse.clone()</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cacheRes</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"命中强制缓存时，该从哪拿缓存\"><a href=\"#命中强制缓存时，该从哪拿缓存\" class=\"headerlink\" title=\"命中强制缓存时，该从哪拿缓存\"></a>命中强制缓存时，该从哪拿缓存</h4><p>对于这个问题，网上有不同的解释，同时不同的浏览器也有不同的缓存机制，所以这个问题我决定做个试验，以下是我的实验结果（截图均为chrome浏览器）：</p>\n<p>没有Service Worker时：<br><img src=\"/blog/img/cache/weizhi_1.gif\" alt=\"没有Service Worker\"></p>\n<p>有Service Worker时：<br><img src=\"/blog/img/cache/weizhi_2.gif\" alt=\"有Service Worker\"></p>\n<p>从图中可以看到，当没有使用Service Worker时，浏览器有的资源从memory中拿，有的资源从disk中拿。同时，相同的资源有可能是从memory中拿，有的可能是从disk中拿。加上第一次进入页面时都是从硬盘中拿取的缓存，因此可以判断当当前内存足够大时从内存中拿，反之从硬盘中拿。</p>\n<p>再看图二，所有资源几乎都是从Service Worker中拿的。因此，可以总结：</p>\n<ol>\n<li>当有Service Worker时，浏览器（chrome）会从Service Worker拿取缓存</li>\n<li>浏览器（chrome）首先会从内存中获取缓存，获取多少由当前内存和内存空间决定</li>\n<li>浏览器（chrome）拿取缓存的顺序：Service Worker &gt; memory cache &gt; disk cache</li>\n<li>其他：在chrome中状态码为200（from disk cache和from memory cache）的文件在edge和firefox中都是304（感兴趣的同学可以试一试）</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.cnblogs.com/shixiaomiao1122/p/7591556.html\" target=\"_blank\" rel=\"noopener\">彻底理解浏览器缓存机制</a><br><a href=\"https://blog.csdn.net/longaiyunlay/article/details/78390226\" target=\"_blank\" rel=\"noopener\">浏览器缓存和CDN缓存基本介绍</a><br><a href=\"https://www.cnblogs.com/quincyWang/p/6911664.html\" target=\"_blank\" rel=\"noopener\">CDN缓存策略</a><br><a href=\"https://zhuanlan.zhihu.com/p/28113197\" target=\"_blank\" rel=\"noopener\">设计一个无懈可击的浏览器缓存方案：关于思路，细节，ServiceWorker，以及HTTP/2</a><br><a href=\"https://blog.csdn.net/xiangzhihong8/article/details/55225829\" target=\"_blank\" rel=\"noopener\">Service Worker初体验</a></p>"},{"title":"前端该如何选择图片的格式","date":"2020-04-07T05:44:59.000Z","_content":"\n想当初，这个问题在面试实习的时候被问到。问题看着简单，但是想要回答好还需要下一番功夫来了解的。\n\n如果不想看文章的话直接翻到文末去看结论即可。\n\n<!-- more -->\n\nso，在开始之前我们先补充一下图片的一些基本知识。\n\n# 图片的类型\n\n首先，我们需要来了解图片的类型。\n\n图片的类型目前就分为两种：\n\n1. 位图\n2. 矢量图\n\n## 位图\n\n所谓位图就是用像素点拼起来的图也叫点阵图，平时我们用到的`png`、`jpg`等图片就是位图。\n\n![bigmap](/blog/img/img/bitmap.png)\n\n如上图，将一张图片放大以后可以看到一个一个小点点，这一个一个小点点就是图片的一个像素。\n\n## 矢量图\n\n矢量图，也叫做向量图。矢量图并不纪录画面上每一点的信息，而是纪录了元素形状及颜色的算法，当你打开一幅矢量图的时候，软件对图形对应的函数进行运算，将运算结果图形的形状和颜色显示给你看。\n\n无论显示画面是大还是小，画面上的对象对应的算法是不变的，所以，即使对画面进行倍数相当大的缩放，它也不会像位图那样会失真。\n\n常见的就是`svg`格式的。\n\n# 图片的压缩类型\n\n1. 无压缩\n2. 有损压缩\n3. 无损压缩\n\n## 无压缩\n\n无压缩的图片格式不对图片数据进行压缩处理，能准确地呈现原图片。例如[BMP](https://baike.baidu.com/item/BMP%E6%A0%BC%E5%BC%8F/3427000?fr=aladdin)格式的图片。\n\n## 有损压缩\n\n指在压缩文件大小的过程中，损失了一部分图片的信息，也即降低了图片的质量（即图片被压糊了），并且这种损失是**不可逆的**。\n\n常见的有损压缩手段是按照一定的算法将**临近的像素点进行合并**。压缩算法不会对图片所有的数据进行编码压缩，而是在压缩的时候，去除了人眼无法识别的图片细节。因此有损压缩可以在同等图片质量的情况下大幅降低图片的体积。例如`jpg`格式的图片使用的就是有损压缩。\n\n## 无损压缩\n\n在压缩图片的过程中，图片的质量没有任何损耗。我们任何时候都可以从无损压缩过的图片中恢复出原来的信息。\n\n压缩算法对图片的所有的**数据进行编码压缩**，能在保证图片的质量的同时降低图片的体积。例如`png`、`gif`使用的就是无损压缩。\n\n# 图片位数\n\n图片位数通常分为8、16、24、32\n\n至于什么是图片位数我们这里就不展开说了，因为展开说又要占不少篇幅，有兴趣的童鞋可以看：\n\n1. [图片位数(bites)的区别](https://blog.csdn.net/huoji555/article/details/78873555)\n2. [图片颜色模式8位，16位和32位的区别是什么](https://zhidao.baidu.com/question/331431582022375125.html)\n3. [位深度](https://baike.baidu.com/item/%E4%BD%8D%E6%B7%B1%E5%BA%A6)\n\n懒得看的童鞋可以直接看结论：\n\n1. 图片位数越大，能表示的颜色越多，同时占用的体积也约大。例如8位图片支持256种颜色，即2的8次方。\n2. 图片位数越大，颜色过渡也就越细腻，携带的色彩信息可以更加丰富。\n3. 32位跟24位的区别就是多了一个Alpha通道，用来支持半透明，其他的跟24位基本一样。\n\n# 常见的图片的格式\n\n## GIF\n\nGIF的全称是Graphics Interchange Format，可译为`图形交换格式`，是在1987年由Compu Serve公司为了填补跨平台图像格式的空白而发展起来的。\n\nGIF采用的是[Lempel-Zev-Welch（LZW）压缩算法](https://baike.baidu.com/item/LZW%E7%AE%97%E6%B3%95/7293853?fr=aladdin)，最高支持256种颜色。由于这种特性，GIF比较适用于色彩较少的图片，比如卡通造型、公司标志等等。如果碰到需要用24位真彩色的场合，那么GIF的表现力就有限了。\n\nGIF格式图片最大的特性是`帧动画`，相比古老的bmp格式，尺寸较小，而且支持透明(不支持半透明，因为不支持 Alpha 透明通道 )和动画。\n\n### 优点\n\n1. 体积小\n2. 支持动画\n\n### 缺点\n\n由于采用了8位压缩，最多只能处理256种颜色\n\n## JPEG/JPG\n\nJPEG是Joint Photographic Experts Group(联合图像专家组)的缩写，文件后辍名为\"．jpg\"或\"．jpeg\"，是常用的图像文件格式，由一个软件开发联合会组织制定，是一种有损压缩格式，能够将图像压缩在很小的储存空间，图像中重复或不重要的资料会被丢失，因此容易造成图像数据的损伤。尤其是使用过高的压缩比例，将使最终解压缩后恢复的图像质量明显降低，如果追求高品质图像，不宜采用过高压缩比例。\n\n### 优点\n\n1. 采用有损压缩，压缩后体积更小\n2. 支持24位真彩色\n3. 支持渐进式加载\n\n### 缺点\n\n1. 有损压缩会损坏图片的质量\n2. 不支持透明/半透明\n\n## 渐进式jpeg(progressive jpeg)图片及其相关\n\n渐进式jpeg是什么鬼？\n\n先上两张图压压惊：\n\n普通jpg：\n\n![normal](/blog/img/img/normal.gif)\n\n渐进式jpg：\n![progressive](/blog/img/img/progressive.gif)\n\n从上面两张图可以看到，普通的jpg是从上往下加载图片的，在网络慢的时候尤为明显。\n\n渐进式jpg文件包含多次扫描，这些扫描顺寻的存储在jpg文件中。打开文件过程中，会先显示整个图片的模糊轮廓，随着扫描次数的增加，图片变得越来越清晰。\n\n至于怎么生成渐进式图片可以看[这里](https://www.zhangxinxu.com/wordpress/2013/01/progressive-jpeg-image-and-so-on/)，本文就不展开说了。\n\n## PNG\n\npng即便携式网络图形是一种无损压缩的位图片形格式，其设计目的是试图替代GIF和TIFF文件格式，同时增加一些GIF文件格式所不具备的特性。PNG使用从[LZ77](https://baike.baidu.com/item/LZ77%E7%BC%96%E7%A0%81/16609862?fr=aladdin)派生的无损数据压缩算法，一般应用于JAVA程序、网页或S60程序中，原因是它压缩比高，生成文件体积小。\n\npng支持8位、24位、32位3种，我们通常叫它们png8、png24、png32。\n\n## png8\n\n8位的png最多支持256(2的8次方)种颜色，png8有1位的布尔透明通道（要么完全透明，要么完全不透明）。\n\n**注意**：png8使用的是索引色模式，png24和png32使用的是rgb色模式。\n\n索引颜色模式是采用一个颜色表存放并索引图像中的颜色使用最多 256 种颜色，当转换为索引颜色时，PS 将构建一个颜色查找表 (CLUT)，用以存放并索引图像中的颜色。\n\n更多关于索引色模式看[这里](https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95%E9%A2%9C%E8%89%B2%E6%A8%A1%E5%BC%8F/7362685)\n\n## PNG24\n\n支持2的24次方种颜色，即rgb分别用8位，不支持透明。\n\n**注意**： png24是不透明的，是不透明的，是不透明的。\n\n这有人就会说了，我用PS导出的png明明是png24的，而且也选了透明了，出来的图就是透明的啊？为什么png24就不透明的了咧？\n\n这个时候可以看图片详情，看看你导出的图片深位度是不是24的？\n\n![深位度](/blog/img/img/deep_digit.gif)\n\n如果是透明的话就是32，否则就是24，只是在你导出的时候PS偷偷帮你转了一下。\n\n## PNG32\n\n它是在png在24位的png基础上增加了8位的透明信息，支持不同程度的半透效果，例如我们`css`设置`rgba(0,0,0,0.5)`。\n","source":"_posts/img-knowledge.md","raw":"---\ntitle: 前端该如何选择图片的格式\ndate: 2020-04-07 13:44:59\ntags: [面试,其他]\n---\n\n想当初，这个问题在面试实习的时候被问到。问题看着简单，但是想要回答好还需要下一番功夫来了解的。\n\n如果不想看文章的话直接翻到文末去看结论即可。\n\n<!-- more -->\n\nso，在开始之前我们先补充一下图片的一些基本知识。\n\n# 图片的类型\n\n首先，我们需要来了解图片的类型。\n\n图片的类型目前就分为两种：\n\n1. 位图\n2. 矢量图\n\n## 位图\n\n所谓位图就是用像素点拼起来的图也叫点阵图，平时我们用到的`png`、`jpg`等图片就是位图。\n\n![bigmap](/blog/img/img/bitmap.png)\n\n如上图，将一张图片放大以后可以看到一个一个小点点，这一个一个小点点就是图片的一个像素。\n\n## 矢量图\n\n矢量图，也叫做向量图。矢量图并不纪录画面上每一点的信息，而是纪录了元素形状及颜色的算法，当你打开一幅矢量图的时候，软件对图形对应的函数进行运算，将运算结果图形的形状和颜色显示给你看。\n\n无论显示画面是大还是小，画面上的对象对应的算法是不变的，所以，即使对画面进行倍数相当大的缩放，它也不会像位图那样会失真。\n\n常见的就是`svg`格式的。\n\n# 图片的压缩类型\n\n1. 无压缩\n2. 有损压缩\n3. 无损压缩\n\n## 无压缩\n\n无压缩的图片格式不对图片数据进行压缩处理，能准确地呈现原图片。例如[BMP](https://baike.baidu.com/item/BMP%E6%A0%BC%E5%BC%8F/3427000?fr=aladdin)格式的图片。\n\n## 有损压缩\n\n指在压缩文件大小的过程中，损失了一部分图片的信息，也即降低了图片的质量（即图片被压糊了），并且这种损失是**不可逆的**。\n\n常见的有损压缩手段是按照一定的算法将**临近的像素点进行合并**。压缩算法不会对图片所有的数据进行编码压缩，而是在压缩的时候，去除了人眼无法识别的图片细节。因此有损压缩可以在同等图片质量的情况下大幅降低图片的体积。例如`jpg`格式的图片使用的就是有损压缩。\n\n## 无损压缩\n\n在压缩图片的过程中，图片的质量没有任何损耗。我们任何时候都可以从无损压缩过的图片中恢复出原来的信息。\n\n压缩算法对图片的所有的**数据进行编码压缩**，能在保证图片的质量的同时降低图片的体积。例如`png`、`gif`使用的就是无损压缩。\n\n# 图片位数\n\n图片位数通常分为8、16、24、32\n\n至于什么是图片位数我们这里就不展开说了，因为展开说又要占不少篇幅，有兴趣的童鞋可以看：\n\n1. [图片位数(bites)的区别](https://blog.csdn.net/huoji555/article/details/78873555)\n2. [图片颜色模式8位，16位和32位的区别是什么](https://zhidao.baidu.com/question/331431582022375125.html)\n3. [位深度](https://baike.baidu.com/item/%E4%BD%8D%E6%B7%B1%E5%BA%A6)\n\n懒得看的童鞋可以直接看结论：\n\n1. 图片位数越大，能表示的颜色越多，同时占用的体积也约大。例如8位图片支持256种颜色，即2的8次方。\n2. 图片位数越大，颜色过渡也就越细腻，携带的色彩信息可以更加丰富。\n3. 32位跟24位的区别就是多了一个Alpha通道，用来支持半透明，其他的跟24位基本一样。\n\n# 常见的图片的格式\n\n## GIF\n\nGIF的全称是Graphics Interchange Format，可译为`图形交换格式`，是在1987年由Compu Serve公司为了填补跨平台图像格式的空白而发展起来的。\n\nGIF采用的是[Lempel-Zev-Welch（LZW）压缩算法](https://baike.baidu.com/item/LZW%E7%AE%97%E6%B3%95/7293853?fr=aladdin)，最高支持256种颜色。由于这种特性，GIF比较适用于色彩较少的图片，比如卡通造型、公司标志等等。如果碰到需要用24位真彩色的场合，那么GIF的表现力就有限了。\n\nGIF格式图片最大的特性是`帧动画`，相比古老的bmp格式，尺寸较小，而且支持透明(不支持半透明，因为不支持 Alpha 透明通道 )和动画。\n\n### 优点\n\n1. 体积小\n2. 支持动画\n\n### 缺点\n\n由于采用了8位压缩，最多只能处理256种颜色\n\n## JPEG/JPG\n\nJPEG是Joint Photographic Experts Group(联合图像专家组)的缩写，文件后辍名为\"．jpg\"或\"．jpeg\"，是常用的图像文件格式，由一个软件开发联合会组织制定，是一种有损压缩格式，能够将图像压缩在很小的储存空间，图像中重复或不重要的资料会被丢失，因此容易造成图像数据的损伤。尤其是使用过高的压缩比例，将使最终解压缩后恢复的图像质量明显降低，如果追求高品质图像，不宜采用过高压缩比例。\n\n### 优点\n\n1. 采用有损压缩，压缩后体积更小\n2. 支持24位真彩色\n3. 支持渐进式加载\n\n### 缺点\n\n1. 有损压缩会损坏图片的质量\n2. 不支持透明/半透明\n\n## 渐进式jpeg(progressive jpeg)图片及其相关\n\n渐进式jpeg是什么鬼？\n\n先上两张图压压惊：\n\n普通jpg：\n\n![normal](/blog/img/img/normal.gif)\n\n渐进式jpg：\n![progressive](/blog/img/img/progressive.gif)\n\n从上面两张图可以看到，普通的jpg是从上往下加载图片的，在网络慢的时候尤为明显。\n\n渐进式jpg文件包含多次扫描，这些扫描顺寻的存储在jpg文件中。打开文件过程中，会先显示整个图片的模糊轮廓，随着扫描次数的增加，图片变得越来越清晰。\n\n至于怎么生成渐进式图片可以看[这里](https://www.zhangxinxu.com/wordpress/2013/01/progressive-jpeg-image-and-so-on/)，本文就不展开说了。\n\n## PNG\n\npng即便携式网络图形是一种无损压缩的位图片形格式，其设计目的是试图替代GIF和TIFF文件格式，同时增加一些GIF文件格式所不具备的特性。PNG使用从[LZ77](https://baike.baidu.com/item/LZ77%E7%BC%96%E7%A0%81/16609862?fr=aladdin)派生的无损数据压缩算法，一般应用于JAVA程序、网页或S60程序中，原因是它压缩比高，生成文件体积小。\n\npng支持8位、24位、32位3种，我们通常叫它们png8、png24、png32。\n\n## png8\n\n8位的png最多支持256(2的8次方)种颜色，png8有1位的布尔透明通道（要么完全透明，要么完全不透明）。\n\n**注意**：png8使用的是索引色模式，png24和png32使用的是rgb色模式。\n\n索引颜色模式是采用一个颜色表存放并索引图像中的颜色使用最多 256 种颜色，当转换为索引颜色时，PS 将构建一个颜色查找表 (CLUT)，用以存放并索引图像中的颜色。\n\n更多关于索引色模式看[这里](https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95%E9%A2%9C%E8%89%B2%E6%A8%A1%E5%BC%8F/7362685)\n\n## PNG24\n\n支持2的24次方种颜色，即rgb分别用8位，不支持透明。\n\n**注意**： png24是不透明的，是不透明的，是不透明的。\n\n这有人就会说了，我用PS导出的png明明是png24的，而且也选了透明了，出来的图就是透明的啊？为什么png24就不透明的了咧？\n\n这个时候可以看图片详情，看看你导出的图片深位度是不是24的？\n\n![深位度](/blog/img/img/deep_digit.gif)\n\n如果是透明的话就是32，否则就是24，只是在你导出的时候PS偷偷帮你转了一下。\n\n## PNG32\n\n它是在png在24位的png基础上增加了8位的透明信息，支持不同程度的半透效果，例如我们`css`设置`rgba(0,0,0,0.5)`。\n","slug":"img-knowledge","published":1,"updated":"2020-04-07T10:27:26.679Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8qzc34t000n2cl6bys40mod","content":"<p>想当初，这个问题在面试实习的时候被问到。问题看着简单，但是想要回答好还需要下一番功夫来了解的。</p>\n<p>如果不想看文章的话直接翻到文末去看结论即可。</p>\n<a id=\"more\"></a>\n<p>so，在开始之前我们先补充一下图片的一些基本知识。</p>\n<h1 id=\"图片的类型\"><a href=\"#图片的类型\" class=\"headerlink\" title=\"图片的类型\"></a>图片的类型</h1><p>首先，我们需要来了解图片的类型。</p>\n<p>图片的类型目前就分为两种：</p>\n<ol>\n<li>位图</li>\n<li>矢量图</li>\n</ol>\n<h2 id=\"位图\"><a href=\"#位图\" class=\"headerlink\" title=\"位图\"></a>位图</h2><p>所谓位图就是用像素点拼起来的图也叫点阵图，平时我们用到的<code>png</code>、<code>jpg</code>等图片就是位图。</p>\n<p><img src=\"/blog/img/img/bitmap.png\" alt=\"bigmap\"></p>\n<p>如上图，将一张图片放大以后可以看到一个一个小点点，这一个一个小点点就是图片的一个像素。</p>\n<h2 id=\"矢量图\"><a href=\"#矢量图\" class=\"headerlink\" title=\"矢量图\"></a>矢量图</h2><p>矢量图，也叫做向量图。矢量图并不纪录画面上每一点的信息，而是纪录了元素形状及颜色的算法，当你打开一幅矢量图的时候，软件对图形对应的函数进行运算，将运算结果图形的形状和颜色显示给你看。</p>\n<p>无论显示画面是大还是小，画面上的对象对应的算法是不变的，所以，即使对画面进行倍数相当大的缩放，它也不会像位图那样会失真。</p>\n<p>常见的就是<code>svg</code>格式的。</p>\n<h1 id=\"图片的压缩类型\"><a href=\"#图片的压缩类型\" class=\"headerlink\" title=\"图片的压缩类型\"></a>图片的压缩类型</h1><ol>\n<li>无压缩</li>\n<li>有损压缩</li>\n<li>无损压缩</li>\n</ol>\n<h2 id=\"无压缩\"><a href=\"#无压缩\" class=\"headerlink\" title=\"无压缩\"></a>无压缩</h2><p>无压缩的图片格式不对图片数据进行压缩处理，能准确地呈现原图片。例如<a href=\"https://baike.baidu.com/item/BMP%E6%A0%BC%E5%BC%8F/3427000?fr=aladdin\" target=\"_blank\" rel=\"noopener\">BMP</a>格式的图片。</p>\n<h2 id=\"有损压缩\"><a href=\"#有损压缩\" class=\"headerlink\" title=\"有损压缩\"></a>有损压缩</h2><p>指在压缩文件大小的过程中，损失了一部分图片的信息，也即降低了图片的质量（即图片被压糊了），并且这种损失是<strong>不可逆的</strong>。</p>\n<p>常见的有损压缩手段是按照一定的算法将<strong>临近的像素点进行合并</strong>。压缩算法不会对图片所有的数据进行编码压缩，而是在压缩的时候，去除了人眼无法识别的图片细节。因此有损压缩可以在同等图片质量的情况下大幅降低图片的体积。例如<code>jpg</code>格式的图片使用的就是有损压缩。</p>\n<h2 id=\"无损压缩\"><a href=\"#无损压缩\" class=\"headerlink\" title=\"无损压缩\"></a>无损压缩</h2><p>在压缩图片的过程中，图片的质量没有任何损耗。我们任何时候都可以从无损压缩过的图片中恢复出原来的信息。</p>\n<p>压缩算法对图片的所有的<strong>数据进行编码压缩</strong>，能在保证图片的质量的同时降低图片的体积。例如<code>png</code>、<code>gif</code>使用的就是无损压缩。</p>\n<h1 id=\"图片位数\"><a href=\"#图片位数\" class=\"headerlink\" title=\"图片位数\"></a>图片位数</h1><p>图片位数通常分为8、16、24、32</p>\n<p>至于什么是图片位数我们这里就不展开说了，因为展开说又要占不少篇幅，有兴趣的童鞋可以看：</p>\n<ol>\n<li><a href=\"https://blog.csdn.net/huoji555/article/details/78873555\" target=\"_blank\" rel=\"noopener\">图片位数(bites)的区别</a></li>\n<li><a href=\"https://zhidao.baidu.com/question/331431582022375125.html\" target=\"_blank\" rel=\"noopener\">图片颜色模式8位，16位和32位的区别是什么</a></li>\n<li><a href=\"https://baike.baidu.com/item/%E4%BD%8D%E6%B7%B1%E5%BA%A6\" target=\"_blank\" rel=\"noopener\">位深度</a></li>\n</ol>\n<p>懒得看的童鞋可以直接看结论：</p>\n<ol>\n<li>图片位数越大，能表示的颜色越多，同时占用的体积也约大。例如8位图片支持256种颜色，即2的8次方。</li>\n<li>图片位数越大，颜色过渡也就越细腻，携带的色彩信息可以更加丰富。</li>\n<li>32位跟24位的区别就是多了一个Alpha通道，用来支持半透明，其他的跟24位基本一样。</li>\n</ol>\n<h1 id=\"常见的图片的格式\"><a href=\"#常见的图片的格式\" class=\"headerlink\" title=\"常见的图片的格式\"></a>常见的图片的格式</h1><h2 id=\"GIF\"><a href=\"#GIF\" class=\"headerlink\" title=\"GIF\"></a>GIF</h2><p>GIF的全称是Graphics Interchange Format，可译为<code>图形交换格式</code>，是在1987年由Compu Serve公司为了填补跨平台图像格式的空白而发展起来的。</p>\n<p>GIF采用的是<a href=\"https://baike.baidu.com/item/LZW%E7%AE%97%E6%B3%95/7293853?fr=aladdin\" target=\"_blank\" rel=\"noopener\">Lempel-Zev-Welch（LZW）压缩算法</a>，最高支持256种颜色。由于这种特性，GIF比较适用于色彩较少的图片，比如卡通造型、公司标志等等。如果碰到需要用24位真彩色的场合，那么GIF的表现力就有限了。</p>\n<p>GIF格式图片最大的特性是<code>帧动画</code>，相比古老的bmp格式，尺寸较小，而且支持透明(不支持半透明，因为不支持 Alpha 透明通道 )和动画。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ol>\n<li>体积小</li>\n<li>支持动画</li>\n</ol>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>由于采用了8位压缩，最多只能处理256种颜色</p>\n<h2 id=\"JPEG-JPG\"><a href=\"#JPEG-JPG\" class=\"headerlink\" title=\"JPEG/JPG\"></a>JPEG/JPG</h2><p>JPEG是Joint Photographic Experts Group(联合图像专家组)的缩写，文件后辍名为”．jpg”或”．jpeg”，是常用的图像文件格式，由一个软件开发联合会组织制定，是一种有损压缩格式，能够将图像压缩在很小的储存空间，图像中重复或不重要的资料会被丢失，因此容易造成图像数据的损伤。尤其是使用过高的压缩比例，将使最终解压缩后恢复的图像质量明显降低，如果追求高品质图像，不宜采用过高压缩比例。</p>\n<h3 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ol>\n<li>采用有损压缩，压缩后体积更小</li>\n<li>支持24位真彩色</li>\n<li>支持渐进式加载</li>\n</ol>\n<h3 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ol>\n<li>有损压缩会损坏图片的质量</li>\n<li>不支持透明/半透明</li>\n</ol>\n<h2 id=\"渐进式jpeg-progressive-jpeg-图片及其相关\"><a href=\"#渐进式jpeg-progressive-jpeg-图片及其相关\" class=\"headerlink\" title=\"渐进式jpeg(progressive jpeg)图片及其相关\"></a>渐进式jpeg(progressive jpeg)图片及其相关</h2><p>渐进式jpeg是什么鬼？</p>\n<p>先上两张图压压惊：</p>\n<p>普通jpg：</p>\n<p><img src=\"/blog/img/img/normal.gif\" alt=\"normal\"></p>\n<p>渐进式jpg：<br><img src=\"/blog/img/img/progressive.gif\" alt=\"progressive\"></p>\n<p>从上面两张图可以看到，普通的jpg是从上往下加载图片的，在网络慢的时候尤为明显。</p>\n<p>渐进式jpg文件包含多次扫描，这些扫描顺寻的存储在jpg文件中。打开文件过程中，会先显示整个图片的模糊轮廓，随着扫描次数的增加，图片变得越来越清晰。</p>\n<p>至于怎么生成渐进式图片可以看<a href=\"https://www.zhangxinxu.com/wordpress/2013/01/progressive-jpeg-image-and-so-on/\" target=\"_blank\" rel=\"noopener\">这里</a>，本文就不展开说了。</p>\n<h2 id=\"PNG\"><a href=\"#PNG\" class=\"headerlink\" title=\"PNG\"></a>PNG</h2><p>png即便携式网络图形是一种无损压缩的位图片形格式，其设计目的是试图替代GIF和TIFF文件格式，同时增加一些GIF文件格式所不具备的特性。PNG使用从<a href=\"https://baike.baidu.com/item/LZ77%E7%BC%96%E7%A0%81/16609862?fr=aladdin\" target=\"_blank\" rel=\"noopener\">LZ77</a>派生的无损数据压缩算法，一般应用于JAVA程序、网页或S60程序中，原因是它压缩比高，生成文件体积小。</p>\n<p>png支持8位、24位、32位3种，我们通常叫它们png8、png24、png32。</p>\n<h2 id=\"png8\"><a href=\"#png8\" class=\"headerlink\" title=\"png8\"></a>png8</h2><p>8位的png最多支持256(2的8次方)种颜色，png8有1位的布尔透明通道（要么完全透明，要么完全不透明）。</p>\n<p><strong>注意</strong>：png8使用的是索引色模式，png24和png32使用的是rgb色模式。</p>\n<p>索引颜色模式是采用一个颜色表存放并索引图像中的颜色使用最多 256 种颜色，当转换为索引颜色时，PS 将构建一个颜色查找表 (CLUT)，用以存放并索引图像中的颜色。</p>\n<p>更多关于索引色模式看<a href=\"https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95%E9%A2%9C%E8%89%B2%E6%A8%A1%E5%BC%8F/7362685\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h2 id=\"PNG24\"><a href=\"#PNG24\" class=\"headerlink\" title=\"PNG24\"></a>PNG24</h2><p>支持2的24次方种颜色，即rgb分别用8位，不支持透明。</p>\n<p><strong>注意</strong>： png24是不透明的，是不透明的，是不透明的。</p>\n<p>这有人就会说了，我用PS导出的png明明是png24的，而且也选了透明了，出来的图就是透明的啊？为什么png24就不透明的了咧？</p>\n<p>这个时候可以看图片详情，看看你导出的图片深位度是不是24的？</p>\n<p><img src=\"/blog/img/img/deep_digit.gif\" alt=\"深位度\"></p>\n<p>如果是透明的话就是32，否则就是24，只是在你导出的时候PS偷偷帮你转了一下。</p>\n<h2 id=\"PNG32\"><a href=\"#PNG32\" class=\"headerlink\" title=\"PNG32\"></a>PNG32</h2><p>它是在png在24位的png基础上增加了8位的透明信息，支持不同程度的半透效果，例如我们<code>css</code>设置<code>rgba(0,0,0,0.5)</code>。</p>\n","site":{"data":{}},"excerpt":"<p>想当初，这个问题在面试实习的时候被问到。问题看着简单，但是想要回答好还需要下一番功夫来了解的。</p>\n<p>如果不想看文章的话直接翻到文末去看结论即可。</p>","more":"<p>so，在开始之前我们先补充一下图片的一些基本知识。</p>\n<h1 id=\"图片的类型\"><a href=\"#图片的类型\" class=\"headerlink\" title=\"图片的类型\"></a>图片的类型</h1><p>首先，我们需要来了解图片的类型。</p>\n<p>图片的类型目前就分为两种：</p>\n<ol>\n<li>位图</li>\n<li>矢量图</li>\n</ol>\n<h2 id=\"位图\"><a href=\"#位图\" class=\"headerlink\" title=\"位图\"></a>位图</h2><p>所谓位图就是用像素点拼起来的图也叫点阵图，平时我们用到的<code>png</code>、<code>jpg</code>等图片就是位图。</p>\n<p><img src=\"/blog/img/img/bitmap.png\" alt=\"bigmap\"></p>\n<p>如上图，将一张图片放大以后可以看到一个一个小点点，这一个一个小点点就是图片的一个像素。</p>\n<h2 id=\"矢量图\"><a href=\"#矢量图\" class=\"headerlink\" title=\"矢量图\"></a>矢量图</h2><p>矢量图，也叫做向量图。矢量图并不纪录画面上每一点的信息，而是纪录了元素形状及颜色的算法，当你打开一幅矢量图的时候，软件对图形对应的函数进行运算，将运算结果图形的形状和颜色显示给你看。</p>\n<p>无论显示画面是大还是小，画面上的对象对应的算法是不变的，所以，即使对画面进行倍数相当大的缩放，它也不会像位图那样会失真。</p>\n<p>常见的就是<code>svg</code>格式的。</p>\n<h1 id=\"图片的压缩类型\"><a href=\"#图片的压缩类型\" class=\"headerlink\" title=\"图片的压缩类型\"></a>图片的压缩类型</h1><ol>\n<li>无压缩</li>\n<li>有损压缩</li>\n<li>无损压缩</li>\n</ol>\n<h2 id=\"无压缩\"><a href=\"#无压缩\" class=\"headerlink\" title=\"无压缩\"></a>无压缩</h2><p>无压缩的图片格式不对图片数据进行压缩处理，能准确地呈现原图片。例如<a href=\"https://baike.baidu.com/item/BMP%E6%A0%BC%E5%BC%8F/3427000?fr=aladdin\" target=\"_blank\" rel=\"noopener\">BMP</a>格式的图片。</p>\n<h2 id=\"有损压缩\"><a href=\"#有损压缩\" class=\"headerlink\" title=\"有损压缩\"></a>有损压缩</h2><p>指在压缩文件大小的过程中，损失了一部分图片的信息，也即降低了图片的质量（即图片被压糊了），并且这种损失是<strong>不可逆的</strong>。</p>\n<p>常见的有损压缩手段是按照一定的算法将<strong>临近的像素点进行合并</strong>。压缩算法不会对图片所有的数据进行编码压缩，而是在压缩的时候，去除了人眼无法识别的图片细节。因此有损压缩可以在同等图片质量的情况下大幅降低图片的体积。例如<code>jpg</code>格式的图片使用的就是有损压缩。</p>\n<h2 id=\"无损压缩\"><a href=\"#无损压缩\" class=\"headerlink\" title=\"无损压缩\"></a>无损压缩</h2><p>在压缩图片的过程中，图片的质量没有任何损耗。我们任何时候都可以从无损压缩过的图片中恢复出原来的信息。</p>\n<p>压缩算法对图片的所有的<strong>数据进行编码压缩</strong>，能在保证图片的质量的同时降低图片的体积。例如<code>png</code>、<code>gif</code>使用的就是无损压缩。</p>\n<h1 id=\"图片位数\"><a href=\"#图片位数\" class=\"headerlink\" title=\"图片位数\"></a>图片位数</h1><p>图片位数通常分为8、16、24、32</p>\n<p>至于什么是图片位数我们这里就不展开说了，因为展开说又要占不少篇幅，有兴趣的童鞋可以看：</p>\n<ol>\n<li><a href=\"https://blog.csdn.net/huoji555/article/details/78873555\" target=\"_blank\" rel=\"noopener\">图片位数(bites)的区别</a></li>\n<li><a href=\"https://zhidao.baidu.com/question/331431582022375125.html\" target=\"_blank\" rel=\"noopener\">图片颜色模式8位，16位和32位的区别是什么</a></li>\n<li><a href=\"https://baike.baidu.com/item/%E4%BD%8D%E6%B7%B1%E5%BA%A6\" target=\"_blank\" rel=\"noopener\">位深度</a></li>\n</ol>\n<p>懒得看的童鞋可以直接看结论：</p>\n<ol>\n<li>图片位数越大，能表示的颜色越多，同时占用的体积也约大。例如8位图片支持256种颜色，即2的8次方。</li>\n<li>图片位数越大，颜色过渡也就越细腻，携带的色彩信息可以更加丰富。</li>\n<li>32位跟24位的区别就是多了一个Alpha通道，用来支持半透明，其他的跟24位基本一样。</li>\n</ol>\n<h1 id=\"常见的图片的格式\"><a href=\"#常见的图片的格式\" class=\"headerlink\" title=\"常见的图片的格式\"></a>常见的图片的格式</h1><h2 id=\"GIF\"><a href=\"#GIF\" class=\"headerlink\" title=\"GIF\"></a>GIF</h2><p>GIF的全称是Graphics Interchange Format，可译为<code>图形交换格式</code>，是在1987年由Compu Serve公司为了填补跨平台图像格式的空白而发展起来的。</p>\n<p>GIF采用的是<a href=\"https://baike.baidu.com/item/LZW%E7%AE%97%E6%B3%95/7293853?fr=aladdin\" target=\"_blank\" rel=\"noopener\">Lempel-Zev-Welch（LZW）压缩算法</a>，最高支持256种颜色。由于这种特性，GIF比较适用于色彩较少的图片，比如卡通造型、公司标志等等。如果碰到需要用24位真彩色的场合，那么GIF的表现力就有限了。</p>\n<p>GIF格式图片最大的特性是<code>帧动画</code>，相比古老的bmp格式，尺寸较小，而且支持透明(不支持半透明，因为不支持 Alpha 透明通道 )和动画。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ol>\n<li>体积小</li>\n<li>支持动画</li>\n</ol>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>由于采用了8位压缩，最多只能处理256种颜色</p>\n<h2 id=\"JPEG-JPG\"><a href=\"#JPEG-JPG\" class=\"headerlink\" title=\"JPEG/JPG\"></a>JPEG/JPG</h2><p>JPEG是Joint Photographic Experts Group(联合图像专家组)的缩写，文件后辍名为”．jpg”或”．jpeg”，是常用的图像文件格式，由一个软件开发联合会组织制定，是一种有损压缩格式，能够将图像压缩在很小的储存空间，图像中重复或不重要的资料会被丢失，因此容易造成图像数据的损伤。尤其是使用过高的压缩比例，将使最终解压缩后恢复的图像质量明显降低，如果追求高品质图像，不宜采用过高压缩比例。</p>\n<h3 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ol>\n<li>采用有损压缩，压缩后体积更小</li>\n<li>支持24位真彩色</li>\n<li>支持渐进式加载</li>\n</ol>\n<h3 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ol>\n<li>有损压缩会损坏图片的质量</li>\n<li>不支持透明/半透明</li>\n</ol>\n<h2 id=\"渐进式jpeg-progressive-jpeg-图片及其相关\"><a href=\"#渐进式jpeg-progressive-jpeg-图片及其相关\" class=\"headerlink\" title=\"渐进式jpeg(progressive jpeg)图片及其相关\"></a>渐进式jpeg(progressive jpeg)图片及其相关</h2><p>渐进式jpeg是什么鬼？</p>\n<p>先上两张图压压惊：</p>\n<p>普通jpg：</p>\n<p><img src=\"/blog/img/img/normal.gif\" alt=\"normal\"></p>\n<p>渐进式jpg：<br><img src=\"/blog/img/img/progressive.gif\" alt=\"progressive\"></p>\n<p>从上面两张图可以看到，普通的jpg是从上往下加载图片的，在网络慢的时候尤为明显。</p>\n<p>渐进式jpg文件包含多次扫描，这些扫描顺寻的存储在jpg文件中。打开文件过程中，会先显示整个图片的模糊轮廓，随着扫描次数的增加，图片变得越来越清晰。</p>\n<p>至于怎么生成渐进式图片可以看<a href=\"https://www.zhangxinxu.com/wordpress/2013/01/progressive-jpeg-image-and-so-on/\" target=\"_blank\" rel=\"noopener\">这里</a>，本文就不展开说了。</p>\n<h2 id=\"PNG\"><a href=\"#PNG\" class=\"headerlink\" title=\"PNG\"></a>PNG</h2><p>png即便携式网络图形是一种无损压缩的位图片形格式，其设计目的是试图替代GIF和TIFF文件格式，同时增加一些GIF文件格式所不具备的特性。PNG使用从<a href=\"https://baike.baidu.com/item/LZ77%E7%BC%96%E7%A0%81/16609862?fr=aladdin\" target=\"_blank\" rel=\"noopener\">LZ77</a>派生的无损数据压缩算法，一般应用于JAVA程序、网页或S60程序中，原因是它压缩比高，生成文件体积小。</p>\n<p>png支持8位、24位、32位3种，我们通常叫它们png8、png24、png32。</p>\n<h2 id=\"png8\"><a href=\"#png8\" class=\"headerlink\" title=\"png8\"></a>png8</h2><p>8位的png最多支持256(2的8次方)种颜色，png8有1位的布尔透明通道（要么完全透明，要么完全不透明）。</p>\n<p><strong>注意</strong>：png8使用的是索引色模式，png24和png32使用的是rgb色模式。</p>\n<p>索引颜色模式是采用一个颜色表存放并索引图像中的颜色使用最多 256 种颜色，当转换为索引颜色时，PS 将构建一个颜色查找表 (CLUT)，用以存放并索引图像中的颜色。</p>\n<p>更多关于索引色模式看<a href=\"https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95%E9%A2%9C%E8%89%B2%E6%A8%A1%E5%BC%8F/7362685\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h2 id=\"PNG24\"><a href=\"#PNG24\" class=\"headerlink\" title=\"PNG24\"></a>PNG24</h2><p>支持2的24次方种颜色，即rgb分别用8位，不支持透明。</p>\n<p><strong>注意</strong>： png24是不透明的，是不透明的，是不透明的。</p>\n<p>这有人就会说了，我用PS导出的png明明是png24的，而且也选了透明了，出来的图就是透明的啊？为什么png24就不透明的了咧？</p>\n<p>这个时候可以看图片详情，看看你导出的图片深位度是不是24的？</p>\n<p><img src=\"/blog/img/img/deep_digit.gif\" alt=\"深位度\"></p>\n<p>如果是透明的话就是32，否则就是24，只是在你导出的时候PS偷偷帮你转了一下。</p>\n<h2 id=\"PNG32\"><a href=\"#PNG32\" class=\"headerlink\" title=\"PNG32\"></a>PNG32</h2><p>它是在png在24位的png基础上增加了8位的透明信息，支持不同程度的半透效果，例如我们<code>css</code>设置<code>rgba(0,0,0,0.5)</code>。</p>"},{"title":"记一次我看红宝书对继承加深的理解","date":"2018-02-27T02:44:29.000Z","_content":"\n## 前言\n\n[知乎](https://zhuanlan.zhihu.com/p/34123800)\n\n趁着目前手头上没啥事，赶紧写篇文章，emm...。\n\n红宝书不愧是红宝书，每看一次都会有新的收获，呃，废话不多说，直接进入正题吧。\n\n此文章默认您已经对原型、原型链、对象实例、new的过程有了一定的理解，如不理解的请自行查阅相关资料。\n\n另外，以下实例代码变量名、函数、变量值名我做了一定的修改，其大体思路和红宝书里的一样。\n\n<!-- more-->\n\n## 正文\n\n在红宝书中，给出了以下继承方式：\n\n1. 原型链实现继承\n2. 借用构造函数\n3. 组合继承\n4. 原型式继承\n5. 寄生式继承\n6. 寄生组合式继承\n\n接下来就一一对它们进行分析。\n\n### 原型链实现继承\n\n话不多说，先上代码：\n\n```javascript\nfunction Parent() {\n    this.parent = 'parent';\n}\n\nParent.prototype.getParent = function(){\n    return this.parent;\n}\n\nfunction Son(){\n    this.son = 'son';\n}\n\nSon.prototype = new Parent(); //这句代码是实现继承的核心\nSon.prototype.getSon = function(){\n    return this.son;\n}\n```\n\n其思路就是让儿子的原型对象等于父亲new出来的实例；我们知道new出来的实例对象上会有其构造函数拥有的一系列属性。让儿子的原型等于这个实例自然就继承了父亲的一系列东西。\n\n这个时候我们运行：\n```javascript\nvar son = new Son();\nson.getParent(); //parent\nson.getSon(); //son\n```\n以上代码能正常运行的。\n\n这个时候`son.constructor`是指向`Parent`的，因为`new Parent`出来的对象的`constructor`是指向`Parent`的，然后Son的`prototype`对象指向了这个new出来的对象，所以Son的`constructor`自然指向`Parent`。\n\n这个时候我们来梳理一下它们之间的关系：\n\n`son.__proto__ => Son.prototype => Parent new出来的实例对象.__proto__ => Parent.prototype`\n\n因此当调用son.getParent()时实际上会经历三个搜索步骤：\n\n1. 搜索son\n2. 搜索son.__proto__（也就是new Parent()这个对象）\n3. 搜索son.__proto__.__proto__（也就是new Parent().__proto__即Parent.prototype）\n\n但是，使用原型链实现继承会有缺点，先上代码：\n```javscript\nfunction Parent(){\n    this.child = [1]\n}\nfunction Son() {}\nSon.prototype = new Parent();\nvar son1 = new Son();\nson1.child.push(2);\nvar son2 = new Son();\nson2.child.push(3);\nson2.child //[1,2,3]\n```\n出现这种情况的原因是，所有实例都**共享**构造函数的prototype。\n\n这个可以通过`son1.__proto__ === son2.__proto__ //true`和`son1.child === son2.child //true`来证明\n\n为了解决这种问题，于是就出现了以下的方法：借用构造函数。\n\n### 借用构造函数\n\n惯例，先上代码：\n```javascript\nfunction Parent(){\n    this.child = [1];\n    this.getChild = function(){\n        return this.child;\n    }\n}\nfunction Son() {\n    Parent.call(this);\n}\nvar son1 = new Son();\nson1.child.push(2);\nson1.child //[1,2]\nvar son2 = new Son();\nson2.child.push(3);\nson2.child //[1,3]\n```\n\n可以看到，以上的引用问题解决了，但是，出现了一个与构造函数模式一样的问题，方法都在构造函数中定义，导致函数不能复用，所以，继续升级。\n\n### 组合继承\n\n```javascript\nfunction Parent(){\n    this.child = [1]\n}\nParent.prototype.getChild = function(){\n    return this.child;\n}\nfunction Son() {\n    Parent.call(this);\n    this.friend = 'Jay Zangwill';\n}\nSon.prototype = new Parent();\nSon.prototype.getFriend = function(){\n    return this.friend;\n}\nvar son1 = new Son();\nson1.child.push(2);\nson1.getChild(); //[1,2]\nvar son2 = new Son();\nson2.getChild(); //[1]\nson2.getFriend(); // Jay Zangwill\n```\n\n这个方法解决了原型链继承的引用bug同时也解决了函数复用的问题，但是缺点也很明显，那就是调用了两次`Parent`函数，最终导致实例对象上有`child`属性原型链上也有这个属性。\n\n在介绍升级方法前先介绍两种基础方法。\n\n### 原型式继承\n\n```javascript\nvar original = {\n    child:[1],\n    name:'Jay Zangwill'\n}\nfunction parent(obj){\n    function F(){}\n    F.prototype = obj\n    return new F();\n}\nvar son1 = parent(original);\nson1.child.push(2);\nson1.name = 'a';\nvar son2 = parent(original);\nson2.child.push(3);\nson2.child //[1,2,3];\nson2.name = 'b';\nson1.name //a\nson2.name //b\n```\n这种继承方式得需要一个原始对象作为参考，这个方式的主要目的是与另一个对象保持类似。\n在es5中新增了一个Object.create()方法来实现原型式继承，[传送门](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create)。\n\n### 寄生式继承\n\n寄生式继承是原型式继承的增强版：\n```javascript\nfunction createObj(obj) {\n    var clone = parent(obj);\n    clone.getChild = function(){\n        return this.child;\n    }\n}\n```\n\n这个方法与借用构造函数方法有个共同的缺点，就是方法没法复用。\n\n### 寄生组合式继承\n\n```javascript\nfunction createObj(obj){\n    function F(){};\n    F.prototype = obj;\n    return new F();\n}\nfunction inherirPrototype(parent,son) {\n    var prototype = createObj(parent.prototype);\n    prototype.constructor = son;\n    son.prototype = prototype;   \n}\nfunction Parent(name){\n    this.name = name;\n    this.child = [1];\n}\nParent.prototype.getChild= function(){\n    return this.child;\n}\nfunction Son(name) {\n    Parent.call(this,name);\n    this.friend = [2];\n}\n\ninherirPrototype(Parent,Son);\n\nSon.prototype.getFriend = function(){\n    return this.friend;\n}\nvar son1 = new Son('Jay');\nson1.child.push(2);\nson1.getChild() //[1,2];\nson2=new Son('Zangwill');\nson2.child.push(3);\nson2.getChild() //[1,3]\nson2.getFriend() //[2]\n```\n\n可以看到上面代码只调用了一次`Parent`没有生成多余的属性，同时还解决了使用原型方法时Son不能向Parent传值的问题，也没有属性引用的问题。\n\n寄生组合式继承的大体思路是，通过借用构造函数模式来继承属性，通过原型链来继承方法。通过原型链继承方法无非就是想要得到父类的`prototype`对象，所以我们得想办法来拿到这个副本。而`createObj`函数就是干这事的。\n\n可能有人会问：`var prototype = createObj(parent.prototype);`这句代码直接改成`var prototype = parent.prototype`不行吗？\n\n答案是：肯定不行，要是这么改，要想在`Son.prototype`上加东西也会间接加到`Parent.prototype`上。\n\n不过，在es5中，可以把`var prototype = createObj(parent.prototype);`换成`var prototype = Object.create(parent.prototype);`\n\n它们之间的关系如下：\n\n`实例(也就是son1和son2).__proto__ => Son.prototype => 中间函数的实例(也就是F).__proto__ => 中间函数.prototype => Parent.prototype`\n\n### es6中的继承\n\n在es6中，引入了`class`，这相当于是一个语法糖，这里我就直接上代码不展开说了，想要了解更多的话进入[传送门](http://es6.ruanyifeng.com/#docs/class)。\n\n```javascript\nclass Parent {\n    constructor(name) {\n        this.name = name;\n    }\n    getName(){\n        console.log(this.name);\n    }\n}\nclass Son extends Parent {\n    constructor(name,age) {\n        super(name);\n        this.age = age;\n    }\n    getAge(){\n        console.log(this.age);\n    }\n    let son = new Son('Jay', 18);\n    son.getAge() //18\n    son.getName(); //Jay\n}\n```\n","source":"_posts/inherit.md","raw":"---\ntitle: 记一次我看红宝书对继承加深的理解\ndate: 2018-02-27 10:44:29\ntags: [基础,javascript]\n---\n\n## 前言\n\n[知乎](https://zhuanlan.zhihu.com/p/34123800)\n\n趁着目前手头上没啥事，赶紧写篇文章，emm...。\n\n红宝书不愧是红宝书，每看一次都会有新的收获，呃，废话不多说，直接进入正题吧。\n\n此文章默认您已经对原型、原型链、对象实例、new的过程有了一定的理解，如不理解的请自行查阅相关资料。\n\n另外，以下实例代码变量名、函数、变量值名我做了一定的修改，其大体思路和红宝书里的一样。\n\n<!-- more-->\n\n## 正文\n\n在红宝书中，给出了以下继承方式：\n\n1. 原型链实现继承\n2. 借用构造函数\n3. 组合继承\n4. 原型式继承\n5. 寄生式继承\n6. 寄生组合式继承\n\n接下来就一一对它们进行分析。\n\n### 原型链实现继承\n\n话不多说，先上代码：\n\n```javascript\nfunction Parent() {\n    this.parent = 'parent';\n}\n\nParent.prototype.getParent = function(){\n    return this.parent;\n}\n\nfunction Son(){\n    this.son = 'son';\n}\n\nSon.prototype = new Parent(); //这句代码是实现继承的核心\nSon.prototype.getSon = function(){\n    return this.son;\n}\n```\n\n其思路就是让儿子的原型对象等于父亲new出来的实例；我们知道new出来的实例对象上会有其构造函数拥有的一系列属性。让儿子的原型等于这个实例自然就继承了父亲的一系列东西。\n\n这个时候我们运行：\n```javascript\nvar son = new Son();\nson.getParent(); //parent\nson.getSon(); //son\n```\n以上代码能正常运行的。\n\n这个时候`son.constructor`是指向`Parent`的，因为`new Parent`出来的对象的`constructor`是指向`Parent`的，然后Son的`prototype`对象指向了这个new出来的对象，所以Son的`constructor`自然指向`Parent`。\n\n这个时候我们来梳理一下它们之间的关系：\n\n`son.__proto__ => Son.prototype => Parent new出来的实例对象.__proto__ => Parent.prototype`\n\n因此当调用son.getParent()时实际上会经历三个搜索步骤：\n\n1. 搜索son\n2. 搜索son.__proto__（也就是new Parent()这个对象）\n3. 搜索son.__proto__.__proto__（也就是new Parent().__proto__即Parent.prototype）\n\n但是，使用原型链实现继承会有缺点，先上代码：\n```javscript\nfunction Parent(){\n    this.child = [1]\n}\nfunction Son() {}\nSon.prototype = new Parent();\nvar son1 = new Son();\nson1.child.push(2);\nvar son2 = new Son();\nson2.child.push(3);\nson2.child //[1,2,3]\n```\n出现这种情况的原因是，所有实例都**共享**构造函数的prototype。\n\n这个可以通过`son1.__proto__ === son2.__proto__ //true`和`son1.child === son2.child //true`来证明\n\n为了解决这种问题，于是就出现了以下的方法：借用构造函数。\n\n### 借用构造函数\n\n惯例，先上代码：\n```javascript\nfunction Parent(){\n    this.child = [1];\n    this.getChild = function(){\n        return this.child;\n    }\n}\nfunction Son() {\n    Parent.call(this);\n}\nvar son1 = new Son();\nson1.child.push(2);\nson1.child //[1,2]\nvar son2 = new Son();\nson2.child.push(3);\nson2.child //[1,3]\n```\n\n可以看到，以上的引用问题解决了，但是，出现了一个与构造函数模式一样的问题，方法都在构造函数中定义，导致函数不能复用，所以，继续升级。\n\n### 组合继承\n\n```javascript\nfunction Parent(){\n    this.child = [1]\n}\nParent.prototype.getChild = function(){\n    return this.child;\n}\nfunction Son() {\n    Parent.call(this);\n    this.friend = 'Jay Zangwill';\n}\nSon.prototype = new Parent();\nSon.prototype.getFriend = function(){\n    return this.friend;\n}\nvar son1 = new Son();\nson1.child.push(2);\nson1.getChild(); //[1,2]\nvar son2 = new Son();\nson2.getChild(); //[1]\nson2.getFriend(); // Jay Zangwill\n```\n\n这个方法解决了原型链继承的引用bug同时也解决了函数复用的问题，但是缺点也很明显，那就是调用了两次`Parent`函数，最终导致实例对象上有`child`属性原型链上也有这个属性。\n\n在介绍升级方法前先介绍两种基础方法。\n\n### 原型式继承\n\n```javascript\nvar original = {\n    child:[1],\n    name:'Jay Zangwill'\n}\nfunction parent(obj){\n    function F(){}\n    F.prototype = obj\n    return new F();\n}\nvar son1 = parent(original);\nson1.child.push(2);\nson1.name = 'a';\nvar son2 = parent(original);\nson2.child.push(3);\nson2.child //[1,2,3];\nson2.name = 'b';\nson1.name //a\nson2.name //b\n```\n这种继承方式得需要一个原始对象作为参考，这个方式的主要目的是与另一个对象保持类似。\n在es5中新增了一个Object.create()方法来实现原型式继承，[传送门](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create)。\n\n### 寄生式继承\n\n寄生式继承是原型式继承的增强版：\n```javascript\nfunction createObj(obj) {\n    var clone = parent(obj);\n    clone.getChild = function(){\n        return this.child;\n    }\n}\n```\n\n这个方法与借用构造函数方法有个共同的缺点，就是方法没法复用。\n\n### 寄生组合式继承\n\n```javascript\nfunction createObj(obj){\n    function F(){};\n    F.prototype = obj;\n    return new F();\n}\nfunction inherirPrototype(parent,son) {\n    var prototype = createObj(parent.prototype);\n    prototype.constructor = son;\n    son.prototype = prototype;   \n}\nfunction Parent(name){\n    this.name = name;\n    this.child = [1];\n}\nParent.prototype.getChild= function(){\n    return this.child;\n}\nfunction Son(name) {\n    Parent.call(this,name);\n    this.friend = [2];\n}\n\ninherirPrototype(Parent,Son);\n\nSon.prototype.getFriend = function(){\n    return this.friend;\n}\nvar son1 = new Son('Jay');\nson1.child.push(2);\nson1.getChild() //[1,2];\nson2=new Son('Zangwill');\nson2.child.push(3);\nson2.getChild() //[1,3]\nson2.getFriend() //[2]\n```\n\n可以看到上面代码只调用了一次`Parent`没有生成多余的属性，同时还解决了使用原型方法时Son不能向Parent传值的问题，也没有属性引用的问题。\n\n寄生组合式继承的大体思路是，通过借用构造函数模式来继承属性，通过原型链来继承方法。通过原型链继承方法无非就是想要得到父类的`prototype`对象，所以我们得想办法来拿到这个副本。而`createObj`函数就是干这事的。\n\n可能有人会问：`var prototype = createObj(parent.prototype);`这句代码直接改成`var prototype = parent.prototype`不行吗？\n\n答案是：肯定不行，要是这么改，要想在`Son.prototype`上加东西也会间接加到`Parent.prototype`上。\n\n不过，在es5中，可以把`var prototype = createObj(parent.prototype);`换成`var prototype = Object.create(parent.prototype);`\n\n它们之间的关系如下：\n\n`实例(也就是son1和son2).__proto__ => Son.prototype => 中间函数的实例(也就是F).__proto__ => 中间函数.prototype => Parent.prototype`\n\n### es6中的继承\n\n在es6中，引入了`class`，这相当于是一个语法糖，这里我就直接上代码不展开说了，想要了解更多的话进入[传送门](http://es6.ruanyifeng.com/#docs/class)。\n\n```javascript\nclass Parent {\n    constructor(name) {\n        this.name = name;\n    }\n    getName(){\n        console.log(this.name);\n    }\n}\nclass Son extends Parent {\n    constructor(name,age) {\n        super(name);\n        this.age = age;\n    }\n    getAge(){\n        console.log(this.age);\n    }\n    let son = new Son('Jay', 18);\n    son.getAge() //18\n    son.getName(); //Jay\n}\n```\n","slug":"inherit","published":1,"updated":"2020-04-07T03:29:17.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8qzc34w000p2cl66oprvg8i","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><a href=\"https://zhuanlan.zhihu.com/p/34123800\" target=\"_blank\" rel=\"noopener\">知乎</a></p>\n<p>趁着目前手头上没啥事，赶紧写篇文章，emm…。</p>\n<p>红宝书不愧是红宝书，每看一次都会有新的收获，呃，废话不多说，直接进入正题吧。</p>\n<p>此文章默认您已经对原型、原型链、对象实例、new的过程有了一定的理解，如不理解的请自行查阅相关资料。</p>\n<p>另外，以下实例代码变量名、函数、变量值名我做了一定的修改，其大体思路和红宝书里的一样。</p>\n<a id=\"more\"></a>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>在红宝书中，给出了以下继承方式：</p>\n<ol>\n<li>原型链实现继承</li>\n<li>借用构造函数</li>\n<li>组合继承</li>\n<li>原型式继承</li>\n<li>寄生式继承</li>\n<li>寄生组合式继承</li>\n</ol>\n<p>接下来就一一对它们进行分析。</p>\n<h3 id=\"原型链实现继承\"><a href=\"#原型链实现继承\" class=\"headerlink\" title=\"原型链实现继承\"></a>原型链实现继承</h3><p>话不多说，先上代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.parent = <span class=\"string\">'parent'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.getParent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.parent;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Son</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.son = <span class=\"string\">'son'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Son.prototype = <span class=\"keyword\">new</span> Parent(); <span class=\"comment\">//这句代码是实现继承的核心</span></span><br><span class=\"line\">Son.prototype.getSon = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.son;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其思路就是让儿子的原型对象等于父亲new出来的实例；我们知道new出来的实例对象上会有其构造函数拥有的一系列属性。让儿子的原型等于这个实例自然就继承了父亲的一系列东西。</p>\n<p>这个时候我们运行：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> son = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\">son.getParent(); <span class=\"comment\">//parent</span></span><br><span class=\"line\">son.getSon(); <span class=\"comment\">//son</span></span><br></pre></td></tr></table></figure></p>\n<p>以上代码能正常运行的。</p>\n<p>这个时候<code>son.constructor</code>是指向<code>Parent</code>的，因为<code>new Parent</code>出来的对象的<code>constructor</code>是指向<code>Parent</code>的，然后Son的<code>prototype</code>对象指向了这个new出来的对象，所以Son的<code>constructor</code>自然指向<code>Parent</code>。</p>\n<p>这个时候我们来梳理一下它们之间的关系：</p>\n<p><code>son.__proto__ =&gt; Son.prototype =&gt; Parent new出来的实例对象.__proto__ =&gt; Parent.prototype</code></p>\n<p>因此当调用son.getParent()时实际上会经历三个搜索步骤：</p>\n<ol>\n<li>搜索son</li>\n<li>搜索son.<strong>proto</strong>（也就是new Parent()这个对象）</li>\n<li>搜索son.<strong>proto</strong>.<strong>proto</strong>（也就是new Parent().<strong>proto</strong>即Parent.prototype）</li>\n</ol>\n<p>但是，使用原型链实现继承会有缺点，先上代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Parent()&#123;</span><br><span class=\"line\">    this.child = [1]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Son() &#123;&#125;</span><br><span class=\"line\">Son.prototype = new Parent();</span><br><span class=\"line\">var son1 = new Son();</span><br><span class=\"line\">son1.child.push(2);</span><br><span class=\"line\">var son2 = new Son();</span><br><span class=\"line\">son2.child.push(3);</span><br><span class=\"line\">son2.child //[1,2,3]</span><br></pre></td></tr></table></figure></p>\n<p>出现这种情况的原因是，所有实例都<strong>共享</strong>构造函数的prototype。</p>\n<p>这个可以通过<code>son1.__proto__ === son2.__proto__ //true</code>和<code>son1.child === son2.child //true</code>来证明</p>\n<p>为了解决这种问题，于是就出现了以下的方法：借用构造函数。</p>\n<h3 id=\"借用构造函数\"><a href=\"#借用构造函数\" class=\"headerlink\" title=\"借用构造函数\"></a>借用构造函数</h3><p>惯例，先上代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.child = [<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getChild = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.child;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Son</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    Parent.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> son1 = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\">son1.child.push(<span class=\"number\">2</span>);</span><br><span class=\"line\">son1.child <span class=\"comment\">//[1,2]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> son2 = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\">son2.child.push(<span class=\"number\">3</span>);</span><br><span class=\"line\">son2.child <span class=\"comment\">//[1,3]</span></span><br></pre></td></tr></table></figure></p>\n<p>可以看到，以上的引用问题解决了，但是，出现了一个与构造函数模式一样的问题，方法都在构造函数中定义，导致函数不能复用，所以，继续升级。</p>\n<h3 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.child = [<span class=\"number\">1</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Parent.prototype.getChild = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.child;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Son</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    Parent.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.friend = <span class=\"string\">'Jay Zangwill'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Son.prototype = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\">Son.prototype.getFriend = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.friend;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> son1 = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\">son1.child.push(<span class=\"number\">2</span>);</span><br><span class=\"line\">son1.getChild(); <span class=\"comment\">//[1,2]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> son2 = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\">son2.getChild(); <span class=\"comment\">//[1]</span></span><br><span class=\"line\">son2.getFriend(); <span class=\"comment\">// Jay Zangwill</span></span><br></pre></td></tr></table></figure>\n<p>这个方法解决了原型链继承的引用bug同时也解决了函数复用的问题，但是缺点也很明显，那就是调用了两次<code>Parent</code>函数，最终导致实例对象上有<code>child</code>属性原型链上也有这个属性。</p>\n<p>在介绍升级方法前先介绍两种基础方法。</p>\n<h3 id=\"原型式继承\"><a href=\"#原型式继承\" class=\"headerlink\" title=\"原型式继承\"></a>原型式继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> original = &#123;</span><br><span class=\"line\">    child:[<span class=\"number\">1</span>],</span><br><span class=\"line\">    name:<span class=\"string\">'Jay Zangwill'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parent</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">    F.prototype = obj</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> son1 = parent(original);</span><br><span class=\"line\">son1.child.push(<span class=\"number\">2</span>);</span><br><span class=\"line\">son1.name = <span class=\"string\">'a'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> son2 = parent(original);</span><br><span class=\"line\">son2.child.push(<span class=\"number\">3</span>);</span><br><span class=\"line\">son2.child <span class=\"comment\">//[1,2,3];</span></span><br><span class=\"line\">son2.name = <span class=\"string\">'b'</span>;</span><br><span class=\"line\">son1.name <span class=\"comment\">//a</span></span><br><span class=\"line\">son2.name <span class=\"comment\">//b</span></span><br></pre></td></tr></table></figure>\n<p>这种继承方式得需要一个原始对象作为参考，这个方式的主要目的是与另一个对象保持类似。<br>在es5中新增了一个Object.create()方法来实现原型式继承，<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create\" target=\"_blank\" rel=\"noopener\">传送门</a>。</p>\n<h3 id=\"寄生式继承\"><a href=\"#寄生式继承\" class=\"headerlink\" title=\"寄生式继承\"></a>寄生式继承</h3><p>寄生式继承是原型式继承的增强版：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createObj</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> clone = parent(obj);</span><br><span class=\"line\">    clone.getChild = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.child;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个方法与借用构造函数方法有个共同的缺点，就是方法没法复用。</p>\n<h3 id=\"寄生组合式继承\"><a href=\"#寄生组合式继承\" class=\"headerlink\" title=\"寄生组合式继承\"></a>寄生组合式继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createObj</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">    F.prototype = obj;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inherirPrototype</span>(<span class=\"params\">parent,son</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> prototype = createObj(parent.prototype);</span><br><span class=\"line\">    prototype.constructor = son;</span><br><span class=\"line\">    son.prototype = prototype;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.child = [<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Parent.prototype.getChild= <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.child;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Son</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    Parent.call(<span class=\"keyword\">this</span>,name);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.friend = [<span class=\"number\">2</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">inherirPrototype(Parent,Son);</span><br><span class=\"line\"></span><br><span class=\"line\">Son.prototype.getFriend = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.friend;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> son1 = <span class=\"keyword\">new</span> Son(<span class=\"string\">'Jay'</span>);</span><br><span class=\"line\">son1.child.push(<span class=\"number\">2</span>);</span><br><span class=\"line\">son1.getChild() <span class=\"comment\">//[1,2];</span></span><br><span class=\"line\">son2=<span class=\"keyword\">new</span> Son(<span class=\"string\">'Zangwill'</span>);</span><br><span class=\"line\">son2.child.push(<span class=\"number\">3</span>);</span><br><span class=\"line\">son2.getChild() <span class=\"comment\">//[1,3]</span></span><br><span class=\"line\">son2.getFriend() <span class=\"comment\">//[2]</span></span><br></pre></td></tr></table></figure>\n<p>可以看到上面代码只调用了一次<code>Parent</code>没有生成多余的属性，同时还解决了使用原型方法时Son不能向Parent传值的问题，也没有属性引用的问题。</p>\n<p>寄生组合式继承的大体思路是，通过借用构造函数模式来继承属性，通过原型链来继承方法。通过原型链继承方法无非就是想要得到父类的<code>prototype</code>对象，所以我们得想办法来拿到这个副本。而<code>createObj</code>函数就是干这事的。</p>\n<p>可能有人会问：<code>var prototype = createObj(parent.prototype);</code>这句代码直接改成<code>var prototype = parent.prototype</code>不行吗？</p>\n<p>答案是：肯定不行，要是这么改，要想在<code>Son.prototype</code>上加东西也会间接加到<code>Parent.prototype</code>上。</p>\n<p>不过，在es5中，可以把<code>var prototype = createObj(parent.prototype);</code>换成<code>var prototype = Object.create(parent.prototype);</code></p>\n<p>它们之间的关系如下：</p>\n<p><code>实例(也就是son1和son2).__proto__ =&gt; Son.prototype =&gt; 中间函数的实例(也就是F).__proto__ =&gt; 中间函数.prototype =&gt; Parent.prototype</code></p>\n<h3 id=\"es6中的继承\"><a href=\"#es6中的继承\" class=\"headerlink\" title=\"es6中的继承\"></a>es6中的继承</h3><p>在es6中，引入了<code>class</code>，这相当于是一个语法糖，这里我就直接上代码不展开说了，想要了解更多的话进入<a href=\"http://es6.ruanyifeng.com/#docs/class\" target=\"_blank\" rel=\"noopener\">传送门</a>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getName()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name,age) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getAge()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> son = <span class=\"keyword\">new</span> Son(<span class=\"string\">'Jay'</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">    son.getAge() <span class=\"comment\">//18</span></span><br><span class=\"line\">    son.getName(); <span class=\"comment\">//Jay</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><a href=\"https://zhuanlan.zhihu.com/p/34123800\" target=\"_blank\" rel=\"noopener\">知乎</a></p>\n<p>趁着目前手头上没啥事，赶紧写篇文章，emm…。</p>\n<p>红宝书不愧是红宝书，每看一次都会有新的收获，呃，废话不多说，直接进入正题吧。</p>\n<p>此文章默认您已经对原型、原型链、对象实例、new的过程有了一定的理解，如不理解的请自行查阅相关资料。</p>\n<p>另外，以下实例代码变量名、函数、变量值名我做了一定的修改，其大体思路和红宝书里的一样。</p>","more":"<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>在红宝书中，给出了以下继承方式：</p>\n<ol>\n<li>原型链实现继承</li>\n<li>借用构造函数</li>\n<li>组合继承</li>\n<li>原型式继承</li>\n<li>寄生式继承</li>\n<li>寄生组合式继承</li>\n</ol>\n<p>接下来就一一对它们进行分析。</p>\n<h3 id=\"原型链实现继承\"><a href=\"#原型链实现继承\" class=\"headerlink\" title=\"原型链实现继承\"></a>原型链实现继承</h3><p>话不多说，先上代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.parent = <span class=\"string\">'parent'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.getParent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.parent;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Son</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.son = <span class=\"string\">'son'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Son.prototype = <span class=\"keyword\">new</span> Parent(); <span class=\"comment\">//这句代码是实现继承的核心</span></span><br><span class=\"line\">Son.prototype.getSon = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.son;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其思路就是让儿子的原型对象等于父亲new出来的实例；我们知道new出来的实例对象上会有其构造函数拥有的一系列属性。让儿子的原型等于这个实例自然就继承了父亲的一系列东西。</p>\n<p>这个时候我们运行：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> son = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\">son.getParent(); <span class=\"comment\">//parent</span></span><br><span class=\"line\">son.getSon(); <span class=\"comment\">//son</span></span><br></pre></td></tr></table></figure></p>\n<p>以上代码能正常运行的。</p>\n<p>这个时候<code>son.constructor</code>是指向<code>Parent</code>的，因为<code>new Parent</code>出来的对象的<code>constructor</code>是指向<code>Parent</code>的，然后Son的<code>prototype</code>对象指向了这个new出来的对象，所以Son的<code>constructor</code>自然指向<code>Parent</code>。</p>\n<p>这个时候我们来梳理一下它们之间的关系：</p>\n<p><code>son.__proto__ =&gt; Son.prototype =&gt; Parent new出来的实例对象.__proto__ =&gt; Parent.prototype</code></p>\n<p>因此当调用son.getParent()时实际上会经历三个搜索步骤：</p>\n<ol>\n<li>搜索son</li>\n<li>搜索son.<strong>proto</strong>（也就是new Parent()这个对象）</li>\n<li>搜索son.<strong>proto</strong>.<strong>proto</strong>（也就是new Parent().<strong>proto</strong>即Parent.prototype）</li>\n</ol>\n<p>但是，使用原型链实现继承会有缺点，先上代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Parent()&#123;</span><br><span class=\"line\">    this.child = [1]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Son() &#123;&#125;</span><br><span class=\"line\">Son.prototype = new Parent();</span><br><span class=\"line\">var son1 = new Son();</span><br><span class=\"line\">son1.child.push(2);</span><br><span class=\"line\">var son2 = new Son();</span><br><span class=\"line\">son2.child.push(3);</span><br><span class=\"line\">son2.child //[1,2,3]</span><br></pre></td></tr></table></figure></p>\n<p>出现这种情况的原因是，所有实例都<strong>共享</strong>构造函数的prototype。</p>\n<p>这个可以通过<code>son1.__proto__ === son2.__proto__ //true</code>和<code>son1.child === son2.child //true</code>来证明</p>\n<p>为了解决这种问题，于是就出现了以下的方法：借用构造函数。</p>\n<h3 id=\"借用构造函数\"><a href=\"#借用构造函数\" class=\"headerlink\" title=\"借用构造函数\"></a>借用构造函数</h3><p>惯例，先上代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.child = [<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getChild = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.child;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Son</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    Parent.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> son1 = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\">son1.child.push(<span class=\"number\">2</span>);</span><br><span class=\"line\">son1.child <span class=\"comment\">//[1,2]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> son2 = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\">son2.child.push(<span class=\"number\">3</span>);</span><br><span class=\"line\">son2.child <span class=\"comment\">//[1,3]</span></span><br></pre></td></tr></table></figure></p>\n<p>可以看到，以上的引用问题解决了，但是，出现了一个与构造函数模式一样的问题，方法都在构造函数中定义，导致函数不能复用，所以，继续升级。</p>\n<h3 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.child = [<span class=\"number\">1</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Parent.prototype.getChild = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.child;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Son</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    Parent.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.friend = <span class=\"string\">'Jay Zangwill'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Son.prototype = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\">Son.prototype.getFriend = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.friend;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> son1 = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\">son1.child.push(<span class=\"number\">2</span>);</span><br><span class=\"line\">son1.getChild(); <span class=\"comment\">//[1,2]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> son2 = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\">son2.getChild(); <span class=\"comment\">//[1]</span></span><br><span class=\"line\">son2.getFriend(); <span class=\"comment\">// Jay Zangwill</span></span><br></pre></td></tr></table></figure>\n<p>这个方法解决了原型链继承的引用bug同时也解决了函数复用的问题，但是缺点也很明显，那就是调用了两次<code>Parent</code>函数，最终导致实例对象上有<code>child</code>属性原型链上也有这个属性。</p>\n<p>在介绍升级方法前先介绍两种基础方法。</p>\n<h3 id=\"原型式继承\"><a href=\"#原型式继承\" class=\"headerlink\" title=\"原型式继承\"></a>原型式继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> original = &#123;</span><br><span class=\"line\">    child:[<span class=\"number\">1</span>],</span><br><span class=\"line\">    name:<span class=\"string\">'Jay Zangwill'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parent</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">    F.prototype = obj</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> son1 = parent(original);</span><br><span class=\"line\">son1.child.push(<span class=\"number\">2</span>);</span><br><span class=\"line\">son1.name = <span class=\"string\">'a'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> son2 = parent(original);</span><br><span class=\"line\">son2.child.push(<span class=\"number\">3</span>);</span><br><span class=\"line\">son2.child <span class=\"comment\">//[1,2,3];</span></span><br><span class=\"line\">son2.name = <span class=\"string\">'b'</span>;</span><br><span class=\"line\">son1.name <span class=\"comment\">//a</span></span><br><span class=\"line\">son2.name <span class=\"comment\">//b</span></span><br></pre></td></tr></table></figure>\n<p>这种继承方式得需要一个原始对象作为参考，这个方式的主要目的是与另一个对象保持类似。<br>在es5中新增了一个Object.create()方法来实现原型式继承，<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create\" target=\"_blank\" rel=\"noopener\">传送门</a>。</p>\n<h3 id=\"寄生式继承\"><a href=\"#寄生式继承\" class=\"headerlink\" title=\"寄生式继承\"></a>寄生式继承</h3><p>寄生式继承是原型式继承的增强版：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createObj</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> clone = parent(obj);</span><br><span class=\"line\">    clone.getChild = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.child;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个方法与借用构造函数方法有个共同的缺点，就是方法没法复用。</p>\n<h3 id=\"寄生组合式继承\"><a href=\"#寄生组合式继承\" class=\"headerlink\" title=\"寄生组合式继承\"></a>寄生组合式继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createObj</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">    F.prototype = obj;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inherirPrototype</span>(<span class=\"params\">parent,son</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> prototype = createObj(parent.prototype);</span><br><span class=\"line\">    prototype.constructor = son;</span><br><span class=\"line\">    son.prototype = prototype;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.child = [<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Parent.prototype.getChild= <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.child;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Son</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    Parent.call(<span class=\"keyword\">this</span>,name);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.friend = [<span class=\"number\">2</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">inherirPrototype(Parent,Son);</span><br><span class=\"line\"></span><br><span class=\"line\">Son.prototype.getFriend = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.friend;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> son1 = <span class=\"keyword\">new</span> Son(<span class=\"string\">'Jay'</span>);</span><br><span class=\"line\">son1.child.push(<span class=\"number\">2</span>);</span><br><span class=\"line\">son1.getChild() <span class=\"comment\">//[1,2];</span></span><br><span class=\"line\">son2=<span class=\"keyword\">new</span> Son(<span class=\"string\">'Zangwill'</span>);</span><br><span class=\"line\">son2.child.push(<span class=\"number\">3</span>);</span><br><span class=\"line\">son2.getChild() <span class=\"comment\">//[1,3]</span></span><br><span class=\"line\">son2.getFriend() <span class=\"comment\">//[2]</span></span><br></pre></td></tr></table></figure>\n<p>可以看到上面代码只调用了一次<code>Parent</code>没有生成多余的属性，同时还解决了使用原型方法时Son不能向Parent传值的问题，也没有属性引用的问题。</p>\n<p>寄生组合式继承的大体思路是，通过借用构造函数模式来继承属性，通过原型链来继承方法。通过原型链继承方法无非就是想要得到父类的<code>prototype</code>对象，所以我们得想办法来拿到这个副本。而<code>createObj</code>函数就是干这事的。</p>\n<p>可能有人会问：<code>var prototype = createObj(parent.prototype);</code>这句代码直接改成<code>var prototype = parent.prototype</code>不行吗？</p>\n<p>答案是：肯定不行，要是这么改，要想在<code>Son.prototype</code>上加东西也会间接加到<code>Parent.prototype</code>上。</p>\n<p>不过，在es5中，可以把<code>var prototype = createObj(parent.prototype);</code>换成<code>var prototype = Object.create(parent.prototype);</code></p>\n<p>它们之间的关系如下：</p>\n<p><code>实例(也就是son1和son2).__proto__ =&gt; Son.prototype =&gt; 中间函数的实例(也就是F).__proto__ =&gt; 中间函数.prototype =&gt; Parent.prototype</code></p>\n<h3 id=\"es6中的继承\"><a href=\"#es6中的继承\" class=\"headerlink\" title=\"es6中的继承\"></a>es6中的继承</h3><p>在es6中，引入了<code>class</code>，这相当于是一个语法糖，这里我就直接上代码不展开说了，想要了解更多的话进入<a href=\"http://es6.ruanyifeng.com/#docs/class\" target=\"_blank\" rel=\"noopener\">传送门</a>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getName()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name,age) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getAge()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> son = <span class=\"keyword\">new</span> Son(<span class=\"string\">'Jay'</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">    son.getAge() <span class=\"comment\">//18</span></span><br><span class=\"line\">    son.getName(); <span class=\"comment\">//Jay</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"line-height和vertical-align采坑记","date":"2018-11-24T11:56:20.000Z","_content":"\n## 前言\n\n[原文](https://jayzangwill.github.io/blog/2018/11/24/line-height-and-vertical-align/) && [个人主页](https://www.jayzangwill.cn)\n[知乎](https://zhuanlan.zhihu.com/p/56943873) && [知乎专栏](https://zhuanlan.zhihu.com/jayzangwill)\n\n由于在工作过程中经常遇到行内元素错位的问题，所以决定研究一下line-height和vertical-align，研究完后发现的确还有一些比较细节性的东西自己好不知道，这次打算和大家分享一下我自己的一些收获。\n\n<!-- more -->\n\n## 语法及规范\n\n他们的语法和规范可点击一下链接，这里就不多说了。\n\n### vertical-anign\n\n[w3c规范](https://www.w3.org/TR/CSS2/visudet.html#propdef-vertical-align)\n\n[MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align)\n\n1. baseline（默认值）：使元素的基线与父元素的基线对齐。HTML规范没有详细说明部分可替换元素的基线，如`<textarea>` ，这意味着这些元素使用此值的表现因浏览器而异。\n2. sub：使元素的基线与父元素的下标基线对齐。\n3. super: 使元素的基线与父元素的上标基线对齐。\n4. text-top：使元素的顶部与父元素的字体顶部对齐。\n5. text-bottom：使元素的底部与父元素的字体底部对齐。\n6. middle：使元素的中部与父元素的基线加上父元素x-height的一半对齐。\n7. length：使元素的基线对齐到父元素的基线之上的给定长度。**可以是负数**。\n8. percentage：使元素的基线对齐到父元素的基线之上的给定百分比，**该百分比是line-height属性的百分比**（基友关系暴露）。**可以是负数**。\n9. top：使元素及其后代元素的顶部与整行的顶部对齐。\n10. bottom：使元素及其后代元素的底部与整行的底部对齐。\n\n**注意：**没有基线的元素，使用外边距的下边缘替代，且vertical-align只对行内元素、表格单元格元素生效：**不能用它垂直对齐块级元素**。\n\n[疯狂戳我试试属性](https://www.jayzangwill.cn/demo/verticalAlign_1.html)\n\n### line-height\n\n[w3c规范](https://www.w3.org/TR/CSS2/visudet.html#propdef-line-height)\n\n[MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-height)\n\n下面列出一些规范中的重点：\n\n1. normal 取决于用户端。桌面浏览器（包括Firefox）使用默认值，约为1.2，这取决于元素的 **font-family**\n2. number 该属性的应用值是这个无单位数字`<number>`乘以该元素的字体大小。计算值与指定值相同。大多数情况下，这是设置line-height的推荐方法，不会在继承时产生不确定的结果。\n3. length 指定`<length>`用于计算 line box 的高度。查看`<length>`获取可能的单位。以em为单位的值可能会产生不确定的结果。\n4. percentage 与元素自身的字体大小有关。计算值是给定的百分比值乘以元素计算出的字体大小。百分比值可能会带来不确定的结果。\n\n#### 什么是可替换元素？\n\n至于可替换元素的话可以看[这里](https://www.w3.org/TR/CSS21/conform.html#replaced-element)，英文好的人可以直接刚，英文不好的人直接看我的个人理解吧，可替换元素就是：这个元素显示的内容可以由标签熟悉决定，例如`img`标签的显示内容就是由`src`属性决定的，`src`改变，标签的显示内容也跟着变。\n\n#### 基线在哪？\n\n基线的问题可以看下面这张图：\n\n![四线图](/blog/img/lineHeight/x_height.png)\n\n这张图修改自[维基百科](https://en.wikipedia.org/wiki/X-height)\n\n从图中可以发现一共有四根线，这四根线很像我们平时写英文时作业本上的那四根线，同时，图中标明了的找到`baseline`也就是基线的位置，同时还标明了`x-height`。(ps：css中有个以x高度为标准的单位即ex，1ex=1个小x的高度)\n\n**but：**事情可没有这么简单，在[w3c规范](https://www.w3.org/TR/CSS2/visudet.html#propdef-vertical-align)的最下面有这么一句话：\n\nThe baseline of an 'inline-block' is the baseline of its last line box in the normal flow, unless it has either no in-flow line boxes or if its 'overflow' property has a computed value other than 'visible', in which case the baseline is the bottom margin edge.\n\n翻译过来就是：`inline-block`的基线是正常流程中其最后一个线框的基线，除非它里面没有在流内（in-flow）或者其`overflow`属性值不为`visible`，在这种情况下，基线是`margin-bottom`边缘。\n\n**提示：**所谓流内元素就是指没有浮动且`positions`的值为默认值或者`relative`以及非根元素。\n\n蛤？不懂什么意思？来，看以下代码：\n\n```css\n    .wrap {\n        display: inline-block;\n        width: 100px;\n        height: 100px;\n        color: #fff;\n        background: rgb(233, 78, 207);\n    }\n\n    .overflow {\n        overflow: hidden;\n    }\n```\n\n```html\n    <div class=\"wrap\"></div>\n    <div class=\"wrap overflow\">x</div>\n    <div class=\"wrap\">x</div>\n```\n\n结果:\n\n![inline_box](/blog/img/lineHeight/inline_box.png)\n\n首先根据上面那句话：“`inline-block`的基线是正常流程中其最后一个线框的基线”，他们的`baseline`是最后一个`.wrap`的`baseline`，即`字母x`的底部；然后根据第二句话：“除非它里面没有在流内（in-flow）或者其`overflow`属性值不为`visible`，在这种情况下，基线是`margin-bottom`边缘”；因为第一个`.wrap`内部没有其他`inline`元素和第二个的`overflow`值为`hidden`，所以他们两个的基线为`margin-bottom`的边缘，在这里因为没有设置`margin-bottom`，所以他们的基线在下面蓝色背景的边缘，这两个`.wrap`因为规范里的第二句话导致基线与第三个`.wrap`不一致，从而出现了如图所示的错位情况。\n\n到这里可能有人会问： `number`和`percentage`不是一样吗？都是与自身字体大小有关。\n\n关于这个，先上代码和效果：\n\n```css\n    .percentage-wrap {\n        font-size: 30px;\n        line-height: 100%;\n    }\n\n    .number-wrap {\n        font-size: 30px;\n        line-height: 1;\n    }\n\n    p {\n        font-size: 20px;\n    }\n```\n\n```html\n    <div class=\"percentage-wrap\">\n        <p>x</p>\n    </div>\n    <div class=\"number-wrap\">\n        <p>x</p>\n    </div>\n```\n\n效果如图：\n\n![height](/blog/img/lineHeight/height.jpg)\n\n可以发现，设置为百分比的`percentage-wrap`将行高遗传给了`p`，而`number-wrap`并没有；这就是二者的区别。\n\n### line box是什么？\n\n1. `content area` 是围绕着文字的一种box，高度由`font-size`和`font-family`决定。在谷歌控制台中，你用鼠标指向某个`inline`元素，蓝色区域就是所谓的`content are`。\n\n2. `line box`其实就是用来包裹每一行文字的东西，一行一个`line box`，这东西我们平时看不见，摸不着。**line-box 的高度是由它所有子元素inline-box的最大高度计算得出的（即line-height或者height）**\n\n这里借用一张图来说明`line box`（[图片出处](http://www.cnblogs.com/wfeicherish/p/8884903.html)）\n\n![height](/blog/img/lineHeight/line_box.png)\n\n图的代码：\n\n```html\n    <p>\n        Good design will be better.\n        <span class=\"a\">Ba</span>\n        <span class=\"b\">Ba</span>\n        <span class=\"c\">Ba</span>\n        We get to make a consequence.\n    </p>\n```\n\n```css\n    p  { font-size: 100px }\n    .a { font-family: Helvetica }\n    .b { font-family: Gruppo    }\n    .c { font-family: Catamaran }\n```\n\n如图所示，这里有三行，共三个`line box`（ps：更多关于line box和line-height的信息可参阅[这里](http://www.cnblogs.com/wfeicherish/p/8884903.html)）。\n\n## vertical-align 与 line-height的地下情\n\n我们首先来看下这张图：\n\n![gay](/blog/img/lineHeight/gay.png)\n\n有没有注意到图片下面为何多了一点空白？\n\n老中医：肯定是你标签后面有空格，加个`font-size:0`就行啦！\n\nemmm，这位老中医其实说对了一半吧。之前我也是这么认为的，怎么说呢？\n\n首先是这个空白不是空格或者回车造成的，其次是这个空白的确可以用`font-size:0`来解决。\n\n不信？你可以把结构改成这样看看空白还在不在。\n\n```html\n    <div class=\"wrap\"><img src=\"url\" alt=\"\"></div>\n```\n\n发现空白的确还是有的，这是为啥？其实这就是张鑫旭大佬所说的幽灵空白节点。\n\n借用张鑫旭大佬的解释：幽灵空白节点就是**块状元素内部的内联元素的行为表现，就好像块状元素内部还有一个（更有可能两个-前后）看不见摸不着没有宽度没有实体的空白节点，这个假想又似乎存在的空白节点，我称之为“幽灵空白节点”**\n\n来让我们在后面加个东西来证实这个”幽灵“的存在（或者说加个东西）：\n\n```html\n    <div class=\"wrap\"><img src=\"url\" alt=\"\"><span>x</span></div>\n```\n\n结果：\n\n![gay](/blog/img/lineHeight/gay_2.png)\n\n[疯狂戳我看个究竟](https://www.jayzangwill.cn/demo/verticalAlign_2.html)\n\n可以发现貌似是`x`的高度把这个空白撑出来的。\n\n如果借用之前提到的知识来解释的话还是很容易解释得通的。\n\n首先，他们默认是基于父元素基线对齐，其次基线是正常流中的最后一个元素的基线。因为`img`标签的基线位于它的`margin-bottom`的边缘，`x`的基线位于`x`的底部，在这里`img`要想它的基线和`x`的基线对齐只能往上顶，然后字体都默认有一定的行高的（即`line-height`不为0）于是`img`和`x`一个往上顶一个往下顶就把这个空白区域顶出来了（实际上就是`vertical-align`和`line-height`相互搞基造成的空白）。\n\n所以要解决这个问题的话就得破坏他们的基友关系。\n\n方法一：即上面所说的`font-size:0`，原理就是将`x`的顶线啊，中线啊，基线啊，什么乱七八糟的线归为一根线自然就ok了\n方法二：既然是`img`因为基线对齐向上顶了，那我们就不让他顶：（`vertical-align:top/middle/bottom`）\n方法三：字体有行高？那我就给你个小点的行高，不让你往下顶🤣例如：`line-height:0`\n方法四：如果布局允许可以将`img`的`display`设置为`block`或者它的父元素设置`display:flex`\n\n## 总结\n\n如果平时开发过程中发现有元素莫名其妙的不对齐，那十有八九就是`vertical-align`和`line-height`搞的鬼，大家可以针对这两个属性下手😁，破坏他们的基友情。\n\n1. 看完这篇文章以后需要知道`vertical-align`的值都是相对于什么对齐的\n2. 什么是可替换元素\n3. 基线在哪\n4. `line box`是什么\n5. `vertical-align`和`line-height`之间会擦出什么样的火花\n\n## 参考链接\n\n[CSS深入理解vertical-align和line-height的基友关系](https://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/)\n[深入理解CSS：line-height、vertical-align](http://www.cnblogs.com/wfeicherish/p/8884903.html)","source":"_posts/line-height-and-vertical-align.md","raw":"---\ntitle: line-height和vertical-align采坑记\ndate: 2018-11-24 19:56:20\ntags: [基础,css]\n---\n\n## 前言\n\n[原文](https://jayzangwill.github.io/blog/2018/11/24/line-height-and-vertical-align/) && [个人主页](https://www.jayzangwill.cn)\n[知乎](https://zhuanlan.zhihu.com/p/56943873) && [知乎专栏](https://zhuanlan.zhihu.com/jayzangwill)\n\n由于在工作过程中经常遇到行内元素错位的问题，所以决定研究一下line-height和vertical-align，研究完后发现的确还有一些比较细节性的东西自己好不知道，这次打算和大家分享一下我自己的一些收获。\n\n<!-- more -->\n\n## 语法及规范\n\n他们的语法和规范可点击一下链接，这里就不多说了。\n\n### vertical-anign\n\n[w3c规范](https://www.w3.org/TR/CSS2/visudet.html#propdef-vertical-align)\n\n[MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align)\n\n1. baseline（默认值）：使元素的基线与父元素的基线对齐。HTML规范没有详细说明部分可替换元素的基线，如`<textarea>` ，这意味着这些元素使用此值的表现因浏览器而异。\n2. sub：使元素的基线与父元素的下标基线对齐。\n3. super: 使元素的基线与父元素的上标基线对齐。\n4. text-top：使元素的顶部与父元素的字体顶部对齐。\n5. text-bottom：使元素的底部与父元素的字体底部对齐。\n6. middle：使元素的中部与父元素的基线加上父元素x-height的一半对齐。\n7. length：使元素的基线对齐到父元素的基线之上的给定长度。**可以是负数**。\n8. percentage：使元素的基线对齐到父元素的基线之上的给定百分比，**该百分比是line-height属性的百分比**（基友关系暴露）。**可以是负数**。\n9. top：使元素及其后代元素的顶部与整行的顶部对齐。\n10. bottom：使元素及其后代元素的底部与整行的底部对齐。\n\n**注意：**没有基线的元素，使用外边距的下边缘替代，且vertical-align只对行内元素、表格单元格元素生效：**不能用它垂直对齐块级元素**。\n\n[疯狂戳我试试属性](https://www.jayzangwill.cn/demo/verticalAlign_1.html)\n\n### line-height\n\n[w3c规范](https://www.w3.org/TR/CSS2/visudet.html#propdef-line-height)\n\n[MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-height)\n\n下面列出一些规范中的重点：\n\n1. normal 取决于用户端。桌面浏览器（包括Firefox）使用默认值，约为1.2，这取决于元素的 **font-family**\n2. number 该属性的应用值是这个无单位数字`<number>`乘以该元素的字体大小。计算值与指定值相同。大多数情况下，这是设置line-height的推荐方法，不会在继承时产生不确定的结果。\n3. length 指定`<length>`用于计算 line box 的高度。查看`<length>`获取可能的单位。以em为单位的值可能会产生不确定的结果。\n4. percentage 与元素自身的字体大小有关。计算值是给定的百分比值乘以元素计算出的字体大小。百分比值可能会带来不确定的结果。\n\n#### 什么是可替换元素？\n\n至于可替换元素的话可以看[这里](https://www.w3.org/TR/CSS21/conform.html#replaced-element)，英文好的人可以直接刚，英文不好的人直接看我的个人理解吧，可替换元素就是：这个元素显示的内容可以由标签熟悉决定，例如`img`标签的显示内容就是由`src`属性决定的，`src`改变，标签的显示内容也跟着变。\n\n#### 基线在哪？\n\n基线的问题可以看下面这张图：\n\n![四线图](/blog/img/lineHeight/x_height.png)\n\n这张图修改自[维基百科](https://en.wikipedia.org/wiki/X-height)\n\n从图中可以发现一共有四根线，这四根线很像我们平时写英文时作业本上的那四根线，同时，图中标明了的找到`baseline`也就是基线的位置，同时还标明了`x-height`。(ps：css中有个以x高度为标准的单位即ex，1ex=1个小x的高度)\n\n**but：**事情可没有这么简单，在[w3c规范](https://www.w3.org/TR/CSS2/visudet.html#propdef-vertical-align)的最下面有这么一句话：\n\nThe baseline of an 'inline-block' is the baseline of its last line box in the normal flow, unless it has either no in-flow line boxes or if its 'overflow' property has a computed value other than 'visible', in which case the baseline is the bottom margin edge.\n\n翻译过来就是：`inline-block`的基线是正常流程中其最后一个线框的基线，除非它里面没有在流内（in-flow）或者其`overflow`属性值不为`visible`，在这种情况下，基线是`margin-bottom`边缘。\n\n**提示：**所谓流内元素就是指没有浮动且`positions`的值为默认值或者`relative`以及非根元素。\n\n蛤？不懂什么意思？来，看以下代码：\n\n```css\n    .wrap {\n        display: inline-block;\n        width: 100px;\n        height: 100px;\n        color: #fff;\n        background: rgb(233, 78, 207);\n    }\n\n    .overflow {\n        overflow: hidden;\n    }\n```\n\n```html\n    <div class=\"wrap\"></div>\n    <div class=\"wrap overflow\">x</div>\n    <div class=\"wrap\">x</div>\n```\n\n结果:\n\n![inline_box](/blog/img/lineHeight/inline_box.png)\n\n首先根据上面那句话：“`inline-block`的基线是正常流程中其最后一个线框的基线”，他们的`baseline`是最后一个`.wrap`的`baseline`，即`字母x`的底部；然后根据第二句话：“除非它里面没有在流内（in-flow）或者其`overflow`属性值不为`visible`，在这种情况下，基线是`margin-bottom`边缘”；因为第一个`.wrap`内部没有其他`inline`元素和第二个的`overflow`值为`hidden`，所以他们两个的基线为`margin-bottom`的边缘，在这里因为没有设置`margin-bottom`，所以他们的基线在下面蓝色背景的边缘，这两个`.wrap`因为规范里的第二句话导致基线与第三个`.wrap`不一致，从而出现了如图所示的错位情况。\n\n到这里可能有人会问： `number`和`percentage`不是一样吗？都是与自身字体大小有关。\n\n关于这个，先上代码和效果：\n\n```css\n    .percentage-wrap {\n        font-size: 30px;\n        line-height: 100%;\n    }\n\n    .number-wrap {\n        font-size: 30px;\n        line-height: 1;\n    }\n\n    p {\n        font-size: 20px;\n    }\n```\n\n```html\n    <div class=\"percentage-wrap\">\n        <p>x</p>\n    </div>\n    <div class=\"number-wrap\">\n        <p>x</p>\n    </div>\n```\n\n效果如图：\n\n![height](/blog/img/lineHeight/height.jpg)\n\n可以发现，设置为百分比的`percentage-wrap`将行高遗传给了`p`，而`number-wrap`并没有；这就是二者的区别。\n\n### line box是什么？\n\n1. `content area` 是围绕着文字的一种box，高度由`font-size`和`font-family`决定。在谷歌控制台中，你用鼠标指向某个`inline`元素，蓝色区域就是所谓的`content are`。\n\n2. `line box`其实就是用来包裹每一行文字的东西，一行一个`line box`，这东西我们平时看不见，摸不着。**line-box 的高度是由它所有子元素inline-box的最大高度计算得出的（即line-height或者height）**\n\n这里借用一张图来说明`line box`（[图片出处](http://www.cnblogs.com/wfeicherish/p/8884903.html)）\n\n![height](/blog/img/lineHeight/line_box.png)\n\n图的代码：\n\n```html\n    <p>\n        Good design will be better.\n        <span class=\"a\">Ba</span>\n        <span class=\"b\">Ba</span>\n        <span class=\"c\">Ba</span>\n        We get to make a consequence.\n    </p>\n```\n\n```css\n    p  { font-size: 100px }\n    .a { font-family: Helvetica }\n    .b { font-family: Gruppo    }\n    .c { font-family: Catamaran }\n```\n\n如图所示，这里有三行，共三个`line box`（ps：更多关于line box和line-height的信息可参阅[这里](http://www.cnblogs.com/wfeicherish/p/8884903.html)）。\n\n## vertical-align 与 line-height的地下情\n\n我们首先来看下这张图：\n\n![gay](/blog/img/lineHeight/gay.png)\n\n有没有注意到图片下面为何多了一点空白？\n\n老中医：肯定是你标签后面有空格，加个`font-size:0`就行啦！\n\nemmm，这位老中医其实说对了一半吧。之前我也是这么认为的，怎么说呢？\n\n首先是这个空白不是空格或者回车造成的，其次是这个空白的确可以用`font-size:0`来解决。\n\n不信？你可以把结构改成这样看看空白还在不在。\n\n```html\n    <div class=\"wrap\"><img src=\"url\" alt=\"\"></div>\n```\n\n发现空白的确还是有的，这是为啥？其实这就是张鑫旭大佬所说的幽灵空白节点。\n\n借用张鑫旭大佬的解释：幽灵空白节点就是**块状元素内部的内联元素的行为表现，就好像块状元素内部还有一个（更有可能两个-前后）看不见摸不着没有宽度没有实体的空白节点，这个假想又似乎存在的空白节点，我称之为“幽灵空白节点”**\n\n来让我们在后面加个东西来证实这个”幽灵“的存在（或者说加个东西）：\n\n```html\n    <div class=\"wrap\"><img src=\"url\" alt=\"\"><span>x</span></div>\n```\n\n结果：\n\n![gay](/blog/img/lineHeight/gay_2.png)\n\n[疯狂戳我看个究竟](https://www.jayzangwill.cn/demo/verticalAlign_2.html)\n\n可以发现貌似是`x`的高度把这个空白撑出来的。\n\n如果借用之前提到的知识来解释的话还是很容易解释得通的。\n\n首先，他们默认是基于父元素基线对齐，其次基线是正常流中的最后一个元素的基线。因为`img`标签的基线位于它的`margin-bottom`的边缘，`x`的基线位于`x`的底部，在这里`img`要想它的基线和`x`的基线对齐只能往上顶，然后字体都默认有一定的行高的（即`line-height`不为0）于是`img`和`x`一个往上顶一个往下顶就把这个空白区域顶出来了（实际上就是`vertical-align`和`line-height`相互搞基造成的空白）。\n\n所以要解决这个问题的话就得破坏他们的基友关系。\n\n方法一：即上面所说的`font-size:0`，原理就是将`x`的顶线啊，中线啊，基线啊，什么乱七八糟的线归为一根线自然就ok了\n方法二：既然是`img`因为基线对齐向上顶了，那我们就不让他顶：（`vertical-align:top/middle/bottom`）\n方法三：字体有行高？那我就给你个小点的行高，不让你往下顶🤣例如：`line-height:0`\n方法四：如果布局允许可以将`img`的`display`设置为`block`或者它的父元素设置`display:flex`\n\n## 总结\n\n如果平时开发过程中发现有元素莫名其妙的不对齐，那十有八九就是`vertical-align`和`line-height`搞的鬼，大家可以针对这两个属性下手😁，破坏他们的基友情。\n\n1. 看完这篇文章以后需要知道`vertical-align`的值都是相对于什么对齐的\n2. 什么是可替换元素\n3. 基线在哪\n4. `line box`是什么\n5. `vertical-align`和`line-height`之间会擦出什么样的火花\n\n## 参考链接\n\n[CSS深入理解vertical-align和line-height的基友关系](https://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/)\n[深入理解CSS：line-height、vertical-align](http://www.cnblogs.com/wfeicherish/p/8884903.html)","slug":"line-height-and-vertical-align","published":1,"updated":"2020-04-07T03:29:17.937Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8qzc350000s2cl6bq8ip6g2","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><a href=\"https://jayzangwill.github.io/blog/2018/11/24/line-height-and-vertical-align/\">原文</a> &amp;&amp; <a href=\"https://www.jayzangwill.cn\" target=\"_blank\" rel=\"noopener\">个人主页</a><br><a href=\"https://zhuanlan.zhihu.com/p/56943873\" target=\"_blank\" rel=\"noopener\">知乎</a> &amp;&amp; <a href=\"https://zhuanlan.zhihu.com/jayzangwill\" target=\"_blank\" rel=\"noopener\">知乎专栏</a></p>\n<p>由于在工作过程中经常遇到行内元素错位的问题，所以决定研究一下line-height和vertical-align，研究完后发现的确还有一些比较细节性的东西自己好不知道，这次打算和大家分享一下我自己的一些收获。</p>\n<a id=\"more\"></a>\n<h2 id=\"语法及规范\"><a href=\"#语法及规范\" class=\"headerlink\" title=\"语法及规范\"></a>语法及规范</h2><p>他们的语法和规范可点击一下链接，这里就不多说了。</p>\n<h3 id=\"vertical-anign\"><a href=\"#vertical-anign\" class=\"headerlink\" title=\"vertical-anign\"></a>vertical-anign</h3><p><a href=\"https://www.w3.org/TR/CSS2/visudet.html#propdef-vertical-align\" target=\"_blank\" rel=\"noopener\">w3c规范</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align\" target=\"_blank\" rel=\"noopener\">MDN</a></p>\n<ol>\n<li>baseline（默认值）：使元素的基线与父元素的基线对齐。HTML规范没有详细说明部分可替换元素的基线，如<code>&lt;textarea&gt;</code> ，这意味着这些元素使用此值的表现因浏览器而异。</li>\n<li>sub：使元素的基线与父元素的下标基线对齐。</li>\n<li>super: 使元素的基线与父元素的上标基线对齐。</li>\n<li>text-top：使元素的顶部与父元素的字体顶部对齐。</li>\n<li>text-bottom：使元素的底部与父元素的字体底部对齐。</li>\n<li>middle：使元素的中部与父元素的基线加上父元素x-height的一半对齐。</li>\n<li>length：使元素的基线对齐到父元素的基线之上的给定长度。<strong>可以是负数</strong>。</li>\n<li>percentage：使元素的基线对齐到父元素的基线之上的给定百分比，<strong>该百分比是line-height属性的百分比</strong>（基友关系暴露）。<strong>可以是负数</strong>。</li>\n<li>top：使元素及其后代元素的顶部与整行的顶部对齐。</li>\n<li>bottom：使元素及其后代元素的底部与整行的底部对齐。</li>\n</ol>\n<p><strong>注意：</strong>没有基线的元素，使用外边距的下边缘替代，且vertical-align只对行内元素、表格单元格元素生效：<strong>不能用它垂直对齐块级元素</strong>。</p>\n<p><a href=\"https://www.jayzangwill.cn/demo/verticalAlign_1.html\" target=\"_blank\" rel=\"noopener\">疯狂戳我试试属性</a></p>\n<h3 id=\"line-height\"><a href=\"#line-height\" class=\"headerlink\" title=\"line-height\"></a>line-height</h3><p><a href=\"https://www.w3.org/TR/CSS2/visudet.html#propdef-line-height\" target=\"_blank\" rel=\"noopener\">w3c规范</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-height\" target=\"_blank\" rel=\"noopener\">MDN</a></p>\n<p>下面列出一些规范中的重点：</p>\n<ol>\n<li>normal 取决于用户端。桌面浏览器（包括Firefox）使用默认值，约为1.2，这取决于元素的 <strong>font-family</strong></li>\n<li>number 该属性的应用值是这个无单位数字<code>&lt;number&gt;</code>乘以该元素的字体大小。计算值与指定值相同。大多数情况下，这是设置line-height的推荐方法，不会在继承时产生不确定的结果。</li>\n<li>length 指定<code>&lt;length&gt;</code>用于计算 line box 的高度。查看<code>&lt;length&gt;</code>获取可能的单位。以em为单位的值可能会产生不确定的结果。</li>\n<li>percentage 与元素自身的字体大小有关。计算值是给定的百分比值乘以元素计算出的字体大小。百分比值可能会带来不确定的结果。</li>\n</ol>\n<h4 id=\"什么是可替换元素？\"><a href=\"#什么是可替换元素？\" class=\"headerlink\" title=\"什么是可替换元素？\"></a>什么是可替换元素？</h4><p>至于可替换元素的话可以看<a href=\"https://www.w3.org/TR/CSS21/conform.html#replaced-element\" target=\"_blank\" rel=\"noopener\">这里</a>，英文好的人可以直接刚，英文不好的人直接看我的个人理解吧，可替换元素就是：这个元素显示的内容可以由标签熟悉决定，例如<code>img</code>标签的显示内容就是由<code>src</code>属性决定的，<code>src</code>改变，标签的显示内容也跟着变。</p>\n<h4 id=\"基线在哪？\"><a href=\"#基线在哪？\" class=\"headerlink\" title=\"基线在哪？\"></a>基线在哪？</h4><p>基线的问题可以看下面这张图：</p>\n<p><img src=\"/blog/img/lineHeight/x_height.png\" alt=\"四线图\"></p>\n<p>这张图修改自<a href=\"https://en.wikipedia.org/wiki/X-height\" target=\"_blank\" rel=\"noopener\">维基百科</a></p>\n<p>从图中可以发现一共有四根线，这四根线很像我们平时写英文时作业本上的那四根线，同时，图中标明了的找到<code>baseline</code>也就是基线的位置，同时还标明了<code>x-height</code>。(ps：css中有个以x高度为标准的单位即ex，1ex=1个小x的高度)</p>\n<p><strong>but：</strong>事情可没有这么简单，在<a href=\"https://www.w3.org/TR/CSS2/visudet.html#propdef-vertical-align\" target=\"_blank\" rel=\"noopener\">w3c规范</a>的最下面有这么一句话：</p>\n<p>The baseline of an ‘inline-block’ is the baseline of its last line box in the normal flow, unless it has either no in-flow line boxes or if its ‘overflow’ property has a computed value other than ‘visible’, in which case the baseline is the bottom margin edge.</p>\n<p>翻译过来就是：<code>inline-block</code>的基线是正常流程中其最后一个线框的基线，除非它里面没有在流内（in-flow）或者其<code>overflow</code>属性值不为<code>visible</code>，在这种情况下，基线是<code>margin-bottom</code>边缘。</p>\n<p><strong>提示：</strong>所谓流内元素就是指没有浮动且<code>positions</code>的值为默认值或者<code>relative</code>以及非根元素。</p>\n<p>蛤？不懂什么意思？来，看以下代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.wrap</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">233</span>, <span class=\"number\">78</span>, <span class=\"number\">207</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.overflow</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap overflow\"</span>&gt;</span>x<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap\"</span>&gt;</span>x<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>结果:</p>\n<p><img src=\"/blog/img/lineHeight/inline_box.png\" alt=\"inline_box\"></p>\n<p>首先根据上面那句话：“<code>inline-block</code>的基线是正常流程中其最后一个线框的基线”，他们的<code>baseline</code>是最后一个<code>.wrap</code>的<code>baseline</code>，即<code>字母x</code>的底部；然后根据第二句话：“除非它里面没有在流内（in-flow）或者其<code>overflow</code>属性值不为<code>visible</code>，在这种情况下，基线是<code>margin-bottom</code>边缘”；因为第一个<code>.wrap</code>内部没有其他<code>inline</code>元素和第二个的<code>overflow</code>值为<code>hidden</code>，所以他们两个的基线为<code>margin-bottom</code>的边缘，在这里因为没有设置<code>margin-bottom</code>，所以他们的基线在下面蓝色背景的边缘，这两个<code>.wrap</code>因为规范里的第二句话导致基线与第三个<code>.wrap</code>不一致，从而出现了如图所示的错位情况。</p>\n<p>到这里可能有人会问： <code>number</code>和<code>percentage</code>不是一样吗？都是与自身字体大小有关。</p>\n<p>关于这个，先上代码和效果：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.percentage-wrap</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">line-height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.number-wrap</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">line-height</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"percentage-wrap\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>x<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"number-wrap\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>x<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>效果如图：</p>\n<p><img src=\"/blog/img/lineHeight/height.jpg\" alt=\"height\"></p>\n<p>可以发现，设置为百分比的<code>percentage-wrap</code>将行高遗传给了<code>p</code>，而<code>number-wrap</code>并没有；这就是二者的区别。</p>\n<h3 id=\"line-box是什么？\"><a href=\"#line-box是什么？\" class=\"headerlink\" title=\"line box是什么？\"></a>line box是什么？</h3><ol>\n<li><p><code>content area</code> 是围绕着文字的一种box，高度由<code>font-size</code>和<code>font-family</code>决定。在谷歌控制台中，你用鼠标指向某个<code>inline</code>元素，蓝色区域就是所谓的<code>content are</code>。</p>\n</li>\n<li><p><code>line box</code>其实就是用来包裹每一行文字的东西，一行一个<code>line box</code>，这东西我们平时看不见，摸不着。<strong>line-box 的高度是由它所有子元素inline-box的最大高度计算得出的（即line-height或者height）</strong></p>\n</li>\n</ol>\n<p>这里借用一张图来说明<code>line box</code>（<a href=\"http://www.cnblogs.com/wfeicherish/p/8884903.html\" target=\"_blank\" rel=\"noopener\">图片出处</a>）</p>\n<p><img src=\"/blog/img/lineHeight/line_box.png\" alt=\"height\"></p>\n<p>图的代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    Good design will be better.</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"a\"</span>&gt;</span>Ba<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"b\"</span>&gt;</span>Ba<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"c\"</span>&gt;</span>Ba<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    We get to make a consequence.</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">p</span>  &#123; <span class=\"attribute\">font-size</span>: <span class=\"number\">100px</span> &#125;</span><br><span class=\"line\"><span class=\"selector-class\">.a</span> &#123; <span class=\"attribute\">font-family</span>: Helvetica &#125;</span><br><span class=\"line\"><span class=\"selector-class\">.b</span> &#123; <span class=\"attribute\">font-family</span>: Gruppo    &#125;</span><br><span class=\"line\"><span class=\"selector-class\">.c</span> &#123; <span class=\"attribute\">font-family</span>: Catamaran &#125;</span><br></pre></td></tr></table></figure>\n<p>如图所示，这里有三行，共三个<code>line box</code>（ps：更多关于line box和line-height的信息可参阅<a href=\"http://www.cnblogs.com/wfeicherish/p/8884903.html\" target=\"_blank\" rel=\"noopener\">这里</a>）。</p>\n<h2 id=\"vertical-align-与-line-height的地下情\"><a href=\"#vertical-align-与-line-height的地下情\" class=\"headerlink\" title=\"vertical-align 与 line-height的地下情\"></a>vertical-align 与 line-height的地下情</h2><p>我们首先来看下这张图：</p>\n<p><img src=\"/blog/img/lineHeight/gay.png\" alt=\"gay\"></p>\n<p>有没有注意到图片下面为何多了一点空白？</p>\n<p>老中医：肯定是你标签后面有空格，加个<code>font-size:0</code>就行啦！</p>\n<p>emmm，这位老中医其实说对了一半吧。之前我也是这么认为的，怎么说呢？</p>\n<p>首先是这个空白不是空格或者回车造成的，其次是这个空白的确可以用<code>font-size:0</code>来解决。</p>\n<p>不信？你可以把结构改成这样看看空白还在不在。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>发现空白的确还是有的，这是为啥？其实这就是张鑫旭大佬所说的幽灵空白节点。</p>\n<p>借用张鑫旭大佬的解释：幽灵空白节点就是<strong>块状元素内部的内联元素的行为表现，就好像块状元素内部还有一个（更有可能两个-前后）看不见摸不着没有宽度没有实体的空白节点，这个假想又似乎存在的空白节点，我称之为“幽灵空白节点”</strong></p>\n<p>来让我们在后面加个东西来证实这个”幽灵“的存在（或者说加个东西）：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>x<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<p><img src=\"/blog/img/lineHeight/gay_2.png\" alt=\"gay\"></p>\n<p><a href=\"https://www.jayzangwill.cn/demo/verticalAlign_2.html\" target=\"_blank\" rel=\"noopener\">疯狂戳我看个究竟</a></p>\n<p>可以发现貌似是<code>x</code>的高度把这个空白撑出来的。</p>\n<p>如果借用之前提到的知识来解释的话还是很容易解释得通的。</p>\n<p>首先，他们默认是基于父元素基线对齐，其次基线是正常流中的最后一个元素的基线。因为<code>img</code>标签的基线位于它的<code>margin-bottom</code>的边缘，<code>x</code>的基线位于<code>x</code>的底部，在这里<code>img</code>要想它的基线和<code>x</code>的基线对齐只能往上顶，然后字体都默认有一定的行高的（即<code>line-height</code>不为0）于是<code>img</code>和<code>x</code>一个往上顶一个往下顶就把这个空白区域顶出来了（实际上就是<code>vertical-align</code>和<code>line-height</code>相互搞基造成的空白）。</p>\n<p>所以要解决这个问题的话就得破坏他们的基友关系。</p>\n<p>方法一：即上面所说的<code>font-size:0</code>，原理就是将<code>x</code>的顶线啊，中线啊，基线啊，什么乱七八糟的线归为一根线自然就ok了<br>方法二：既然是<code>img</code>因为基线对齐向上顶了，那我们就不让他顶：（<code>vertical-align:top/middle/bottom</code>）<br>方法三：字体有行高？那我就给你个小点的行高，不让你往下顶🤣例如：<code>line-height:0</code><br>方法四：如果布局允许可以将<code>img</code>的<code>display</code>设置为<code>block</code>或者它的父元素设置<code>display:flex</code></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>如果平时开发过程中发现有元素莫名其妙的不对齐，那十有八九就是<code>vertical-align</code>和<code>line-height</code>搞的鬼，大家可以针对这两个属性下手😁，破坏他们的基友情。</p>\n<ol>\n<li>看完这篇文章以后需要知道<code>vertical-align</code>的值都是相对于什么对齐的</li>\n<li>什么是可替换元素</li>\n<li>基线在哪</li>\n<li><code>line box</code>是什么</li>\n<li><code>vertical-align</code>和<code>line-height</code>之间会擦出什么样的火花</li>\n</ol>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/\" target=\"_blank\" rel=\"noopener\">CSS深入理解vertical-align和line-height的基友关系</a><br><a href=\"http://www.cnblogs.com/wfeicherish/p/8884903.html\" target=\"_blank\" rel=\"noopener\">深入理解CSS：line-height、vertical-align</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><a href=\"https://jayzangwill.github.io/blog/2018/11/24/line-height-and-vertical-align/\">原文</a> &amp;&amp; <a href=\"https://www.jayzangwill.cn\" target=\"_blank\" rel=\"noopener\">个人主页</a><br><a href=\"https://zhuanlan.zhihu.com/p/56943873\" target=\"_blank\" rel=\"noopener\">知乎</a> &amp;&amp; <a href=\"https://zhuanlan.zhihu.com/jayzangwill\" target=\"_blank\" rel=\"noopener\">知乎专栏</a></p>\n<p>由于在工作过程中经常遇到行内元素错位的问题，所以决定研究一下line-height和vertical-align，研究完后发现的确还有一些比较细节性的东西自己好不知道，这次打算和大家分享一下我自己的一些收获。</p>","more":"<h2 id=\"语法及规范\"><a href=\"#语法及规范\" class=\"headerlink\" title=\"语法及规范\"></a>语法及规范</h2><p>他们的语法和规范可点击一下链接，这里就不多说了。</p>\n<h3 id=\"vertical-anign\"><a href=\"#vertical-anign\" class=\"headerlink\" title=\"vertical-anign\"></a>vertical-anign</h3><p><a href=\"https://www.w3.org/TR/CSS2/visudet.html#propdef-vertical-align\" target=\"_blank\" rel=\"noopener\">w3c规范</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align\" target=\"_blank\" rel=\"noopener\">MDN</a></p>\n<ol>\n<li>baseline（默认值）：使元素的基线与父元素的基线对齐。HTML规范没有详细说明部分可替换元素的基线，如<code>&lt;textarea&gt;</code> ，这意味着这些元素使用此值的表现因浏览器而异。</li>\n<li>sub：使元素的基线与父元素的下标基线对齐。</li>\n<li>super: 使元素的基线与父元素的上标基线对齐。</li>\n<li>text-top：使元素的顶部与父元素的字体顶部对齐。</li>\n<li>text-bottom：使元素的底部与父元素的字体底部对齐。</li>\n<li>middle：使元素的中部与父元素的基线加上父元素x-height的一半对齐。</li>\n<li>length：使元素的基线对齐到父元素的基线之上的给定长度。<strong>可以是负数</strong>。</li>\n<li>percentage：使元素的基线对齐到父元素的基线之上的给定百分比，<strong>该百分比是line-height属性的百分比</strong>（基友关系暴露）。<strong>可以是负数</strong>。</li>\n<li>top：使元素及其后代元素的顶部与整行的顶部对齐。</li>\n<li>bottom：使元素及其后代元素的底部与整行的底部对齐。</li>\n</ol>\n<p><strong>注意：</strong>没有基线的元素，使用外边距的下边缘替代，且vertical-align只对行内元素、表格单元格元素生效：<strong>不能用它垂直对齐块级元素</strong>。</p>\n<p><a href=\"https://www.jayzangwill.cn/demo/verticalAlign_1.html\" target=\"_blank\" rel=\"noopener\">疯狂戳我试试属性</a></p>\n<h3 id=\"line-height\"><a href=\"#line-height\" class=\"headerlink\" title=\"line-height\"></a>line-height</h3><p><a href=\"https://www.w3.org/TR/CSS2/visudet.html#propdef-line-height\" target=\"_blank\" rel=\"noopener\">w3c规范</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-height\" target=\"_blank\" rel=\"noopener\">MDN</a></p>\n<p>下面列出一些规范中的重点：</p>\n<ol>\n<li>normal 取决于用户端。桌面浏览器（包括Firefox）使用默认值，约为1.2，这取决于元素的 <strong>font-family</strong></li>\n<li>number 该属性的应用值是这个无单位数字<code>&lt;number&gt;</code>乘以该元素的字体大小。计算值与指定值相同。大多数情况下，这是设置line-height的推荐方法，不会在继承时产生不确定的结果。</li>\n<li>length 指定<code>&lt;length&gt;</code>用于计算 line box 的高度。查看<code>&lt;length&gt;</code>获取可能的单位。以em为单位的值可能会产生不确定的结果。</li>\n<li>percentage 与元素自身的字体大小有关。计算值是给定的百分比值乘以元素计算出的字体大小。百分比值可能会带来不确定的结果。</li>\n</ol>\n<h4 id=\"什么是可替换元素？\"><a href=\"#什么是可替换元素？\" class=\"headerlink\" title=\"什么是可替换元素？\"></a>什么是可替换元素？</h4><p>至于可替换元素的话可以看<a href=\"https://www.w3.org/TR/CSS21/conform.html#replaced-element\" target=\"_blank\" rel=\"noopener\">这里</a>，英文好的人可以直接刚，英文不好的人直接看我的个人理解吧，可替换元素就是：这个元素显示的内容可以由标签熟悉决定，例如<code>img</code>标签的显示内容就是由<code>src</code>属性决定的，<code>src</code>改变，标签的显示内容也跟着变。</p>\n<h4 id=\"基线在哪？\"><a href=\"#基线在哪？\" class=\"headerlink\" title=\"基线在哪？\"></a>基线在哪？</h4><p>基线的问题可以看下面这张图：</p>\n<p><img src=\"/blog/img/lineHeight/x_height.png\" alt=\"四线图\"></p>\n<p>这张图修改自<a href=\"https://en.wikipedia.org/wiki/X-height\" target=\"_blank\" rel=\"noopener\">维基百科</a></p>\n<p>从图中可以发现一共有四根线，这四根线很像我们平时写英文时作业本上的那四根线，同时，图中标明了的找到<code>baseline</code>也就是基线的位置，同时还标明了<code>x-height</code>。(ps：css中有个以x高度为标准的单位即ex，1ex=1个小x的高度)</p>\n<p><strong>but：</strong>事情可没有这么简单，在<a href=\"https://www.w3.org/TR/CSS2/visudet.html#propdef-vertical-align\" target=\"_blank\" rel=\"noopener\">w3c规范</a>的最下面有这么一句话：</p>\n<p>The baseline of an ‘inline-block’ is the baseline of its last line box in the normal flow, unless it has either no in-flow line boxes or if its ‘overflow’ property has a computed value other than ‘visible’, in which case the baseline is the bottom margin edge.</p>\n<p>翻译过来就是：<code>inline-block</code>的基线是正常流程中其最后一个线框的基线，除非它里面没有在流内（in-flow）或者其<code>overflow</code>属性值不为<code>visible</code>，在这种情况下，基线是<code>margin-bottom</code>边缘。</p>\n<p><strong>提示：</strong>所谓流内元素就是指没有浮动且<code>positions</code>的值为默认值或者<code>relative</code>以及非根元素。</p>\n<p>蛤？不懂什么意思？来，看以下代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.wrap</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">233</span>, <span class=\"number\">78</span>, <span class=\"number\">207</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.overflow</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap overflow\"</span>&gt;</span>x<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap\"</span>&gt;</span>x<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>结果:</p>\n<p><img src=\"/blog/img/lineHeight/inline_box.png\" alt=\"inline_box\"></p>\n<p>首先根据上面那句话：“<code>inline-block</code>的基线是正常流程中其最后一个线框的基线”，他们的<code>baseline</code>是最后一个<code>.wrap</code>的<code>baseline</code>，即<code>字母x</code>的底部；然后根据第二句话：“除非它里面没有在流内（in-flow）或者其<code>overflow</code>属性值不为<code>visible</code>，在这种情况下，基线是<code>margin-bottom</code>边缘”；因为第一个<code>.wrap</code>内部没有其他<code>inline</code>元素和第二个的<code>overflow</code>值为<code>hidden</code>，所以他们两个的基线为<code>margin-bottom</code>的边缘，在这里因为没有设置<code>margin-bottom</code>，所以他们的基线在下面蓝色背景的边缘，这两个<code>.wrap</code>因为规范里的第二句话导致基线与第三个<code>.wrap</code>不一致，从而出现了如图所示的错位情况。</p>\n<p>到这里可能有人会问： <code>number</code>和<code>percentage</code>不是一样吗？都是与自身字体大小有关。</p>\n<p>关于这个，先上代码和效果：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.percentage-wrap</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">line-height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.number-wrap</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">line-height</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"percentage-wrap\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>x<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"number-wrap\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>x<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>效果如图：</p>\n<p><img src=\"/blog/img/lineHeight/height.jpg\" alt=\"height\"></p>\n<p>可以发现，设置为百分比的<code>percentage-wrap</code>将行高遗传给了<code>p</code>，而<code>number-wrap</code>并没有；这就是二者的区别。</p>\n<h3 id=\"line-box是什么？\"><a href=\"#line-box是什么？\" class=\"headerlink\" title=\"line box是什么？\"></a>line box是什么？</h3><ol>\n<li><p><code>content area</code> 是围绕着文字的一种box，高度由<code>font-size</code>和<code>font-family</code>决定。在谷歌控制台中，你用鼠标指向某个<code>inline</code>元素，蓝色区域就是所谓的<code>content are</code>。</p>\n</li>\n<li><p><code>line box</code>其实就是用来包裹每一行文字的东西，一行一个<code>line box</code>，这东西我们平时看不见，摸不着。<strong>line-box 的高度是由它所有子元素inline-box的最大高度计算得出的（即line-height或者height）</strong></p>\n</li>\n</ol>\n<p>这里借用一张图来说明<code>line box</code>（<a href=\"http://www.cnblogs.com/wfeicherish/p/8884903.html\" target=\"_blank\" rel=\"noopener\">图片出处</a>）</p>\n<p><img src=\"/blog/img/lineHeight/line_box.png\" alt=\"height\"></p>\n<p>图的代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    Good design will be better.</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"a\"</span>&gt;</span>Ba<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"b\"</span>&gt;</span>Ba<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"c\"</span>&gt;</span>Ba<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    We get to make a consequence.</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">p</span>  &#123; <span class=\"attribute\">font-size</span>: <span class=\"number\">100px</span> &#125;</span><br><span class=\"line\"><span class=\"selector-class\">.a</span> &#123; <span class=\"attribute\">font-family</span>: Helvetica &#125;</span><br><span class=\"line\"><span class=\"selector-class\">.b</span> &#123; <span class=\"attribute\">font-family</span>: Gruppo    &#125;</span><br><span class=\"line\"><span class=\"selector-class\">.c</span> &#123; <span class=\"attribute\">font-family</span>: Catamaran &#125;</span><br></pre></td></tr></table></figure>\n<p>如图所示，这里有三行，共三个<code>line box</code>（ps：更多关于line box和line-height的信息可参阅<a href=\"http://www.cnblogs.com/wfeicherish/p/8884903.html\" target=\"_blank\" rel=\"noopener\">这里</a>）。</p>\n<h2 id=\"vertical-align-与-line-height的地下情\"><a href=\"#vertical-align-与-line-height的地下情\" class=\"headerlink\" title=\"vertical-align 与 line-height的地下情\"></a>vertical-align 与 line-height的地下情</h2><p>我们首先来看下这张图：</p>\n<p><img src=\"/blog/img/lineHeight/gay.png\" alt=\"gay\"></p>\n<p>有没有注意到图片下面为何多了一点空白？</p>\n<p>老中医：肯定是你标签后面有空格，加个<code>font-size:0</code>就行啦！</p>\n<p>emmm，这位老中医其实说对了一半吧。之前我也是这么认为的，怎么说呢？</p>\n<p>首先是这个空白不是空格或者回车造成的，其次是这个空白的确可以用<code>font-size:0</code>来解决。</p>\n<p>不信？你可以把结构改成这样看看空白还在不在。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>发现空白的确还是有的，这是为啥？其实这就是张鑫旭大佬所说的幽灵空白节点。</p>\n<p>借用张鑫旭大佬的解释：幽灵空白节点就是<strong>块状元素内部的内联元素的行为表现，就好像块状元素内部还有一个（更有可能两个-前后）看不见摸不着没有宽度没有实体的空白节点，这个假想又似乎存在的空白节点，我称之为“幽灵空白节点”</strong></p>\n<p>来让我们在后面加个东西来证实这个”幽灵“的存在（或者说加个东西）：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>x<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<p><img src=\"/blog/img/lineHeight/gay_2.png\" alt=\"gay\"></p>\n<p><a href=\"https://www.jayzangwill.cn/demo/verticalAlign_2.html\" target=\"_blank\" rel=\"noopener\">疯狂戳我看个究竟</a></p>\n<p>可以发现貌似是<code>x</code>的高度把这个空白撑出来的。</p>\n<p>如果借用之前提到的知识来解释的话还是很容易解释得通的。</p>\n<p>首先，他们默认是基于父元素基线对齐，其次基线是正常流中的最后一个元素的基线。因为<code>img</code>标签的基线位于它的<code>margin-bottom</code>的边缘，<code>x</code>的基线位于<code>x</code>的底部，在这里<code>img</code>要想它的基线和<code>x</code>的基线对齐只能往上顶，然后字体都默认有一定的行高的（即<code>line-height</code>不为0）于是<code>img</code>和<code>x</code>一个往上顶一个往下顶就把这个空白区域顶出来了（实际上就是<code>vertical-align</code>和<code>line-height</code>相互搞基造成的空白）。</p>\n<p>所以要解决这个问题的话就得破坏他们的基友关系。</p>\n<p>方法一：即上面所说的<code>font-size:0</code>，原理就是将<code>x</code>的顶线啊，中线啊，基线啊，什么乱七八糟的线归为一根线自然就ok了<br>方法二：既然是<code>img</code>因为基线对齐向上顶了，那我们就不让他顶：（<code>vertical-align:top/middle/bottom</code>）<br>方法三：字体有行高？那我就给你个小点的行高，不让你往下顶🤣例如：<code>line-height:0</code><br>方法四：如果布局允许可以将<code>img</code>的<code>display</code>设置为<code>block</code>或者它的父元素设置<code>display:flex</code></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>如果平时开发过程中发现有元素莫名其妙的不对齐，那十有八九就是<code>vertical-align</code>和<code>line-height</code>搞的鬼，大家可以针对这两个属性下手😁，破坏他们的基友情。</p>\n<ol>\n<li>看完这篇文章以后需要知道<code>vertical-align</code>的值都是相对于什么对齐的</li>\n<li>什么是可替换元素</li>\n<li>基线在哪</li>\n<li><code>line box</code>是什么</li>\n<li><code>vertical-align</code>和<code>line-height</code>之间会擦出什么样的火花</li>\n</ol>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/\" target=\"_blank\" rel=\"noopener\">CSS深入理解vertical-align和line-height的基友关系</a><br><a href=\"http://www.cnblogs.com/wfeicherish/p/8884903.html\" target=\"_blank\" rel=\"noopener\">深入理解CSS：line-height、vertical-align</a></p>"},{"title":"new blog","date":"2016-07-30T03:05:50.000Z","_content":"# 新的开始\n\n\n * 搭建了一天半的博客终于搭建好了，各种百度各种坑，加上各种烧脑，最终还是搭建好了。本来想用[jekyll](http://jekyll.bootcss.com/)搭建的，但是要安装一堆东西是在是麻烦，最重要的是还不能上传到github的gh-pages分支上，所以选择了比较简便的[hexo](https://hexo.io/)，进入官网就能看到安装的方法。\n  \n<!-- more-->\n\n * 在选主题的时候选了很久，原因之一就是没有好看的，最重要的还是当时不会配置主题文件，走了很大的弯路。在此吐槽一下*hexo*，还有众多的辣鸡教程，不过相对于以前来说*hexo*确实变得简便了许多。\n \n \n * 至于我为何要搭建博客，最重要的原因就是前端学习的东西太多，有些东西会忘，所以搭个博客出来做做笔记，顺便做个技术分享。\n \n \n * 最后还要吐槽一下用的这个主题名字叫[jacman](http://jacman.wuchong.me/2014/11/20/how-to-use-jacman/)，找了好久用的这个主题还算漂亮，教程也比较详细，但是唯一的缺点就是我多说评论框没出来，不知为何，等以后有时间了再换，蛤蛤蛤！\n \n \n \n * 饭点到了，是时候出去觅食了，弄得好辛苦啊！！\n","source":"_posts/new-blog.md","raw":"---\ntitle: new blog\ndate: 2016-07-30 11:05:50\ntags: 心情\n---\n# 新的开始\n\n\n * 搭建了一天半的博客终于搭建好了，各种百度各种坑，加上各种烧脑，最终还是搭建好了。本来想用[jekyll](http://jekyll.bootcss.com/)搭建的，但是要安装一堆东西是在是麻烦，最重要的是还不能上传到github的gh-pages分支上，所以选择了比较简便的[hexo](https://hexo.io/)，进入官网就能看到安装的方法。\n  \n<!-- more-->\n\n * 在选主题的时候选了很久，原因之一就是没有好看的，最重要的还是当时不会配置主题文件，走了很大的弯路。在此吐槽一下*hexo*，还有众多的辣鸡教程，不过相对于以前来说*hexo*确实变得简便了许多。\n \n \n * 至于我为何要搭建博客，最重要的原因就是前端学习的东西太多，有些东西会忘，所以搭个博客出来做做笔记，顺便做个技术分享。\n \n \n * 最后还要吐槽一下用的这个主题名字叫[jacman](http://jacman.wuchong.me/2014/11/20/how-to-use-jacman/)，找了好久用的这个主题还算漂亮，教程也比较详细，但是唯一的缺点就是我多说评论框没出来，不知为何，等以后有时间了再换，蛤蛤蛤！\n \n \n \n * 饭点到了，是时候出去觅食了，弄得好辛苦啊！！\n","slug":"new-blog","published":1,"updated":"2020-04-07T03:29:17.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8qzc352000u2cl6vf10vg8f","content":"<h1 id=\"新的开始\"><a href=\"#新的开始\" class=\"headerlink\" title=\"新的开始\"></a>新的开始</h1><ul>\n<li>搭建了一天半的博客终于搭建好了，各种百度各种坑，加上各种烧脑，最终还是搭建好了。本来想用<a href=\"http://jekyll.bootcss.com/\" target=\"_blank\" rel=\"noopener\">jekyll</a>搭建的，但是要安装一堆东西是在是麻烦，最重要的是还不能上传到github的gh-pages分支上，所以选择了比较简便的<a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">hexo</a>，进入官网就能看到安装的方法。</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li>在选主题的时候选了很久，原因之一就是没有好看的，最重要的还是当时不会配置主题文件，走了很大的弯路。在此吐槽一下<em>hexo</em>，还有众多的辣鸡教程，不过相对于以前来说<em>hexo</em>确实变得简便了许多。</li>\n</ul>\n<ul>\n<li>至于我为何要搭建博客，最重要的原因就是前端学习的东西太多，有些东西会忘，所以搭个博客出来做做笔记，顺便做个技术分享。</li>\n</ul>\n<ul>\n<li>最后还要吐槽一下用的这个主题名字叫<a href=\"http://jacman.wuchong.me/2014/11/20/how-to-use-jacman/\" target=\"_blank\" rel=\"noopener\">jacman</a>，找了好久用的这个主题还算漂亮，教程也比较详细，但是唯一的缺点就是我多说评论框没出来，不知为何，等以后有时间了再换，蛤蛤蛤！</li>\n</ul>\n<ul>\n<li>饭点到了，是时候出去觅食了，弄得好辛苦啊！！</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"新的开始\"><a href=\"#新的开始\" class=\"headerlink\" title=\"新的开始\"></a>新的开始</h1><ul>\n<li>搭建了一天半的博客终于搭建好了，各种百度各种坑，加上各种烧脑，最终还是搭建好了。本来想用<a href=\"http://jekyll.bootcss.com/\" target=\"_blank\" rel=\"noopener\">jekyll</a>搭建的，但是要安装一堆东西是在是麻烦，最重要的是还不能上传到github的gh-pages分支上，所以选择了比较简便的<a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">hexo</a>，进入官网就能看到安装的方法。</li>\n</ul>","more":"<ul>\n<li>在选主题的时候选了很久，原因之一就是没有好看的，最重要的还是当时不会配置主题文件，走了很大的弯路。在此吐槽一下<em>hexo</em>，还有众多的辣鸡教程，不过相对于以前来说<em>hexo</em>确实变得简便了许多。</li>\n</ul>\n<ul>\n<li>至于我为何要搭建博客，最重要的原因就是前端学习的东西太多，有些东西会忘，所以搭个博客出来做做笔记，顺便做个技术分享。</li>\n</ul>\n<ul>\n<li>最后还要吐槽一下用的这个主题名字叫<a href=\"http://jacman.wuchong.me/2014/11/20/how-to-use-jacman/\" target=\"_blank\" rel=\"noopener\">jacman</a>，找了好久用的这个主题还算漂亮，教程也比较详细，但是唯一的缺点就是我多说评论框没出来，不知为何，等以后有时间了再换，蛤蛤蛤！</li>\n</ul>\n<ul>\n<li>饭点到了，是时候出去觅食了，弄得好辛苦啊！！</li>\n</ul>"},{"title":"常用的mongodb命令","date":"2017-04-10T10:57:18.000Z","_content":"\n# 下面是一些我常用的mongodb命令，供自己备忘\n\n\n<!-- more -->\n\n1. show dbs （列出所有数据库）\n2. use [database name] （数据库的切换）\n3. show collections （查看当前使用数据库有哪些表）\n4. db.[表名].find() （查找当前表下所有数据）\n5. db.[表名].findOne({'key':value}) （查找一条符合查询条件的数据）\n6. db.[表名].drop() （删除当前表）\n7. db.[表名].move({'key':value}) （根据条件删除数据）\n8. help （输出mongodb的帮助）\n9. db help() （数据库的帮助命令）\n\n[关于mongodb更多](http://blog.csdn.net/u010305706/article/details/48129131)\n\n# node与mongodb交互\n```node\n// 插入操作\nfunction insertDocuments(db, data, callback) {\n\tlet collection = db.collection('documents');\n\tcollection.insertOne(data, (err, result) => {\n\t\tassert.equal(err, null);\n\t\tcallback(result);\n\t});\n}\n```\n```node\n// 查找操作\nfunction findDocuments(db, callback, search) {\n\tsearch = search || {};\n\t\n\t// Get the documents collection\n\tlet collection = db.collection('documents');\n\t// Find some documents\n\tcollection.find(search).toArray((err, docs) => {\n\t\tassert.equal(err, null);\n\t\tcallback(docs);\n\t});\n}\n```\n\n```node\n// 更新操作\nfunction updateDocument(db, userinfo, money, callback) {\n\n\t// Get the documents collection\n\tlet collection = db.collection('documents');\n\n\tcollection.updateOne({\n\t\tidCard: userinfo\n\t}, {\n\t\t$set: {\n\t\t\tmoney: money\n\t\t}\n\t}, (err, result) => {\n\t\tassert.equal(err, null);\n\t\tcallback(result);\n\t});\n}\n```\n```node\nfunction deleteDocument(db, userinfo, callback) {\n  // Get the documents collection\n  let collection = db.collection('documents');\n  collection.deleteOne({ idCard: userinfo }, (err, result) => {\n    callback(result);\n  });\n}\n```\n[更多node与mongodb交互](https://github.com/mongodb/node-mongodb-native)\n","source":"_posts/mongodb common command.md","raw":"---\ntitle: 常用的mongodb命令\ndate: 2017-04-10 18:57:18\ntags: [mongodb]\n---\n\n# 下面是一些我常用的mongodb命令，供自己备忘\n\n\n<!-- more -->\n\n1. show dbs （列出所有数据库）\n2. use [database name] （数据库的切换）\n3. show collections （查看当前使用数据库有哪些表）\n4. db.[表名].find() （查找当前表下所有数据）\n5. db.[表名].findOne({'key':value}) （查找一条符合查询条件的数据）\n6. db.[表名].drop() （删除当前表）\n7. db.[表名].move({'key':value}) （根据条件删除数据）\n8. help （输出mongodb的帮助）\n9. db help() （数据库的帮助命令）\n\n[关于mongodb更多](http://blog.csdn.net/u010305706/article/details/48129131)\n\n# node与mongodb交互\n```node\n// 插入操作\nfunction insertDocuments(db, data, callback) {\n\tlet collection = db.collection('documents');\n\tcollection.insertOne(data, (err, result) => {\n\t\tassert.equal(err, null);\n\t\tcallback(result);\n\t});\n}\n```\n```node\n// 查找操作\nfunction findDocuments(db, callback, search) {\n\tsearch = search || {};\n\t\n\t// Get the documents collection\n\tlet collection = db.collection('documents');\n\t// Find some documents\n\tcollection.find(search).toArray((err, docs) => {\n\t\tassert.equal(err, null);\n\t\tcallback(docs);\n\t});\n}\n```\n\n```node\n// 更新操作\nfunction updateDocument(db, userinfo, money, callback) {\n\n\t// Get the documents collection\n\tlet collection = db.collection('documents');\n\n\tcollection.updateOne({\n\t\tidCard: userinfo\n\t}, {\n\t\t$set: {\n\t\t\tmoney: money\n\t\t}\n\t}, (err, result) => {\n\t\tassert.equal(err, null);\n\t\tcallback(result);\n\t});\n}\n```\n```node\nfunction deleteDocument(db, userinfo, callback) {\n  // Get the documents collection\n  let collection = db.collection('documents');\n  collection.deleteOne({ idCard: userinfo }, (err, result) => {\n    callback(result);\n  });\n}\n```\n[更多node与mongodb交互](https://github.com/mongodb/node-mongodb-native)\n","slug":"mongodb common command","published":1,"updated":"2020-04-07T03:29:17.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8qzc356000x2cl6yqqsio6l","content":"<h1 id=\"下面是一些我常用的mongodb命令，供自己备忘\"><a href=\"#下面是一些我常用的mongodb命令，供自己备忘\" class=\"headerlink\" title=\"下面是一些我常用的mongodb命令，供自己备忘\"></a>下面是一些我常用的mongodb命令，供自己备忘</h1><a id=\"more\"></a>\n<ol>\n<li>show dbs （列出所有数据库）</li>\n<li>use [database name] （数据库的切换）</li>\n<li>show collections （查看当前使用数据库有哪些表）</li>\n<li>db.[表名].find() （查找当前表下所有数据）</li>\n<li>db.[表名].findOne({‘key’:value}) （查找一条符合查询条件的数据）</li>\n<li>db.[表名].drop() （删除当前表）</li>\n<li>db.[表名].move({‘key’:value}) （根据条件删除数据）</li>\n<li>help （输出mongodb的帮助）</li>\n<li>db help() （数据库的帮助命令）</li>\n</ol>\n<p><a href=\"http://blog.csdn.net/u010305706/article/details/48129131\" target=\"_blank\" rel=\"noopener\">关于mongodb更多</a></p>\n<h1 id=\"node与mongodb交互\"><a href=\"#node与mongodb交互\" class=\"headerlink\" title=\"node与mongodb交互\"></a>node与mongodb交互</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 插入操作</span><br><span class=\"line\">function insertDocuments(db, data, callback) &#123;</span><br><span class=\"line\">\tlet collection = db.collection(&apos;documents&apos;);</span><br><span class=\"line\">\tcollection.insertOne(data, (err, result) =&gt; &#123;</span><br><span class=\"line\">\t\tassert.equal(err, null);</span><br><span class=\"line\">\t\tcallback(result);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 查找操作</span><br><span class=\"line\">function findDocuments(db, callback, search) &#123;</span><br><span class=\"line\">\tsearch = search || &#123;&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t// Get the documents collection</span><br><span class=\"line\">\tlet collection = db.collection(&apos;documents&apos;);</span><br><span class=\"line\">\t// Find some documents</span><br><span class=\"line\">\tcollection.find(search).toArray((err, docs) =&gt; &#123;</span><br><span class=\"line\">\t\tassert.equal(err, null);</span><br><span class=\"line\">\t\tcallback(docs);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 更新操作</span><br><span class=\"line\">function updateDocument(db, userinfo, money, callback) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Get the documents collection</span><br><span class=\"line\">\tlet collection = db.collection(&apos;documents&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">\tcollection.updateOne(&#123;</span><br><span class=\"line\">\t\tidCard: userinfo</span><br><span class=\"line\">\t&#125;, &#123;</span><br><span class=\"line\">\t\t$set: &#123;</span><br><span class=\"line\">\t\t\tmoney: money</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;, (err, result) =&gt; &#123;</span><br><span class=\"line\">\t\tassert.equal(err, null);</span><br><span class=\"line\">\t\tcallback(result);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function deleteDocument(db, userinfo, callback) &#123;</span><br><span class=\"line\">  // Get the documents collection</span><br><span class=\"line\">  let collection = db.collection(&apos;documents&apos;);</span><br><span class=\"line\">  collection.deleteOne(&#123; idCard: userinfo &#125;, (err, result) =&gt; &#123;</span><br><span class=\"line\">    callback(result);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/mongodb/node-mongodb-native\" target=\"_blank\" rel=\"noopener\">更多node与mongodb交互</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"下面是一些我常用的mongodb命令，供自己备忘\"><a href=\"#下面是一些我常用的mongodb命令，供自己备忘\" class=\"headerlink\" title=\"下面是一些我常用的mongodb命令，供自己备忘\"></a>下面是一些我常用的mongodb命令，供自己备忘</h1>","more":"<ol>\n<li>show dbs （列出所有数据库）</li>\n<li>use [database name] （数据库的切换）</li>\n<li>show collections （查看当前使用数据库有哪些表）</li>\n<li>db.[表名].find() （查找当前表下所有数据）</li>\n<li>db.[表名].findOne({‘key’:value}) （查找一条符合查询条件的数据）</li>\n<li>db.[表名].drop() （删除当前表）</li>\n<li>db.[表名].move({‘key’:value}) （根据条件删除数据）</li>\n<li>help （输出mongodb的帮助）</li>\n<li>db help() （数据库的帮助命令）</li>\n</ol>\n<p><a href=\"http://blog.csdn.net/u010305706/article/details/48129131\" target=\"_blank\" rel=\"noopener\">关于mongodb更多</a></p>\n<h1 id=\"node与mongodb交互\"><a href=\"#node与mongodb交互\" class=\"headerlink\" title=\"node与mongodb交互\"></a>node与mongodb交互</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 插入操作</span><br><span class=\"line\">function insertDocuments(db, data, callback) &#123;</span><br><span class=\"line\">\tlet collection = db.collection(&apos;documents&apos;);</span><br><span class=\"line\">\tcollection.insertOne(data, (err, result) =&gt; &#123;</span><br><span class=\"line\">\t\tassert.equal(err, null);</span><br><span class=\"line\">\t\tcallback(result);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 查找操作</span><br><span class=\"line\">function findDocuments(db, callback, search) &#123;</span><br><span class=\"line\">\tsearch = search || &#123;&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t// Get the documents collection</span><br><span class=\"line\">\tlet collection = db.collection(&apos;documents&apos;);</span><br><span class=\"line\">\t// Find some documents</span><br><span class=\"line\">\tcollection.find(search).toArray((err, docs) =&gt; &#123;</span><br><span class=\"line\">\t\tassert.equal(err, null);</span><br><span class=\"line\">\t\tcallback(docs);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 更新操作</span><br><span class=\"line\">function updateDocument(db, userinfo, money, callback) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Get the documents collection</span><br><span class=\"line\">\tlet collection = db.collection(&apos;documents&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">\tcollection.updateOne(&#123;</span><br><span class=\"line\">\t\tidCard: userinfo</span><br><span class=\"line\">\t&#125;, &#123;</span><br><span class=\"line\">\t\t$set: &#123;</span><br><span class=\"line\">\t\t\tmoney: money</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;, (err, result) =&gt; &#123;</span><br><span class=\"line\">\t\tassert.equal(err, null);</span><br><span class=\"line\">\t\tcallback(result);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function deleteDocument(db, userinfo, callback) &#123;</span><br><span class=\"line\">  // Get the documents collection</span><br><span class=\"line\">  let collection = db.collection(&apos;documents&apos;);</span><br><span class=\"line\">  collection.deleteOne(&#123; idCard: userinfo &#125;, (err, result) =&gt; &#123;</span><br><span class=\"line\">    callback(result);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/mongodb/node-mongodb-native\" target=\"_blank\" rel=\"noopener\">更多node与mongodb交互</a></p>"},{"title":"搜狗实习总结","date":"2018-03-19T14:02:27.000Z","_content":"\n转眼间，在搜狗实习已经快一年了，在这得确收获颇丰，所以得总结一下。\n\n<!-- more -->\n\n### 日常工作\n\n1. 负责搜狗网页搜索结果页部分日常需求开发。\n2. 负责搜索app的一些活动页开发。\n3. 负责搜狗英文搜索和搜狗学术搜索全部日常需求开发及一些内部组件日常维护。\n4. 搜狗其他周边需求的开发等。\n\n### 工作中遇到的问题\n\n因为平时工作中主要是html+css这一块的东西，所以遇到最多的问题就是浏览器兼容问题（ie7，ie8）与移动端适配问题。\n\n下面列举一些工作中常见的一些兼容问题及解决办法：\n\n1. pc下mac二倍屏图像显示模糊\n```css\nbackground-image: -webkit-image-set(url(imgUrl@1x) 1x,url(imgUrl@2x) 2x);\n```\n\n2. ie背景半透明效果（不是opacity哦，opacity会把前景也变透明）\n\n```scss\n$ieHexStr: ie-hex-str(rgba($color,$alpha));\nfilter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#{$ieHexStr}', endColorstr='#{$ieHexStr}');\n```\n\n3. ie背景平铺\n\n```css\nfilter: progid:DXImageTransform.Microsoft.AlphaImageLoader(src=$url, sizingMethod='scale')\n```\n\n4. ie常用hack（在工作中通常解决一些间距、行高偏差）\n\n```css\ncolor:red;\ncolor:green\\0;ie8、9、10、11\ncolor:#000\\9;ie 8、9、10\ncolor:orange\\9\\0;ie9、10\n*color:yellow;ie7\n\n/*ie以外浏览器红色 ie11绿色 ie9、10橙色 ie8黑色 ie7黄色*/\n```\n\n5. ie7下`display:inline-block`失效\n\n解决办法：在ie7下`display:inline-block`只对默认是行内的元素生效，例如a、i、span\n\n6. ie7下定位覆盖问题\n\n有时候我们在定位的时候在其他浏览器下层叠顺序正常，但是在ie7下，无论给这个元素设置多高的z-index都没用，依然还会被另外一个元素覆盖，这是因为ie7下层叠顺序还得看父辈元素，这个时候，可以试试把父辈元素的z-index设高点（这个问题貌似在移动端也有，233）。\n\n7. webkit(blink)内核下`fixed`定位失效。\n\n看看`fixed`定位的父辈元素有没有设置`transform`属性，如果有的话就得去掉，因为在webkit(blink)内核下`transform`属性会导致`fixed`定位随着它定位，而不是随着窗口。\n\n8. 在ios下给背景颜色设置`transparent`颜色不是变透明，而是变黑\n\n解决办法：试试`rgba(255,255,255,0)`\n\n9. ios下某个元素滚动不顺畅（松手时滚动太僵硬）\n\n试试`-webkit-overflow-scrolling: touch;`\n\n10. `sticky`定位失效\n\n先确定浏览器版本是不是够新，够新的话检查父辈元素有没有有没有`overflow: hidden;`，有的话得删掉（sticky定位是个蛮新的定位值，不了解的同学这里有个[传送门](https://developer.mozilla.org/en-US/docs/Web/CSS/position)）\n\n11. 微信小程序`textarea`组件自动聚焦有bug\n\n解决办法：沟通换成`input`\n\n12. 微信小程序雪碧图在真机上定位不准\n\n解决办法：雪碧图换成`image`\n\n13. 在做小程序时碰到一个需求：给`input`框加个**reset**功能，reset完以后要重新聚焦`input`，但是这个在真机上会有莫名的bug，感兴趣的同学可以试试。\n\n解决办法：沟通把这个功能去掉\n\n14. vm、vh、vmax、vmin在ios safair下宽度是大于视口的\n\n解决办法：换单位或者用js兼容\n\n15. 其他一些乱七八糟的问题\n\n解决办法：利用调试工具快速定位问题（调试工具用的好，什么bug都不怕），如果无法解决（例如只有某种机型有bug），沟通解决（没有什么问题是沟通解决不了的，233）\n\n### 收获\n\n1. 项目实战经验，使得html+(s)css使用得更熟练（实习前基本都是用bootstrap的样式233）\n2. 更注重html语义化\n3. html+css+js基础加强，写出的代码质量更高\n4. 熟悉了公司开发、合作流程\n5. 将psd还原成页面更熟练，精度更高\n6. 接触了pixi.js、bodmovin.js等一些动画库，更熟悉了canvas的一些原生操作\n7. 考虑问题更全面\n8. emm...\n\n### 实习以前没见过的一些css属性\n\n1. css多行截断\n\n在实习前只知道怎么用css做单行截断，但是却不知到怎么用css做多行截断，css多行截断代码如下:\n```\n\toverflow: hidden;\n\tdisplay: -webkit-box;\n\ttext-overflow: ellipsis;\n\t-webkit-line-clamp: 3; /*超出多少行开始截断*/\n\t-webkit-box-orient: vertical;\n```\n可以看到，前面加有-webkit-前缀，所以考虑到兼容性，目前只能用于移动端\n\n2. -webkit-tap-highlight-color\n\n这是用于改变a链接点击高亮的颜色\n\n3. -webkit-overflow-scrolling: touch\n\n在ios下设置了`overflow:scroll`的元素使其有惯性滚动效果。关于此属性的更多可以查看[这里](http://www.cnblogs.com/chris-oil/p/6164966.html)\n\n4. filter: blur()\n\n一个高斯模糊属性\n\n5. filter: grayscale();\n\n一个能使元素变灰的属性，一般用于图片上，使图片变灰。[更多filter的操作](https://developer.mozilla.org/en-US/docs/Web/CSS/filter)\n\n...其他的等我想起再加吧","source":"_posts/sogou-life.md","raw":"---\ntitle: 搜狗实习总结\ndate: 2018-03-19 22:02:27\ntags: [心情,基础]\n---\n\n转眼间，在搜狗实习已经快一年了，在这得确收获颇丰，所以得总结一下。\n\n<!-- more -->\n\n### 日常工作\n\n1. 负责搜狗网页搜索结果页部分日常需求开发。\n2. 负责搜索app的一些活动页开发。\n3. 负责搜狗英文搜索和搜狗学术搜索全部日常需求开发及一些内部组件日常维护。\n4. 搜狗其他周边需求的开发等。\n\n### 工作中遇到的问题\n\n因为平时工作中主要是html+css这一块的东西，所以遇到最多的问题就是浏览器兼容问题（ie7，ie8）与移动端适配问题。\n\n下面列举一些工作中常见的一些兼容问题及解决办法：\n\n1. pc下mac二倍屏图像显示模糊\n```css\nbackground-image: -webkit-image-set(url(imgUrl@1x) 1x,url(imgUrl@2x) 2x);\n```\n\n2. ie背景半透明效果（不是opacity哦，opacity会把前景也变透明）\n\n```scss\n$ieHexStr: ie-hex-str(rgba($color,$alpha));\nfilter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#{$ieHexStr}', endColorstr='#{$ieHexStr}');\n```\n\n3. ie背景平铺\n\n```css\nfilter: progid:DXImageTransform.Microsoft.AlphaImageLoader(src=$url, sizingMethod='scale')\n```\n\n4. ie常用hack（在工作中通常解决一些间距、行高偏差）\n\n```css\ncolor:red;\ncolor:green\\0;ie8、9、10、11\ncolor:#000\\9;ie 8、9、10\ncolor:orange\\9\\0;ie9、10\n*color:yellow;ie7\n\n/*ie以外浏览器红色 ie11绿色 ie9、10橙色 ie8黑色 ie7黄色*/\n```\n\n5. ie7下`display:inline-block`失效\n\n解决办法：在ie7下`display:inline-block`只对默认是行内的元素生效，例如a、i、span\n\n6. ie7下定位覆盖问题\n\n有时候我们在定位的时候在其他浏览器下层叠顺序正常，但是在ie7下，无论给这个元素设置多高的z-index都没用，依然还会被另外一个元素覆盖，这是因为ie7下层叠顺序还得看父辈元素，这个时候，可以试试把父辈元素的z-index设高点（这个问题貌似在移动端也有，233）。\n\n7. webkit(blink)内核下`fixed`定位失效。\n\n看看`fixed`定位的父辈元素有没有设置`transform`属性，如果有的话就得去掉，因为在webkit(blink)内核下`transform`属性会导致`fixed`定位随着它定位，而不是随着窗口。\n\n8. 在ios下给背景颜色设置`transparent`颜色不是变透明，而是变黑\n\n解决办法：试试`rgba(255,255,255,0)`\n\n9. ios下某个元素滚动不顺畅（松手时滚动太僵硬）\n\n试试`-webkit-overflow-scrolling: touch;`\n\n10. `sticky`定位失效\n\n先确定浏览器版本是不是够新，够新的话检查父辈元素有没有有没有`overflow: hidden;`，有的话得删掉（sticky定位是个蛮新的定位值，不了解的同学这里有个[传送门](https://developer.mozilla.org/en-US/docs/Web/CSS/position)）\n\n11. 微信小程序`textarea`组件自动聚焦有bug\n\n解决办法：沟通换成`input`\n\n12. 微信小程序雪碧图在真机上定位不准\n\n解决办法：雪碧图换成`image`\n\n13. 在做小程序时碰到一个需求：给`input`框加个**reset**功能，reset完以后要重新聚焦`input`，但是这个在真机上会有莫名的bug，感兴趣的同学可以试试。\n\n解决办法：沟通把这个功能去掉\n\n14. vm、vh、vmax、vmin在ios safair下宽度是大于视口的\n\n解决办法：换单位或者用js兼容\n\n15. 其他一些乱七八糟的问题\n\n解决办法：利用调试工具快速定位问题（调试工具用的好，什么bug都不怕），如果无法解决（例如只有某种机型有bug），沟通解决（没有什么问题是沟通解决不了的，233）\n\n### 收获\n\n1. 项目实战经验，使得html+(s)css使用得更熟练（实习前基本都是用bootstrap的样式233）\n2. 更注重html语义化\n3. html+css+js基础加强，写出的代码质量更高\n4. 熟悉了公司开发、合作流程\n5. 将psd还原成页面更熟练，精度更高\n6. 接触了pixi.js、bodmovin.js等一些动画库，更熟悉了canvas的一些原生操作\n7. 考虑问题更全面\n8. emm...\n\n### 实习以前没见过的一些css属性\n\n1. css多行截断\n\n在实习前只知道怎么用css做单行截断，但是却不知到怎么用css做多行截断，css多行截断代码如下:\n```\n\toverflow: hidden;\n\tdisplay: -webkit-box;\n\ttext-overflow: ellipsis;\n\t-webkit-line-clamp: 3; /*超出多少行开始截断*/\n\t-webkit-box-orient: vertical;\n```\n可以看到，前面加有-webkit-前缀，所以考虑到兼容性，目前只能用于移动端\n\n2. -webkit-tap-highlight-color\n\n这是用于改变a链接点击高亮的颜色\n\n3. -webkit-overflow-scrolling: touch\n\n在ios下设置了`overflow:scroll`的元素使其有惯性滚动效果。关于此属性的更多可以查看[这里](http://www.cnblogs.com/chris-oil/p/6164966.html)\n\n4. filter: blur()\n\n一个高斯模糊属性\n\n5. filter: grayscale();\n\n一个能使元素变灰的属性，一般用于图片上，使图片变灰。[更多filter的操作](https://developer.mozilla.org/en-US/docs/Web/CSS/filter)\n\n...其他的等我想起再加吧","slug":"sogou-life","published":1,"updated":"2020-04-07T03:29:17.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8qzc358000z2cl6lnzdq56x","content":"<p>转眼间，在搜狗实习已经快一年了，在这得确收获颇丰，所以得总结一下。</p>\n<a id=\"more\"></a>\n<h3 id=\"日常工作\"><a href=\"#日常工作\" class=\"headerlink\" title=\"日常工作\"></a>日常工作</h3><ol>\n<li>负责搜狗网页搜索结果页部分日常需求开发。</li>\n<li>负责搜索app的一些活动页开发。</li>\n<li>负责搜狗英文搜索和搜狗学术搜索全部日常需求开发及一些内部组件日常维护。</li>\n<li>搜狗其他周边需求的开发等。</li>\n</ol>\n<h3 id=\"工作中遇到的问题\"><a href=\"#工作中遇到的问题\" class=\"headerlink\" title=\"工作中遇到的问题\"></a>工作中遇到的问题</h3><p>因为平时工作中主要是html+css这一块的东西，所以遇到最多的问题就是浏览器兼容问题（ie7，ie8）与移动端适配问题。</p>\n<p>下面列举一些工作中常见的一些兼容问题及解决办法：</p>\n<ol>\n<li><p>pc下mac二倍屏图像显示模糊</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background-image</span>: <span class=\"selector-tag\">-webkit-image-set</span>(<span class=\"selector-tag\">url</span>(<span class=\"selector-tag\">imgUrl</span><span class=\"keyword\">@1x</span>) <span class=\"number\">1</span>x,url(imgUrl@<span class=\"number\">2</span>x) <span class=\"number\">2</span>x);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ie背景半透明效果（不是opacity哦，opacity会把前景也变透明）</p>\n</li>\n</ol>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ieHexStr</span>: ie-hex-str(rgba(<span class=\"variable\">$color</span>,<span class=\"variable\">$alpha</span>));</span><br><span class=\"line\"><span class=\"attribute\">filter</span>:progid:DXImageTransform.Microsoft.gradient(startColorstr=<span class=\"string\">'#&#123;$ieHexStr&#125;'</span>, endColorstr=<span class=\"string\">'#&#123;$ieHexStr&#125;'</span>);</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>ie背景平铺</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filter: progid:DXImageTransform.Microsoft.AlphaImageLoader(src=$url, sizingMethod='scale')</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>ie常用hack（在工作中通常解决一些间距、行高偏差）</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">color</span><span class=\"selector-pseudo\">:red</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">color</span><span class=\"selector-pseudo\">:green</span>\\0;<span class=\"selector-tag\">ie8</span>、9、10、11</span><br><span class=\"line\"><span class=\"selector-tag\">color</span>:<span class=\"selector-id\">#000</span>\\9;<span class=\"selector-tag\">ie</span> 8、9、10</span><br><span class=\"line\"><span class=\"selector-tag\">color</span><span class=\"selector-pseudo\">:orange</span>\\9\\0;<span class=\"selector-tag\">ie9</span>、10</span><br><span class=\"line\">*<span class=\"selector-tag\">color</span><span class=\"selector-pseudo\">:yellow</span>;<span class=\"selector-tag\">ie7</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*ie以外浏览器红色 ie11绿色 ie9、10橙色 ie8黑色 ie7黄色*/</span></span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>ie7下<code>display:inline-block</code>失效</li>\n</ol>\n<p>解决办法：在ie7下<code>display:inline-block</code>只对默认是行内的元素生效，例如a、i、span</p>\n<ol start=\"6\">\n<li>ie7下定位覆盖问题</li>\n</ol>\n<p>有时候我们在定位的时候在其他浏览器下层叠顺序正常，但是在ie7下，无论给这个元素设置多高的z-index都没用，依然还会被另外一个元素覆盖，这是因为ie7下层叠顺序还得看父辈元素，这个时候，可以试试把父辈元素的z-index设高点（这个问题貌似在移动端也有，233）。</p>\n<ol start=\"7\">\n<li>webkit(blink)内核下<code>fixed</code>定位失效。</li>\n</ol>\n<p>看看<code>fixed</code>定位的父辈元素有没有设置<code>transform</code>属性，如果有的话就得去掉，因为在webkit(blink)内核下<code>transform</code>属性会导致<code>fixed</code>定位随着它定位，而不是随着窗口。</p>\n<ol start=\"8\">\n<li>在ios下给背景颜色设置<code>transparent</code>颜色不是变透明，而是变黑</li>\n</ol>\n<p>解决办法：试试<code>rgba(255,255,255,0)</code></p>\n<ol start=\"9\">\n<li>ios下某个元素滚动不顺畅（松手时滚动太僵硬）</li>\n</ol>\n<p>试试<code>-webkit-overflow-scrolling: touch;</code></p>\n<ol start=\"10\">\n<li><code>sticky</code>定位失效</li>\n</ol>\n<p>先确定浏览器版本是不是够新，够新的话检查父辈元素有没有有没有<code>overflow: hidden;</code>，有的话得删掉（sticky定位是个蛮新的定位值，不了解的同学这里有个<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/position\" target=\"_blank\" rel=\"noopener\">传送门</a>）</p>\n<ol start=\"11\">\n<li>微信小程序<code>textarea</code>组件自动聚焦有bug</li>\n</ol>\n<p>解决办法：沟通换成<code>input</code></p>\n<ol start=\"12\">\n<li>微信小程序雪碧图在真机上定位不准</li>\n</ol>\n<p>解决办法：雪碧图换成<code>image</code></p>\n<ol start=\"13\">\n<li>在做小程序时碰到一个需求：给<code>input</code>框加个<strong>reset</strong>功能，reset完以后要重新聚焦<code>input</code>，但是这个在真机上会有莫名的bug，感兴趣的同学可以试试。</li>\n</ol>\n<p>解决办法：沟通把这个功能去掉</p>\n<ol start=\"14\">\n<li>vm、vh、vmax、vmin在ios safair下宽度是大于视口的</li>\n</ol>\n<p>解决办法：换单位或者用js兼容</p>\n<ol start=\"15\">\n<li>其他一些乱七八糟的问题</li>\n</ol>\n<p>解决办法：利用调试工具快速定位问题（调试工具用的好，什么bug都不怕），如果无法解决（例如只有某种机型有bug），沟通解决（没有什么问题是沟通解决不了的，233）</p>\n<h3 id=\"收获\"><a href=\"#收获\" class=\"headerlink\" title=\"收获\"></a>收获</h3><ol>\n<li>项目实战经验，使得html+(s)css使用得更熟练（实习前基本都是用bootstrap的样式233）</li>\n<li>更注重html语义化</li>\n<li>html+css+js基础加强，写出的代码质量更高</li>\n<li>熟悉了公司开发、合作流程</li>\n<li>将psd还原成页面更熟练，精度更高</li>\n<li>接触了pixi.js、bodmovin.js等一些动画库，更熟悉了canvas的一些原生操作</li>\n<li>考虑问题更全面</li>\n<li>emm…</li>\n</ol>\n<h3 id=\"实习以前没见过的一些css属性\"><a href=\"#实习以前没见过的一些css属性\" class=\"headerlink\" title=\"实习以前没见过的一些css属性\"></a>实习以前没见过的一些css属性</h3><ol>\n<li>css多行截断</li>\n</ol>\n<p>在实习前只知道怎么用css做单行截断，但是却不知到怎么用css做多行截断，css多行截断代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">overflow: hidden;</span><br><span class=\"line\">display: -webkit-box;</span><br><span class=\"line\">text-overflow: ellipsis;</span><br><span class=\"line\">-webkit-line-clamp: 3; /*超出多少行开始截断*/</span><br><span class=\"line\">-webkit-box-orient: vertical;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，前面加有-webkit-前缀，所以考虑到兼容性，目前只能用于移动端</p>\n<ol start=\"2\">\n<li>-webkit-tap-highlight-color</li>\n</ol>\n<p>这是用于改变a链接点击高亮的颜色</p>\n<ol start=\"3\">\n<li>-webkit-overflow-scrolling: touch</li>\n</ol>\n<p>在ios下设置了<code>overflow:scroll</code>的元素使其有惯性滚动效果。关于此属性的更多可以查看<a href=\"http://www.cnblogs.com/chris-oil/p/6164966.html\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<ol start=\"4\">\n<li>filter: blur()</li>\n</ol>\n<p>一个高斯模糊属性</p>\n<ol start=\"5\">\n<li>filter: grayscale();</li>\n</ol>\n<p>一个能使元素变灰的属性，一般用于图片上，使图片变灰。<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/filter\" target=\"_blank\" rel=\"noopener\">更多filter的操作</a></p>\n<p>…其他的等我想起再加吧</p>\n","site":{"data":{}},"excerpt":"<p>转眼间，在搜狗实习已经快一年了，在这得确收获颇丰，所以得总结一下。</p>","more":"<h3 id=\"日常工作\"><a href=\"#日常工作\" class=\"headerlink\" title=\"日常工作\"></a>日常工作</h3><ol>\n<li>负责搜狗网页搜索结果页部分日常需求开发。</li>\n<li>负责搜索app的一些活动页开发。</li>\n<li>负责搜狗英文搜索和搜狗学术搜索全部日常需求开发及一些内部组件日常维护。</li>\n<li>搜狗其他周边需求的开发等。</li>\n</ol>\n<h3 id=\"工作中遇到的问题\"><a href=\"#工作中遇到的问题\" class=\"headerlink\" title=\"工作中遇到的问题\"></a>工作中遇到的问题</h3><p>因为平时工作中主要是html+css这一块的东西，所以遇到最多的问题就是浏览器兼容问题（ie7，ie8）与移动端适配问题。</p>\n<p>下面列举一些工作中常见的一些兼容问题及解决办法：</p>\n<ol>\n<li><p>pc下mac二倍屏图像显示模糊</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background-image</span>: <span class=\"selector-tag\">-webkit-image-set</span>(<span class=\"selector-tag\">url</span>(<span class=\"selector-tag\">imgUrl</span><span class=\"keyword\">@1x</span>) <span class=\"number\">1</span>x,url(imgUrl@<span class=\"number\">2</span>x) <span class=\"number\">2</span>x);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ie背景半透明效果（不是opacity哦，opacity会把前景也变透明）</p>\n</li>\n</ol>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ieHexStr</span>: ie-hex-str(rgba(<span class=\"variable\">$color</span>,<span class=\"variable\">$alpha</span>));</span><br><span class=\"line\"><span class=\"attribute\">filter</span>:progid:DXImageTransform.Microsoft.gradient(startColorstr=<span class=\"string\">'#&#123;$ieHexStr&#125;'</span>, endColorstr=<span class=\"string\">'#&#123;$ieHexStr&#125;'</span>);</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>ie背景平铺</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filter: progid:DXImageTransform.Microsoft.AlphaImageLoader(src=$url, sizingMethod='scale')</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>ie常用hack（在工作中通常解决一些间距、行高偏差）</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">color</span><span class=\"selector-pseudo\">:red</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">color</span><span class=\"selector-pseudo\">:green</span>\\0;<span class=\"selector-tag\">ie8</span>、9、10、11</span><br><span class=\"line\"><span class=\"selector-tag\">color</span>:<span class=\"selector-id\">#000</span>\\9;<span class=\"selector-tag\">ie</span> 8、9、10</span><br><span class=\"line\"><span class=\"selector-tag\">color</span><span class=\"selector-pseudo\">:orange</span>\\9\\0;<span class=\"selector-tag\">ie9</span>、10</span><br><span class=\"line\">*<span class=\"selector-tag\">color</span><span class=\"selector-pseudo\">:yellow</span>;<span class=\"selector-tag\">ie7</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*ie以外浏览器红色 ie11绿色 ie9、10橙色 ie8黑色 ie7黄色*/</span></span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>ie7下<code>display:inline-block</code>失效</li>\n</ol>\n<p>解决办法：在ie7下<code>display:inline-block</code>只对默认是行内的元素生效，例如a、i、span</p>\n<ol start=\"6\">\n<li>ie7下定位覆盖问题</li>\n</ol>\n<p>有时候我们在定位的时候在其他浏览器下层叠顺序正常，但是在ie7下，无论给这个元素设置多高的z-index都没用，依然还会被另外一个元素覆盖，这是因为ie7下层叠顺序还得看父辈元素，这个时候，可以试试把父辈元素的z-index设高点（这个问题貌似在移动端也有，233）。</p>\n<ol start=\"7\">\n<li>webkit(blink)内核下<code>fixed</code>定位失效。</li>\n</ol>\n<p>看看<code>fixed</code>定位的父辈元素有没有设置<code>transform</code>属性，如果有的话就得去掉，因为在webkit(blink)内核下<code>transform</code>属性会导致<code>fixed</code>定位随着它定位，而不是随着窗口。</p>\n<ol start=\"8\">\n<li>在ios下给背景颜色设置<code>transparent</code>颜色不是变透明，而是变黑</li>\n</ol>\n<p>解决办法：试试<code>rgba(255,255,255,0)</code></p>\n<ol start=\"9\">\n<li>ios下某个元素滚动不顺畅（松手时滚动太僵硬）</li>\n</ol>\n<p>试试<code>-webkit-overflow-scrolling: touch;</code></p>\n<ol start=\"10\">\n<li><code>sticky</code>定位失效</li>\n</ol>\n<p>先确定浏览器版本是不是够新，够新的话检查父辈元素有没有有没有<code>overflow: hidden;</code>，有的话得删掉（sticky定位是个蛮新的定位值，不了解的同学这里有个<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/position\" target=\"_blank\" rel=\"noopener\">传送门</a>）</p>\n<ol start=\"11\">\n<li>微信小程序<code>textarea</code>组件自动聚焦有bug</li>\n</ol>\n<p>解决办法：沟通换成<code>input</code></p>\n<ol start=\"12\">\n<li>微信小程序雪碧图在真机上定位不准</li>\n</ol>\n<p>解决办法：雪碧图换成<code>image</code></p>\n<ol start=\"13\">\n<li>在做小程序时碰到一个需求：给<code>input</code>框加个<strong>reset</strong>功能，reset完以后要重新聚焦<code>input</code>，但是这个在真机上会有莫名的bug，感兴趣的同学可以试试。</li>\n</ol>\n<p>解决办法：沟通把这个功能去掉</p>\n<ol start=\"14\">\n<li>vm、vh、vmax、vmin在ios safair下宽度是大于视口的</li>\n</ol>\n<p>解决办法：换单位或者用js兼容</p>\n<ol start=\"15\">\n<li>其他一些乱七八糟的问题</li>\n</ol>\n<p>解决办法：利用调试工具快速定位问题（调试工具用的好，什么bug都不怕），如果无法解决（例如只有某种机型有bug），沟通解决（没有什么问题是沟通解决不了的，233）</p>\n<h3 id=\"收获\"><a href=\"#收获\" class=\"headerlink\" title=\"收获\"></a>收获</h3><ol>\n<li>项目实战经验，使得html+(s)css使用得更熟练（实习前基本都是用bootstrap的样式233）</li>\n<li>更注重html语义化</li>\n<li>html+css+js基础加强，写出的代码质量更高</li>\n<li>熟悉了公司开发、合作流程</li>\n<li>将psd还原成页面更熟练，精度更高</li>\n<li>接触了pixi.js、bodmovin.js等一些动画库，更熟悉了canvas的一些原生操作</li>\n<li>考虑问题更全面</li>\n<li>emm…</li>\n</ol>\n<h3 id=\"实习以前没见过的一些css属性\"><a href=\"#实习以前没见过的一些css属性\" class=\"headerlink\" title=\"实习以前没见过的一些css属性\"></a>实习以前没见过的一些css属性</h3><ol>\n<li>css多行截断</li>\n</ol>\n<p>在实习前只知道怎么用css做单行截断，但是却不知到怎么用css做多行截断，css多行截断代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">overflow: hidden;</span><br><span class=\"line\">display: -webkit-box;</span><br><span class=\"line\">text-overflow: ellipsis;</span><br><span class=\"line\">-webkit-line-clamp: 3; /*超出多少行开始截断*/</span><br><span class=\"line\">-webkit-box-orient: vertical;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，前面加有-webkit-前缀，所以考虑到兼容性，目前只能用于移动端</p>\n<ol start=\"2\">\n<li>-webkit-tap-highlight-color</li>\n</ol>\n<p>这是用于改变a链接点击高亮的颜色</p>\n<ol start=\"3\">\n<li>-webkit-overflow-scrolling: touch</li>\n</ol>\n<p>在ios下设置了<code>overflow:scroll</code>的元素使其有惯性滚动效果。关于此属性的更多可以查看<a href=\"http://www.cnblogs.com/chris-oil/p/6164966.html\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<ol start=\"4\">\n<li>filter: blur()</li>\n</ol>\n<p>一个高斯模糊属性</p>\n<ol start=\"5\">\n<li>filter: grayscale();</li>\n</ol>\n<p>一个能使元素变灰的属性，一般用于图片上，使图片变灰。<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/filter\" target=\"_blank\" rel=\"noopener\">更多filter的操作</a></p>\n<p>…其他的等我想起再加吧</p>"},{"title":"vue-cli-multipage","date":"2018-03-06T03:40:12.000Z","_content":"# 基于vue-cli的多页面应用脚手架\n\n## 前言\n\n[原文](https://jayzangwill.github.io/blog/2018/03/06/vue-cli-multipage/#more)\n\n[掘金](https://juejin.im/post/5a9e1716f265da237a4c85f9)\n\n[知乎](https://zhuanlan.zhihu.com/p/34272390)&[知乎专栏](https://zhuanlan.zhihu.com/jayzangwill)\n\n目前vue-cli生成的配置都是做多页面的，然而，我们有时也会有多页面的需求。\n同时，之前借用的[这个](https://github.com/breezefeng/vue-cli-multipage)多页面例子貌似作者不再维护了，导致webpack升级到webpack2就无法使用了，所以我就参考这个例子自己弄了个多页面脚手架，会不定期维护的。\n\n代码地址：https://github.com/JayZangwill/vue-multipage\n有什么问题可以在issues上提，欢迎star\n\n<!-- more -->\n\n## 下载&使用\n\n``` bash\ngit clone https://github.com/JayZangwill/vue-multipage\ncd vue-multipage\nnpm i\n\n//开发模式（运行完后要在浏览器输入http://localhost:8081/module/index）\nnpm run dev\n\n//生产模式\nnpmrun build\n```\n## 目录结构\n```\nvue-multipage\n  |---build\n  |---config\n  |---src\n    |---assets   \n    |---components  组件\n      |---HelloWorld.vue\n      |---other.vue\n    |---module多页面模块\n      |---index  \n        |---index.html\n        |---index.js\n        |---App.vue\n      |---other\n        |---index.html\n        |---other.js\n        |---App.vue\n```\n\n## 说明\n\n如需添加页面需要在**module**目录下新建文件夹，然后文件夹里必须包括`.hmtl，.js，.vue`文件作为入口文件。\n\n运行`npm run dev`命令后，需要在浏览器输入`http://localhost:8081/module/+module下目录文件夹名/+文件夹名里的html文件`\n\n## 已知bug\n\n1. 目前公用css还无法分离\n2. 开发模式需要手动输入url打开页面，不能直接打开。\n\n同时也欢迎提代码pull来帮助我解决bug\n\n## 参考\n\n[vue-cli + webpack 多页面实例应用](http://www.cnblogs.com/fengyuqing/p/vue_cli_webpack.html)\n\n","source":"_posts/vue-cli-multipage.md","raw":"---\ntitle: vue-cli-multipage\ndate: 2018-03-06 11:40:12\ntags: [vue,vue-cli]\n---\n# 基于vue-cli的多页面应用脚手架\n\n## 前言\n\n[原文](https://jayzangwill.github.io/blog/2018/03/06/vue-cli-multipage/#more)\n\n[掘金](https://juejin.im/post/5a9e1716f265da237a4c85f9)\n\n[知乎](https://zhuanlan.zhihu.com/p/34272390)&[知乎专栏](https://zhuanlan.zhihu.com/jayzangwill)\n\n目前vue-cli生成的配置都是做多页面的，然而，我们有时也会有多页面的需求。\n同时，之前借用的[这个](https://github.com/breezefeng/vue-cli-multipage)多页面例子貌似作者不再维护了，导致webpack升级到webpack2就无法使用了，所以我就参考这个例子自己弄了个多页面脚手架，会不定期维护的。\n\n代码地址：https://github.com/JayZangwill/vue-multipage\n有什么问题可以在issues上提，欢迎star\n\n<!-- more -->\n\n## 下载&使用\n\n``` bash\ngit clone https://github.com/JayZangwill/vue-multipage\ncd vue-multipage\nnpm i\n\n//开发模式（运行完后要在浏览器输入http://localhost:8081/module/index）\nnpm run dev\n\n//生产模式\nnpmrun build\n```\n## 目录结构\n```\nvue-multipage\n  |---build\n  |---config\n  |---src\n    |---assets   \n    |---components  组件\n      |---HelloWorld.vue\n      |---other.vue\n    |---module多页面模块\n      |---index  \n        |---index.html\n        |---index.js\n        |---App.vue\n      |---other\n        |---index.html\n        |---other.js\n        |---App.vue\n```\n\n## 说明\n\n如需添加页面需要在**module**目录下新建文件夹，然后文件夹里必须包括`.hmtl，.js，.vue`文件作为入口文件。\n\n运行`npm run dev`命令后，需要在浏览器输入`http://localhost:8081/module/+module下目录文件夹名/+文件夹名里的html文件`\n\n## 已知bug\n\n1. 目前公用css还无法分离\n2. 开发模式需要手动输入url打开页面，不能直接打开。\n\n同时也欢迎提代码pull来帮助我解决bug\n\n## 参考\n\n[vue-cli + webpack 多页面实例应用](http://www.cnblogs.com/fengyuqing/p/vue_cli_webpack.html)\n\n","slug":"vue-cli-multipage","published":1,"updated":"2020-04-07T03:29:17.939Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8qzc35c00112cl6riqtwggb","content":"<h1 id=\"基于vue-cli的多页面应用脚手架\"><a href=\"#基于vue-cli的多页面应用脚手架\" class=\"headerlink\" title=\"基于vue-cli的多页面应用脚手架\"></a>基于vue-cli的多页面应用脚手架</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><a href=\"https://jayzangwill.github.io/blog/2018/03/06/vue-cli-multipage/#more\">原文</a></p>\n<p><a href=\"https://juejin.im/post/5a9e1716f265da237a4c85f9\" target=\"_blank\" rel=\"noopener\">掘金</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/34272390\" target=\"_blank\" rel=\"noopener\">知乎</a>&amp;<a href=\"https://zhuanlan.zhihu.com/jayzangwill\" target=\"_blank\" rel=\"noopener\">知乎专栏</a></p>\n<p>目前vue-cli生成的配置都是做多页面的，然而，我们有时也会有多页面的需求。<br>同时，之前借用的<a href=\"https://github.com/breezefeng/vue-cli-multipage\" target=\"_blank\" rel=\"noopener\">这个</a>多页面例子貌似作者不再维护了，导致webpack升级到webpack2就无法使用了，所以我就参考这个例子自己弄了个多页面脚手架，会不定期维护的。</p>\n<p>代码地址：<a href=\"https://github.com/JayZangwill/vue-multipage\" target=\"_blank\" rel=\"noopener\">https://github.com/JayZangwill/vue-multipage</a><br>有什么问题可以在issues上提，欢迎star</p>\n<a id=\"more\"></a>\n<h2 id=\"下载-amp-使用\"><a href=\"#下载-amp-使用\" class=\"headerlink\" title=\"下载&amp;使用\"></a>下载&amp;使用</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/JayZangwill/vue-multipage</span><br><span class=\"line\"><span class=\"built_in\">cd</span> vue-multipage</span><br><span class=\"line\">npm i</span><br><span class=\"line\"></span><br><span class=\"line\">//开发模式（运行完后要在浏览器输入http://localhost:8081/module/index）</span><br><span class=\"line\">npm run dev</span><br><span class=\"line\"></span><br><span class=\"line\">//生产模式</span><br><span class=\"line\">npmrun build</span><br></pre></td></tr></table></figure>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue-multipage</span><br><span class=\"line\">  |---build</span><br><span class=\"line\">  |---config</span><br><span class=\"line\">  |---src</span><br><span class=\"line\">    |---assets   </span><br><span class=\"line\">    |---components  组件</span><br><span class=\"line\">      |---HelloWorld.vue</span><br><span class=\"line\">      |---other.vue</span><br><span class=\"line\">    |---module多页面模块</span><br><span class=\"line\">      |---index  </span><br><span class=\"line\">        |---index.html</span><br><span class=\"line\">        |---index.js</span><br><span class=\"line\">        |---App.vue</span><br><span class=\"line\">      |---other</span><br><span class=\"line\">        |---index.html</span><br><span class=\"line\">        |---other.js</span><br><span class=\"line\">        |---App.vue</span><br></pre></td></tr></table></figure>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>如需添加页面需要在<strong>module</strong>目录下新建文件夹，然后文件夹里必须包括<code>.hmtl，.js，.vue</code>文件作为入口文件。</p>\n<p>运行<code>npm run dev</code>命令后，需要在浏览器输入<code>http://localhost:8081/module/+module下目录文件夹名/+文件夹名里的html文件</code></p>\n<h2 id=\"已知bug\"><a href=\"#已知bug\" class=\"headerlink\" title=\"已知bug\"></a>已知bug</h2><ol>\n<li>目前公用css还无法分离</li>\n<li>开发模式需要手动输入url打开页面，不能直接打开。</li>\n</ol>\n<p>同时也欢迎提代码pull来帮助我解决bug</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.cnblogs.com/fengyuqing/p/vue_cli_webpack.html\" target=\"_blank\" rel=\"noopener\">vue-cli + webpack 多页面实例应用</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"基于vue-cli的多页面应用脚手架\"><a href=\"#基于vue-cli的多页面应用脚手架\" class=\"headerlink\" title=\"基于vue-cli的多页面应用脚手架\"></a>基于vue-cli的多页面应用脚手架</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><a href=\"https://jayzangwill.github.io/blog/2018/03/06/vue-cli-multipage/#more\">原文</a></p>\n<p><a href=\"https://juejin.im/post/5a9e1716f265da237a4c85f9\" target=\"_blank\" rel=\"noopener\">掘金</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/34272390\" target=\"_blank\" rel=\"noopener\">知乎</a>&amp;<a href=\"https://zhuanlan.zhihu.com/jayzangwill\" target=\"_blank\" rel=\"noopener\">知乎专栏</a></p>\n<p>目前vue-cli生成的配置都是做多页面的，然而，我们有时也会有多页面的需求。<br>同时，之前借用的<a href=\"https://github.com/breezefeng/vue-cli-multipage\" target=\"_blank\" rel=\"noopener\">这个</a>多页面例子貌似作者不再维护了，导致webpack升级到webpack2就无法使用了，所以我就参考这个例子自己弄了个多页面脚手架，会不定期维护的。</p>\n<p>代码地址：<a href=\"https://github.com/JayZangwill/vue-multipage\" target=\"_blank\" rel=\"noopener\">https://github.com/JayZangwill/vue-multipage</a><br>有什么问题可以在issues上提，欢迎star</p>","more":"<h2 id=\"下载-amp-使用\"><a href=\"#下载-amp-使用\" class=\"headerlink\" title=\"下载&amp;使用\"></a>下载&amp;使用</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/JayZangwill/vue-multipage</span><br><span class=\"line\"><span class=\"built_in\">cd</span> vue-multipage</span><br><span class=\"line\">npm i</span><br><span class=\"line\"></span><br><span class=\"line\">//开发模式（运行完后要在浏览器输入http://localhost:8081/module/index）</span><br><span class=\"line\">npm run dev</span><br><span class=\"line\"></span><br><span class=\"line\">//生产模式</span><br><span class=\"line\">npmrun build</span><br></pre></td></tr></table></figure>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue-multipage</span><br><span class=\"line\">  |---build</span><br><span class=\"line\">  |---config</span><br><span class=\"line\">  |---src</span><br><span class=\"line\">    |---assets   </span><br><span class=\"line\">    |---components  组件</span><br><span class=\"line\">      |---HelloWorld.vue</span><br><span class=\"line\">      |---other.vue</span><br><span class=\"line\">    |---module多页面模块</span><br><span class=\"line\">      |---index  </span><br><span class=\"line\">        |---index.html</span><br><span class=\"line\">        |---index.js</span><br><span class=\"line\">        |---App.vue</span><br><span class=\"line\">      |---other</span><br><span class=\"line\">        |---index.html</span><br><span class=\"line\">        |---other.js</span><br><span class=\"line\">        |---App.vue</span><br></pre></td></tr></table></figure>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>如需添加页面需要在<strong>module</strong>目录下新建文件夹，然后文件夹里必须包括<code>.hmtl，.js，.vue</code>文件作为入口文件。</p>\n<p>运行<code>npm run dev</code>命令后，需要在浏览器输入<code>http://localhost:8081/module/+module下目录文件夹名/+文件夹名里的html文件</code></p>\n<h2 id=\"已知bug\"><a href=\"#已知bug\" class=\"headerlink\" title=\"已知bug\"></a>已知bug</h2><ol>\n<li>目前公用css还无法分离</li>\n<li>开发模式需要手动输入url打开页面，不能直接打开。</li>\n</ol>\n<p>同时也欢迎提代码pull来帮助我解决bug</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.cnblogs.com/fengyuqing/p/vue_cli_webpack.html\" target=\"_blank\" rel=\"noopener\">vue-cli + webpack 多页面实例应用</a></p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck8qzc33l00002cl60cdipz1x","tag_id":"ck8qzc33t00022cl68rjknquc","_id":"ck8qzc34o000h2cl6bu00573x"},{"post_id":"ck8qzc33l00002cl60cdipz1x","tag_id":"ck8qzc34400062cl6zimw314i","_id":"ck8qzc34q000j2cl6nilcbl4w"},{"post_id":"ck8qzc33l00002cl60cdipz1x","tag_id":"ck8qzc34900092cl67kh2cdys","_id":"ck8qzc34s000m2cl68q6lijf3"},{"post_id":"ck8qzc33l00002cl60cdipz1x","tag_id":"ck8qzc34h000c2cl6c6hot0yl","_id":"ck8qzc34v000o2cl63f4gixus"},{"post_id":"ck8qzc33q00012cl6aj3rsbmn","tag_id":"ck8qzc34m000f2cl6ygom1dtu","_id":"ck8qzc34z000r2cl6fa4nrfqx"},{"post_id":"ck8qzc33v00032cl6wglj4ewi","tag_id":"ck8qzc34r000l2cl6kt1td75g","_id":"ck8qzc352000t2cl6w4i8idij"},{"post_id":"ck8qzc350000s2cl6bq8ip6g2","tag_id":"ck8qzc34400062cl6zimw314i","_id":"ck8qzc354000w2cl6a1dz41wc"},{"post_id":"ck8qzc350000s2cl6bq8ip6g2","tag_id":"ck8qzc33t00022cl68rjknquc","_id":"ck8qzc358000y2cl69bljq1b2"},{"post_id":"ck8qzc33y00042cl6we9f0jbp","tag_id":"ck8qzc34y000q2cl6ceyh3wx0","_id":"ck8qzc35f00132cl67n9si6fa"},{"post_id":"ck8qzc33y00042cl6we9f0jbp","tag_id":"ck8qzc34400062cl6zimw314i","_id":"ck8qzc35g00142cl6tcsiuaqj"},{"post_id":"ck8qzc33y00042cl6we9f0jbp","tag_id":"ck8qzc35b00102cl6hquu6cef","_id":"ck8qzc35h00162cl6plhexaa0"},{"post_id":"ck8qzc34300052cl6u9jwtz7t","tag_id":"ck8qzc35b00102cl6hquu6cef","_id":"ck8qzc35i00182cl6lww88wgv"},{"post_id":"ck8qzc34300052cl6u9jwtz7t","tag_id":"ck8qzc34400062cl6zimw314i","_id":"ck8qzc35j00192cl6miyiaat5"},{"post_id":"ck8qzc34500072cl6p763v83e","tag_id":"ck8qzc34y000q2cl6ceyh3wx0","_id":"ck8qzc35k001c2cl6iatt8ab3"},{"post_id":"ck8qzc34500072cl6p763v83e","tag_id":"ck8qzc35j001a2cl6ikkdpp21","_id":"ck8qzc35l001d2cl67um6glzn"},{"post_id":"ck8qzc34700082cl6y0pkn4ow","tag_id":"ck8qzc35k001b2cl6palez06m","_id":"ck8qzc35m001f2cl6qbqjm0xr"},{"post_id":"ck8qzc34700082cl6y0pkn4ow","tag_id":"ck8qzc34400062cl6zimw314i","_id":"ck8qzc35m001g2cl6u6dxaj85"},{"post_id":"ck8qzc34a000a2cl6fbr93pij","tag_id":"ck8qzc35l001e2cl6ka9rsydr","_id":"ck8qzc35o001i2cl6kk4pxlv9"},{"post_id":"ck8qzc34a000a2cl6fbr93pij","tag_id":"ck8qzc34400062cl6zimw314i","_id":"ck8qzc35o001j2cl6dsf3d49a"},{"post_id":"ck8qzc34e000b2cl6sp9zro3i","tag_id":"ck8qzc35k001b2cl6palez06m","_id":"ck8qzc35q001l2cl6bt085hqd"},{"post_id":"ck8qzc34e000b2cl6sp9zro3i","tag_id":"ck8qzc34400062cl6zimw314i","_id":"ck8qzc35r001m2cl61xztnlmy"},{"post_id":"ck8qzc34h000d2cl6w7q7o5f2","tag_id":"ck8qzc34400062cl6zimw314i","_id":"ck8qzc35x001q2cl6hzsujkmn"},{"post_id":"ck8qzc34h000d2cl6w7q7o5f2","tag_id":"ck8qzc35b00102cl6hquu6cef","_id":"ck8qzc35z001r2cl6rvzdxvmf"},{"post_id":"ck8qzc34h000d2cl6w7q7o5f2","tag_id":"ck8qzc35s001n2cl6ilgyskur","_id":"ck8qzc361001t2cl6vxcd64io"},{"post_id":"ck8qzc34h000d2cl6w7q7o5f2","tag_id":"ck8qzc33t00022cl68rjknquc","_id":"ck8qzc362001u2cl6un3gkvep"},{"post_id":"ck8qzc34h000d2cl6w7q7o5f2","tag_id":"ck8qzc34y000q2cl6ceyh3wx0","_id":"ck8qzc364001w2cl6nixv1vcs"},{"post_id":"ck8qzc34k000e2cl6a5y7ipuu","tag_id":"ck8qzc35k001b2cl6palez06m","_id":"ck8qzc365001x2cl6m680lot7"},{"post_id":"ck8qzc34k000e2cl6a5y7ipuu","tag_id":"ck8qzc34400062cl6zimw314i","_id":"ck8qzc369001z2cl63jw0mirz"},{"post_id":"ck8qzc34m000g2cl63z7ox97l","tag_id":"ck8qzc34y000q2cl6ceyh3wx0","_id":"ck8qzc36a00202cl6wnipjuxp"},{"post_id":"ck8qzc34m000g2cl63z7ox97l","tag_id":"ck8qzc34400062cl6zimw314i","_id":"ck8qzc36c00222cl68eyhj5kw"},{"post_id":"ck8qzc34m000g2cl63z7ox97l","tag_id":"ck8qzc35b00102cl6hquu6cef","_id":"ck8qzc36e00232cl6h0kp7gwg"},{"post_id":"ck8qzc34p000i2cl6kxbxx2vo","tag_id":"ck8qzc367001y2cl6nwl423yz","_id":"ck8qzc36g00252cl6rjwb3fco"},{"post_id":"ck8qzc34p000i2cl6kxbxx2vo","tag_id":"ck8qzc36a00212cl62yoqw9jf","_id":"ck8qzc36h00262cl6v7rhjq0f"},{"post_id":"ck8qzc34q000k2cl6mkpxc5ed","tag_id":"ck8qzc34400062cl6zimw314i","_id":"ck8qzc36j00282cl6ikgambjr"},{"post_id":"ck8qzc34q000k2cl6mkpxc5ed","tag_id":"ck8qzc36e00242cl6owd17frc","_id":"ck8qzc36k00292cl6o95adzpc"},{"post_id":"ck8qzc34t000n2cl6bys40mod","tag_id":"ck8qzc34y000q2cl6ceyh3wx0","_id":"ck8qzc36q002c2cl6fz3d7uwi"},{"post_id":"ck8qzc34t000n2cl6bys40mod","tag_id":"ck8qzc36k002a2cl6w5r7n6qt","_id":"ck8qzc36r002d2cl6u45c0j0a"},{"post_id":"ck8qzc34w000p2cl66oprvg8i","tag_id":"ck8qzc34400062cl6zimw314i","_id":"ck8qzc36t002f2cl6atx6ptfj"},{"post_id":"ck8qzc34w000p2cl66oprvg8i","tag_id":"ck8qzc35b00102cl6hquu6cef","_id":"ck8qzc36u002g2cl67o1so62f"},{"post_id":"ck8qzc352000u2cl6vf10vg8f","tag_id":"ck8qzc35j001a2cl6ikkdpp21","_id":"ck8qzc36w002i2cl6f476a6ru"},{"post_id":"ck8qzc356000x2cl6yqqsio6l","tag_id":"ck8qzc36u002h2cl6jeqn9ozy","_id":"ck8qzc36y002k2cl6sbh7xy3o"},{"post_id":"ck8qzc358000z2cl6lnzdq56x","tag_id":"ck8qzc35j001a2cl6ikkdpp21","_id":"ck8qzc372002m2cl6z0un1lmw"},{"post_id":"ck8qzc358000z2cl6lnzdq56x","tag_id":"ck8qzc34400062cl6zimw314i","_id":"ck8qzc375002n2cl6uzfc99b4"},{"post_id":"ck8qzc35c00112cl6riqtwggb","tag_id":"ck8qzc35l001e2cl6ka9rsydr","_id":"ck8qzc379002p2cl6w7kzfz78"},{"post_id":"ck8qzc35c00112cl6riqtwggb","tag_id":"ck8qzc377002o2cl6mmvz6mu4","_id":"ck8qzc379002q2cl6z6gam4op"}],"Tag":[{"name":"css","_id":"ck8qzc33t00022cl68rjknquc"},{"name":"基础","_id":"ck8qzc34400062cl6zimw314i"},{"name":"盒模型","_id":"ck8qzc34900092cl67kh2cdys"},{"name":"定位","_id":"ck8qzc34h000c2cl6c6hot0yl"},{"name":"sass","_id":"ck8qzc34m000f2cl6ygom1dtu"},{"name":"hexo","_id":"ck8qzc34r000l2cl6kt1td75g"},{"name":"面试","_id":"ck8qzc34y000q2cl6ceyh3wx0"},{"name":"javascript","_id":"ck8qzc35b00102cl6hquu6cef"},{"name":"心情","_id":"ck8qzc35j001a2cl6ikkdpp21"},{"name":"angular","_id":"ck8qzc35k001b2cl6palez06m"},{"name":"vue","_id":"ck8qzc35l001e2cl6ka9rsydr"},{"name":"html","_id":"ck8qzc35s001n2cl6ilgyskur"},{"name":"移动端","_id":"ck8qzc367001y2cl6nwl423yz"},{"name":"适配","_id":"ck8qzc36a00212cl62yoqw9jf"},{"name":"浏览器","_id":"ck8qzc36e00242cl6owd17frc"},{"name":"其他","_id":"ck8qzc36k002a2cl6w5r7n6qt"},{"name":"mongodb","_id":"ck8qzc36u002h2cl6jeqn9ozy"},{"name":"vue-cli","_id":"ck8qzc377002o2cl6mmvz6mu4"}]}}